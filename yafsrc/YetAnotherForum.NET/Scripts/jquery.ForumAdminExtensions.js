(function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
})(this, function() {
    "use strict";
    var hookCallback;
    function hooks() {
        return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
        hookCallback = callback;
    }
    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
    }
    function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
    }
    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }
    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
        } else {
            var k;
            for (k in obj) {
                if (hasOwnProp(obj, k)) {
                    return false;
                }
            }
            return true;
        }
    }
    function isUndefined(input) {
        return input === void 0;
    }
    function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
    }
    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }
    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }
        if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
        }
        return a;
    }
    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }
    function defaultParsingFlags() {
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
        };
    }
    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }
    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function(fun) {
            var t = Object(this), len = t.length >>> 0, i;
            for (i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }
            return false;
        };
    }
    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
                return i != null;
            }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict) {
                isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            } else {
                return isNowValid;
            }
        }
        return m._isValid;
    }
    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }
        return m;
    }
    var momentProperties = hooks.momentProperties = [], updateInProgress = false;
    function copyConfig(to, from) {
        var i, prop, val;
        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }
        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }
        return to;
    }
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }
    function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
        }
    }
    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [], arg, i, key;
                for (i = 0; i < arguments.length; i++) {
                    arg = "";
                    if (typeof arguments[i] === "object") {
                        arg += "\n[" + i + "] ";
                        for (key in arguments[0]) {
                            if (hasOwnProp(arguments[0], key)) {
                                arg += key + ": " + arguments[0][key] + ", ";
                            }
                        }
                        arg = arg.slice(0, -2);
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    function set(config) {
        var prop, i;
        for (i in config) {
            if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction(prop)) {
                    this[i] = prop;
                } else {
                    this["_" + i] = prop;
                }
            }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
    }
    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }
    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }
    var keys;
    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function(obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }
    var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
    };
    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now) : output;
    }
    function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;
        return (sign ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === "string") {
            func = function() {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function() {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function() {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }
    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }
        return function(mom) {
            var output = "", i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
        return formatFunctions[format](m);
    }
    function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }
        return format;
    }
    var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
        var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format || !formatUpper) {
            return format;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
            if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
                return tok.slice(1);
            }
            return tok;
        }).join("");
        return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
        return this._invalidDate;
    }
    var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
        return this._ordinal.replace("%d", number);
    }
    var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
    };
    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? "future" : "past"];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }
        return normalizedInput;
    }
    var priorities = {};
    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }
    function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
                units.push({
                    unit: u,
                    priority: priorities[u]
                });
            }
        }
        units.sort(function(a, b) {
            return a.priority - b.priority;
        });
        return units;
    }
    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function absFloor(number) {
        if (number < 0) {
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }
        return value;
    }
    function makeGetSet(unit, keepTime) {
        return function(value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }
    function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
    }
    function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                value = toInt(value);
                mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
            } else {
                mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
            }
        }
    }
    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }
    function stringSet(units, value) {
        if (typeof units === "object") {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units), i;
            for (i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }
    var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
    regexes = {};
    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
            return isStrict && strictRegex ? strictRegex : regex;
        };
    }
    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }
        return regexes[token](config._strict, config._locale);
    }
    function unescapeFormat(s) {
        return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }
    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var tokens = {};
    function addParseToken(token, callback) {
        var i, func = callback;
        if (typeof token === "string") {
            token = [ token ];
        }
        if (isNumber(callback)) {
            func = function(input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }
    function addWeekParseToken(token, callback) {
        addParseToken(token, function(input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }
    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }
    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    function mod(n, x) {
        return (n % x + x) % x;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function(o) {
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }
    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    addFormatToken("M", [ "MM", 2 ], "Mo", function() {
        return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format) {
        return this.localeData().monthsShort(this, format);
    });
    addFormatToken("MMMM", 0, 0, function(format) {
        return this.localeData().months(this, format);
    });
    addUnitAlias("month", "M");
    addUnitPriority("month", 8);
    addRegexToken("M", match1to2);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });
    addParseToken([ "M", "MM" ], function(input, array) {
        array[MONTH] = toInt(input) - 1;
    });
    addParseToken([ "MMM", "MMMM" ], function(input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    function localeMonths(m, format) {
        if (!m) {
            return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? "format" : "standalone"][m.month()];
    }
    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"][m.month()];
    }
    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([ 2e3, i ]);
                this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
            }
        }
        if (strict) {
            if (format === "MMM") {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === "MMM") {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }
    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }
        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
            mom = createUTC([ 2e3, i ]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
                this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
            }
            if (!strict && !this._monthsParse[i]) {
                regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format === "MMMM" && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === "MMM" && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }
    function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
            return mom;
        }
        if (typeof value === "string") {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
    }
    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, "Month");
        }
    }
    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, "_monthsShortRegex")) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }
    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, "_monthsRegex")) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
    }
    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
            mom = createUTC([ 2e3, i ]);
            shortPieces.push(this.monthsShort(mom, ""));
            longPieces.push(this.months(mom, ""));
            mixedPieces.push(this.months(mom, ""));
            mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
    }
    addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
    });
    addFormatToken(0, [ "YY", 2 ], 0, function() {
        return this.year() % 100;
    });
    addFormatToken(0, [ "YYYY", 4 ], 0, "year");
    addFormatToken(0, [ "YYYYY", 5 ], 0, "year");
    addFormatToken(0, [ "YYYYYY", 6, true ], 0, "year");
    addUnitAlias("year", "y");
    addUnitPriority("year", 1);
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken([ "YYYYY", "YYYYYY" ], YEAR);
    addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", true);
    function getIsLeapYear() {
        return isLeapYear(this.year());
    }
    function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
    }
    function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
    }
    function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }
        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }
    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }
        return {
            week: resWeek,
            year: resYear
        };
    }
    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken("w", [ "ww", 2 ], "wo", "week");
    addFormatToken("W", [ "WW", 2 ], "Wo", "isoWeek");
    addUnitAlias("week", "w");
    addUnitAlias("isoWeek", "W");
    addUnitPriority("week", 5);
    addUnitPriority("isoWeek", 5);
    addRegexToken("w", match1to2);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken([ "w", "ww", "W", "WW" ], function(input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });
    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
        dow: 0,
        doy: 6
    };
    function localeFirstDayOfWeek() {
        return this._week.dow;
    }
    function localeFirstDayOfYear() {
        return this._week.doy;
    }
    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format) {
        return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken("ddd", 0, 0, function(format) {
        return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken("dddd", 0, 0, function(format) {
        return this.localeData().weekdays(this, format);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addUnitAlias("day", "d");
    addUnitAlias("weekday", "e");
    addUnitAlias("isoWeekday", "E");
    addUnitPriority("day", 11);
    addUnitPriority("weekday", 11);
    addUnitPriority("isoWeekday", 11);
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });
    addWeekParseToken([ "dd", "ddd", "dddd" ], function(input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });
    addWeekParseToken([ "d", "e", "E" ], function(input, week, config, token) {
        week[token] = toInt(input);
    });
    function parseWeekday(input, locale) {
        if (typeof input !== "string") {
            return input;
        }
        if (!isNaN(input)) {
            return parseInt(input, 10);
        }
        input = locale.weekdaysParse(input);
        if (typeof input === "number") {
            return input;
        }
        return null;
    }
    function parseIsoWeekday(input, locale) {
        if (typeof input === "string") {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }
    function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
                mom = createUTC([ 2e3, 1 ]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
            }
        }
        if (strict) {
            if (format === "dddd") {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === "ddd") {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === "dddd") {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === "ddd") {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }
    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
            mom = createUTC([ 2e3, 1 ]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
                this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
                this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
            }
            if (!this._weekdaysParse[i]) {
                regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
                this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }
    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, "d");
        } else {
            return day;
        }
    }
    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }
    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }
    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, "_weekdaysShortRegex")) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }
    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, "_weekdaysMinRegex")) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }
    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            mom = createUTC([ 2e3, 1 ]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ""));
            shortp = regexEscape(this.weekdaysShort(mom, ""));
            longp = regexEscape(this.weekdays(mom, ""));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
        this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
    }
    function hFormat() {
        return this.hours() % 12 || 12;
    }
    function kFormat() {
        return this.hours() || 24;
    }
    addFormatToken("H", [ "HH", 2 ], 0, "hour");
    addFormatToken("h", [ "hh", 2 ], 0, hFormat);
    addFormatToken("k", [ "kk", 2 ], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }
    meridiem("a", true);
    meridiem("A", false);
    addUnitAlias("hour", "h");
    addUnitPriority("hour", 13);
    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2);
    addRegexToken("h", match1to2);
    addRegexToken("k", match1to2);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("kk", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken([ "H", "HH" ], HOUR);
    addParseToken([ "k", "kk" ], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken([ "a", "A" ], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken([ "h", "hh" ], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? "pm" : "PM";
        } else {
            return isLower ? "am" : "AM";
        }
    }
    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {}, localeFamilies = {}, globalLocale;
    function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
                return i;
            }
        }
        return minl;
    }
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;
        while (i < names.length) {
            split = normalizeLocale(names[i]).split("-");
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join("-"));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }
    function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === undefined && typeof module !== "undefined" && module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                aliasedRequire = require;
                aliasedRequire("./locale/" + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {
                locales[name] = null;
            }
        }
        return locales[name];
    }
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }
            if (data) {
                globalLocale = data;
            } else {
                if (typeof console !== "undefined" && console.warn) {
                    console.warn("Locale " + key + " not found. Did you forget to load it?");
                }
            }
        }
        return globalLocale._abbr;
    }
    function defineLocale(name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change " + "an existing locale. moment.defineLocale(localeName, " + "config) should only be used for creating a new locale " + "See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function(x) {
                    defineLocale(x.name, x.config);
                });
            }
            getSetGlobalLocale(name);
            return locales[name];
        } else {
            delete locales[name];
            return null;
        }
    }
    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            if (locales[name] != null && locales[name].parentLocale != null) {
                locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
                tmpLocale = loadLocale(name);
                if (tmpLocale != null) {
                    parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                    config.abbr = name;
                }
                locale = new Locale(config);
                locale.parentLocale = locales[name];
                locales[name] = locale;
            }
            getSetGlobalLocale(name);
        } else {
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                    if (name === getSetGlobalLocale()) {
                        getSetGlobalLocale(name);
                    }
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }
    function getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }
        if (!key) {
            return globalLocale;
        }
        if (!isArray(key)) {
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [ key ];
        }
        return chooseLocale(key);
    }
    function listLocales() {
        return keys(locales);
    }
    function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
        }
        return m;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/ ], [ "YYYY-MM-DD", /\d{4}-\d\d-\d\d/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d\d-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d\d/, false ], [ "YYYY-DDD", /\d{4}-\d{3}/ ], [ "YYYY-MM", /\d{4}-\d\d/, false ], [ "YYYYYYMMDD", /[+-]\d{10}/ ], [ "YYYYMMDD", /\d{8}/ ], [ "GGGG[W]WWE", /\d{4}W\d{3}/ ], [ "GGGG[W]WW", /\d{4}W\d{2}/, false ], [ "YYYYDDD", /\d{7}/ ], [ "YYYYMM", /\d{6}/, false ], [ "YYYY", /\d{4}/, false ] ], isoTimes = [ [ "HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/ ], [ "HH:mm:ss", /\d\d:\d\d:\d\d/ ], [ "HH:mm", /\d\d:\d\d/ ], [ "HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/ ], [ "HHmmss,SSSS", /\d\d\d\d\d\d,\d+/ ], [ "HHmmss", /\d\d\d\d\d\d/ ], [ "HHmm", /\d\d\d\d/ ], [ "HH", /\d\d/ ] ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };
    function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat;
        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        timeFormat = (match[2] || " ") + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = "Z";
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [ untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10) ];
        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }
        return result;
    }
    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2e3 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }
    function preprocessRFC2822(s) {
        return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            return 0;
        } else {
            var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
            parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }
        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }
        if (config._strict) {
            config._isValid = false;
        } else {
            hooks.createFromInputFallback(config);
        }
    }
    hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), " + "which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are " + "discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    });
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }
    function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [ nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate() ];
        }
        return [ nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate() ];
    }
    function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
            return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }
        for (;i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
            week = defaults(w.w, curWeek.week);
            if (w.d != null) {
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }
    hooks.ISO_8601 = function() {};
    hooks.RFC_2822 = function() {};
    function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0, era;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        era = getParsingFlags(config).era;
        if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) {
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            return hour;
        }
    }
    function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false;
        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }
        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
                validFormatFound = true;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
                if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                    if (validFormatFound) {
                        bestFormatIsValid = true;
                    }
                }
            } else {
                if (currentScore < scoreToBeat) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                }
            }
        }
        extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
        if (config._d) {
            return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === undefined ? i.date : i.day;
        config._a = map([ i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond ], function(obj) {
            return obj && parseInt(obj, 10);
        });
        configFromArray(config);
    }
    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = undefined;
        }
        return res;
    }
    function prepareConfig(config) {
        var input = config._i, format = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format === undefined && input === "") {
            return createInvalid({
                nullInput: true
            });
        }
        if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }
        if (!isValid(config)) {
            config._d = null;
        }
        return config;
    }
    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function(obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        if (format === true || format === false) {
            strict = format;
            format = undefined;
        }
        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
            input = undefined;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        return createFromConfig(c);
    }
    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }
    var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    });
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }
    function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
    }
    function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
    }
    var now = function() {
        return Date.now ? Date.now() : +new Date();
    };
    var ordering = [ "year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond" ];
    function isDurationValid(m) {
        var key, unitHasDecimal = false, i;
        for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }
        for (i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false;
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }
        return true;
    }
    function isValid$1() {
        return this._isValid;
    }
    function createInvalid$1() {
        return createDuration(NaN);
    }
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || normalizedInput.isoWeek || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 1e3 * 60 * 60;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
    }
    function isDuration(obj) {
        return obj instanceof Duration;
    }
    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }
    function offset(token, separator) {
        addFormatToken(token, 0, 0, function() {
            var offset = this.utcOffset(), sign = "+";
            if (offset < 0) {
                offset = -offset;
                sign = "-";
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
        });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken([ "Z", "ZZ" ], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes;
        if (matches === null) {
            return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || [ "-", 0, 0 ];
        minutes = +(parts[1] * 60) + toInt(parts[2]);
        return minutes === 0 ? 0 : parts[0] === "+" ? minutes : -minutes;
    }
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }
    function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
    }
    hooks.updateOffset = function() {};
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0, localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === "string") {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, "m");
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, "m"), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }
    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== "string") {
                input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
        } else {
            return -this.utcOffset();
        }
    }
    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
                this.subtract(getDateOffset(this), "m");
            }
        }
        return this;
    }
    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }
    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }
        return this._isDSTShifted;
    }
    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
        var duration = input, match = null, sign, ret, diffRes;
        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
                duration[key] = +input;
            } else {
                duration.milliseconds = +input;
            }
        } else if (match = aspNetRegex.exec(input)) {
            sign = match[1] === "-" ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign
            };
        } else if (match = isoRegex.exec(input)) {
            sign = match[1] === "-" ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign)
            };
        } else if (duration == null) {
            duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
            ret._isValid = input._isValid;
        }
        return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
    }
    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {
                milliseconds: 0,
                months: 0
            };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }
        return res;
    }
    function createAdder(direction, name) {
        return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). " + "See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
                tmp = val;
                val = period;
                period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);
        if (!mom.isValid()) {
            return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months) {
            setMonth(mom, get(mom, "Month") + months * isAdding);
        }
        if (days) {
            set$1(mom, "Date", get(mom, "Date") + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    function isString(input) {
        return typeof input === "string" || input instanceof String;
    }
    function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;
    }
    function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [ "years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms" ], i, property;
        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
            dataTypeTest = input.filter(function(item) {
                return !isNumber(item) && isString(input);
            }).length === 0;
        }
        return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [ "sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse" ], i, property;
        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, "days", true);
        return diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats) {
        if (arguments.length === 1) {
            if (!arguments[0]) {
                time = undefined;
                formats = undefined;
            } else if (isMomentInput(arguments[0])) {
                time = arguments[0];
                formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
                formats = arguments[0];
                time = undefined;
            }
        }
        var now = time || createLocal(), sod = cloneWithOffset(now, this).startOf("day"), format = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }
    function clone() {
        return new Moment(this);
    }
    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }
    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }
    function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from), localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }
    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }
    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
            return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
            return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;

          case "month":
            output = monthDiff(this, that);
            break;

          case "quarter":
            output = monthDiff(this, that) / 3;
            break;

          case "second":
            output = (this - that) / 1e3;
            break;

          case "minute":
            output = (this - that) / 6e4;
            break;

          case "hour":
            output = (this - that) / 36e5;
            break;

          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;

          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;

          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
        if (a.date() < b.date()) {
            return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
        }
        if (isFunction(Date.prototype.toISOString)) {
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
            }
        }
        return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
    }
    function inspect() {
        if (!this.isValid()) {
            return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
            zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
                to: this,
                from: time
            }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }
    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
                from: this,
                to: time
            }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }
    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
        var newLocaleData;
        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }
    var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    });
    function localeData() {
        return this._locale;
    }
    var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }
    function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }
    function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === "millisecond" || !this.isValid()) {
            return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;

          case "quarter":
            time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
            break;

          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;

          case "week":
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
            break;

          case "isoWeek":
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;

          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;

          case "hour":
            time = this._d.valueOf();
            time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
            break;

          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;

          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }
    function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === "millisecond" || !this.isValid()) {
            return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;

          case "quarter":
            time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;

          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;

          case "week":
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;

          case "isoWeek":
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;

          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;

          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
            break;

          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;

          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }
    function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
    }
    function unix() {
        return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
        return new Date(this.valueOf());
    }
    function toArray() {
        var m = this;
        return [ m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond() ];
    }
    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }
    function toJSON() {
        return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
        return isValid(this);
    }
    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
        return getParsingFlags(this).overflow;
    }
    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", [ "y", 1 ], "yo", "eraYear");
    addFormatToken("y", [ "yy", 2 ], 0, "eraYear");
    addFormatToken("y", [ "yyy", 3 ], 0, "eraYear");
    addFormatToken("y", [ "yyyy", 4 ], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken([ "N", "NN", "NNN", "NNNN", "NNNNN" ], function(input, array, config, token) {
        var era = config._locale.erasParse(input, token, config._strict);
        if (era) {
            getParsingFlags(config).era = era;
        } else {
            getParsingFlags(config).invalidEra = input;
        }
    });
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken([ "y", "yy", "yyy", "yyyy" ], YEAR);
    addParseToken([ "yo" ], function(input, array, config, token) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
            array[YEAR] = parseInt(input, 10);
        }
    });
    function localeEras(m, format) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
              case "string":
                date = hooks(eras[i].since).startOf("day");
                eras[i].since = date.valueOf();
                break;
            }
            switch (typeof eras[i].until) {
              case "undefined":
                eras[i].until = +Infinity;
                break;

              case "string":
                date = hooks(eras[i].until).startOf("day").valueOf();
                eras[i].until = date.valueOf();
                break;
            }
        }
        return eras;
    }
    function localeErasParse(eraName, format, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();
            if (strict) {
                switch (format) {
                  case "N":
                  case "NN":
                  case "NNN":
                    if (abbr === eraName) {
                        return eras[i];
                    }
                    break;

                  case "NNNN":
                    if (name === eraName) {
                        return eras[i];
                    }
                    break;

                  case "NNNNN":
                    if (narrow === eraName) {
                        return eras[i];
                    }
                    break;
                }
            } else if ([ name, abbr, narrow ].indexOf(eraName) >= 0) {
                return eras[i];
            }
        }
    }
    function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? +1 : -1;
        if (year === undefined) {
            return hooks(era.since).year();
        } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
        }
    }
    function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].name;
            }
        }
        return "";
    }
    function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].narrow;
            }
        }
        return "";
    }
    function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].abbr;
            }
        }
        return "";
    }
    function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
                return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
            }
        }
        return this.year();
    }
    function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));
            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
    }
    addFormatToken(0, [ "gg", 2 ], 0, function() {
        return this.weekYear() % 100;
    });
    addFormatToken(0, [ "GG", 2 ], 0, function() {
        return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [ token, token.length ], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addUnitAlias("weekYear", "gg");
    addUnitAlias("isoWeekYear", "GG");
    addUnitPriority("weekYear", 1);
    addUnitPriority("isoWeekYear", 1);
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken([ "gggg", "ggggg", "GGGG", "GGGGG" ], function(input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken([ "gg", "GG" ], function(input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }
    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }
    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }
    addFormatToken("Q", 0, "Qo", "quarter");
    addUnitAlias("quarter", "Q");
    addUnitPriority("quarter", 7);
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", [ "DD", 2 ], "Do", "date");
    addUnitAlias("date", "D");
    addUnitPriority("date", 9);
    addRegexToken("D", match1to2);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale) {
        return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
    });
    addParseToken([ "D", "DD" ], DATE);
    addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", [ "DDDD", 3 ], "DDDo", "dayOfYear");
    addUnitAlias("dayOfYear", "DDD");
    addUnitPriority("dayOfYear", 4);
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken([ "DDD", "DDDD" ], function(input, array, config) {
        config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    addFormatToken("m", [ "mm", 2 ], 0, "minute");
    addUnitAlias("minute", "m");
    addUnitPriority("minute", 14);
    addRegexToken("m", match1to2);
    addRegexToken("mm", match1to2, match2);
    addParseToken([ "m", "mm" ], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", [ "ss", 2 ], 0, "second");
    addUnitAlias("second", "s");
    addUnitPriority("second", 15);
    addRegexToken("s", match1to2);
    addRegexToken("ss", match1to2, match2);
    addParseToken([ "s", "ss" ], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, [ "SS", 2 ], 0, function() {
        return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, [ "SSS", 3 ], 0, "millisecond");
    addFormatToken(0, [ "SSSS", 4 ], 0, function() {
        return this.millisecond() * 10;
    });
    addFormatToken(0, [ "SSSSS", 5 ], 0, function() {
        return this.millisecond() * 100;
    });
    addFormatToken(0, [ "SSSSSS", 6 ], 0, function() {
        return this.millisecond() * 1e3;
    });
    addFormatToken(0, [ "SSSSSSS", 7 ], 0, function() {
        return this.millisecond() * 1e4;
    });
    addFormatToken(0, [ "SSSSSSSS", 8 ], 0, function() {
        return this.millisecond() * 1e5;
    });
    addFormatToken(0, [ "SSSSSSSSS", 9 ], 0, function() {
        return this.millisecond() * 1e6;
    });
    addUnitAlias("millisecond", "ms");
    addUnitPriority("millisecond", 16);
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token, getSetMillisecond;
    for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
    }
    for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
            return "Moment<" + this.format() + ">";
        };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
    proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
    proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
    proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
    proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
    function createUnix(input) {
        return createLocal(input * 1e3);
    }
    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
        return string;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1(format, index, field, setter) {
        var locale = getLocale(), utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }
    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }
        format = format || "";
        if (index != null) {
            return get$1(format, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, "month");
        }
        return out;
    }
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === "boolean") {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }
            format = format || "";
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }
            format = format || "";
        }
        var locale = getLocale(), shift = localeSorted ? locale._week.dow : 0, i, out = [];
        if (index != null) {
            return get$1(format, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, "day");
        }
        return out;
    }
    function listMonths(format, index) {
        return listMonthsImpl(format, index, "months");
    }
    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, "monthsShort");
    }
    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdaysMin");
    }
    getSetGlobalLocale("en", {
        eras: [ {
            since: "0001-01-01",
            until: +Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
        }, {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
        } ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        }
    });
    hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
    hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
    var mathAbs = Math.abs;
    function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
    }
    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
    }
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }
    function bubble() {
        var milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, seconds, minutes, hours, years, monthsFromDays;
        if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }
        data.milliseconds = milliseconds % 1e3;
        seconds = absFloor(milliseconds / 1e3);
        data.seconds = seconds % 60;
        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;
        hours = absFloor(minutes / 60);
        data.hours = hours % 24;
        days += absFloor(hours / 24);
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));
        years = absFloor(months / 12);
        months %= 12;
        data.days = days;
        data.months = months;
        data.years = years;
        return this;
    }
    function daysToMonths(days) {
        return days * 4800 / 146097;
    }
    function monthsToDays(months) {
        return months * 146097 / 4800;
    }
    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days, months, milliseconds = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
              case "month":
                return months;

              case "quarter":
                return months / 3;

              case "year":
                return months / 12;
            }
        } else {
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case "week":
                return days / 7 + milliseconds / 6048e5;

              case "day":
                return days + milliseconds / 864e5;

              case "hour":
                return days * 24 + milliseconds / 36e5;

              case "minute":
                return days * 1440 + milliseconds / 6e4;

              case "second":
                return days * 86400 + milliseconds / 1e3;

              case "millisecond":
                return Math.floor(days * 864e5) + milliseconds;

              default:
                throw new Error("Unknown unit " + units);
            }
        }
    }
    function valueOf$1() {
        if (!this.isValid()) {
            return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }
    function makeAs(alias) {
        return function() {
            return this.as(alias);
        };
    }
    var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
    function clone$1() {
        return createDuration(this);
    }
    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
    }
    function makeGetter(name) {
        return function() {
            return this.isValid() ? this._data[name] : NaN;
        };
    }
    var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
    function weeks() {
        return absFloor(this.days() / 7);
    }
    var round = Math.round, thresholds = {
        ss: 44,
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        w: null,
        M: 11
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duration = createDuration(posNegDuration).abs(), seconds = round(duration.as("s")), minutes = round(duration.as("m")), hours = round(duration.as("h")), days = round(duration.as("d")), months = round(duration.as("M")), weeks = round(duration.as("w")), years = round(duration.as("y")), a = seconds <= thresholds.ss && [ "s", seconds ] || seconds < thresholds.s && [ "ss", seconds ] || minutes <= 1 && [ "m" ] || minutes < thresholds.m && [ "mm", minutes ] || hours <= 1 && [ "h" ] || hours < thresholds.h && [ "hh", hours ] || days <= 1 && [ "d" ] || days < thresholds.d && [ "dd", days ];
        if (thresholds.w != null) {
            a = a || weeks <= 1 && [ "w" ] || weeks < thresholds.w && [ "ww", weeks ];
        }
        a = a || months <= 1 && [ "M" ] || months < thresholds.M && [ "MM", months ] || years <= 1 && [ "y" ] || [ "yy", years ];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof roundingFunction === "function") {
            round = roundingFunction;
            return true;
        }
        return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
            thresholds.ss = limit - 1;
        }
        return true;
    }
    function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale, output;
        if (typeof argWithSuffix === "object") {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
            withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
            }
        }
        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);
        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }
        return locale.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x) {
        return (x > 0) - (x < 0) || +x;
    }
    function toISOString$1() {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        var seconds = abs$1(this._milliseconds) / 1e3, days = abs$1(this._days), months = abs$1(this._months), minutes, hours, years, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
            return "P0D";
        }
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;
        years = absFloor(months / 12);
        months %= 12;
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years ? ymSign + years + "Y" : "") + (months ? ymSign + months + "M" : "") + (days ? daysSign + days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? hmsSign + hours + "H" : "") + (minutes ? hmsSign + minutes + "M" : "") + (seconds ? hmsSign + s + "S" : "");
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
    });
    hooks.version = "2.29.1";
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        DATE: "YYYY-MM-DD",
        TIME: "HH:mm",
        TIME_SECONDS: "HH:mm:ss",
        TIME_MS: "HH:mm:ss.SSS",
        WEEK: "GGGG-[W]WW",
        MONTH: "YYYY-MM"
    };
    hooks.defineLocale("af", {
        months: "Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split("_"),
        monthsShort: "Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"),
        weekdays: "Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split("_"),
        weekdaysShort: "Son_Maa_Din_Woe_Don_Vry_Sat".split("_"),
        weekdaysMin: "So_Ma_Di_Wo_Do_Vr_Sa".split("_"),
        meridiemParse: /vm|nm/i,
        isPM: function(input) {
            return /^nm$/i.test(input);
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? "vm" : "VM";
            } else {
                return isLower ? "nm" : "NM";
            }
        },
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Vandag om] LT",
            nextDay: "[Mre om] LT",
            nextWeek: "dddd [om] LT",
            lastDay: "[Gister om] LT",
            lastWeek: "[Laas] dddd [om] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "oor %s",
            past: "%s gelede",
            s: "'n paar sekondes",
            ss: "%d sekondes",
            m: "'n minuut",
            mm: "%d minute",
            h: "'n uur",
            hh: "%d ure",
            d: "'n dag",
            dd: "%d dae",
            M: "'n maand",
            MM: "%d maande",
            y: "'n jaar",
            yy: "%d jaar"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function(number) {
            return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var pluralForm = function(n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        m: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        h: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        d: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        M: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        y: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ]
    }, pluralize = function(u) {
        return function(number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number), str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, months$1 = [ "", "", "", "", "", "", "", "", "", "", "", "" ];
    hooks.defineLocale("ar-dz", {
        months: months$1,
        monthsShort: months$1,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "D/M/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return "" === input;
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[  ] LT",
            nextDay: "[  ] LT",
            nextWeek: "dddd [ ] LT",
            lastDay: "[  ] LT",
            lastWeek: "dddd [ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: pluralize("s"),
            ss: pluralize("s"),
            m: pluralize("m"),
            mm: pluralize("m"),
            h: pluralize("h"),
            hh: pluralize("h"),
            d: pluralize("d"),
            dd: pluralize("d"),
            M: pluralize("M"),
            MM: pluralize("M"),
            y: pluralize("y"),
            yy: pluralize("y")
        },
        postformat: function(string) {
            return string.replace(/,/g, "");
        },
        week: {
            dow: 0,
            doy: 4
        }
    });
    hooks.defineLocale("ar-kw", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[  ] LT",
            nextDay: "[  ] LT",
            nextWeek: "dddd [ ] LT",
            lastDay: "[  ] LT",
            lastWeek: "dddd [ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: "",
            ss: "%d ",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        week: {
            dow: 0,
            doy: 12
        }
    });
    var symbolMap = {
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        0: "0"
    }, pluralForm$1 = function(n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals$1 = {
        s: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        m: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        h: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        d: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        M: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        y: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ]
    }, pluralize$1 = function(u) {
        return function(number, withoutSuffix, string, isFuture) {
            var f = pluralForm$1(number), str = plurals$1[u][pluralForm$1(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, months$2 = [ "", "", "", "", "", "", "", "", "", "", "", "" ];
    hooks.defineLocale("ar-ly", {
        months: months$2,
        monthsShort: months$2,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "D/M/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return "" === input;
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[  ] LT",
            nextDay: "[  ] LT",
            nextWeek: "dddd [ ] LT",
            lastDay: "[  ] LT",
            lastWeek: "dddd [ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: pluralize$1("s"),
            ss: pluralize$1("s"),
            m: pluralize$1("m"),
            mm: pluralize$1("m"),
            h: pluralize$1("h"),
            hh: pluralize$1("h"),
            d: pluralize$1("d"),
            dd: pluralize$1("d"),
            M: pluralize$1("M"),
            MM: pluralize$1("M"),
            y: pluralize$1("y"),
            yy: pluralize$1("y")
        },
        preparse: function(string) {
            return string.replace(//g, ",");
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap[match];
            }).replace(/,/g, "");
        },
        week: {
            dow: 6,
            doy: 12
        }
    });
    hooks.defineLocale("ar-ma", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[  ] LT",
            nextDay: "[  ] LT",
            nextWeek: "dddd [ ] LT",
            lastDay: "[  ] LT",
            lastWeek: "dddd [ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: "",
            ss: "%d ",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var symbolMap$1 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("ar-sa", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return "" === input;
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[  ] LT",
            nextDay: "[  ] LT",
            nextWeek: "dddd [ ] LT",
            lastDay: "[  ] LT",
            lastWeek: "dddd [ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: "",
            ss: "%d ",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap[match];
            }).replace(//g, ",");
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$1[match];
            }).replace(/,/g, "");
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    hooks.defineLocale("ar-tn", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[  ] LT",
            nextDay: "[  ] LT",
            nextWeek: "dddd [ ] LT",
            lastDay: "[  ] LT",
            lastWeek: "dddd [ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: "",
            ss: "%d ",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var symbolMap$2 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$1 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    }, pluralForm$2 = function(n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals$2 = {
        s: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        m: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        h: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        d: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        M: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        y: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ]
    }, pluralize$2 = function(u) {
        return function(number, withoutSuffix, string, isFuture) {
            var f = pluralForm$2(number), str = plurals$2[u][pluralForm$2(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, months$3 = [ "", "", "", "", "", "", "", "", "", "", "", "" ];
    hooks.defineLocale("ar", {
        months: months$3,
        monthsShort: months$3,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "D/M/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return "" === input;
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[  ] LT",
            nextDay: "[  ] LT",
            nextWeek: "dddd [ ] LT",
            lastDay: "[  ] LT",
            lastWeek: "dddd [ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: pluralize$2("s"),
            ss: pluralize$2("s"),
            m: pluralize$2("m"),
            mm: pluralize$2("m"),
            h: pluralize$2("h"),
            hh: pluralize$2("h"),
            d: pluralize$2("d"),
            dd: pluralize$2("d"),
            M: pluralize$2("M"),
            MM: pluralize$2("M"),
            y: pluralize$2("y"),
            yy: pluralize$2("y")
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$1[match];
            }).replace(//g, ",");
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$2[match];
            }).replace(/,/g, "");
        },
        week: {
            dow: 6,
            doy: 12
        }
    });
    var suffixes = {
        1: "-inci",
        5: "-inci",
        8: "-inci",
        70: "-inci",
        80: "-inci",
        2: "-nci",
        7: "-nci",
        20: "-nci",
        50: "-nci",
        3: "-nc",
        4: "-nc",
        100: "-nc",
        6: "-nc",
        9: "-uncu",
        10: "-uncu",
        30: "-uncu",
        60: "-nc",
        90: "-nc"
    };
    hooks.defineLocale("az", {
        months: "yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split("_"),
        monthsShort: "yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"),
        weekdays: "Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb".split("_"),
        weekdaysShort: "Baz_BzE_Ax_r_CAx_Cm_n".split("_"),
        weekdaysMin: "Bz_BE_A__CA_C_".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[bugn saat] LT",
            nextDay: "[sabah saat] LT",
            nextWeek: "[gln hft] dddd [saat] LT",
            lastDay: "[dnn] LT",
            lastWeek: "[ken hft] dddd [saat] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s sonra",
            past: "%s vvl",
            s: "bir ne saniy",
            ss: "%d saniy",
            m: "bir dqiq",
            mm: "%d dqiq",
            h: "bir saat",
            hh: "%d saat",
            d: "bir gn",
            dd: "%d gn",
            M: "bir ay",
            MM: "%d ay",
            y: "bir il",
            yy: "%d il"
        },
        meridiemParse: /gec|shr|gndz|axam/,
        isPM: function(input) {
            return /^(gndz|axam)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "gec";
            } else if (hour < 12) {
                return "shr";
            } else if (hour < 17) {
                return "gndz";
            } else {
                return "axam";
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
        ordinal: function(number) {
            if (number === 0) {
                return number + "-nc";
            }
            var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    function plural(word, num) {
        var forms = word.split("_");
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            ss: withoutSuffix ? "__" : "__",
            mm: withoutSuffix ? "__" : "__",
            hh: withoutSuffix ? "__" : "__",
            dd: "__",
            MM: "__",
            yy: "__"
        };
        if (key === "m") {
            return withoutSuffix ? "" : "";
        } else if (key === "h") {
            return withoutSuffix ? "" : "";
        } else {
            return number + " " + plural(format[key], +number);
        }
    }
    hooks.defineLocale("be", {
        months: {
            format: "___________".split("_"),
            standalone: "___________".split("_")
        },
        monthsShort: "___________".split("_"),
        weekdays: {
            format: "______".split("_"),
            standalone: "______".split("_"),
            isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
        },
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY .",
            LLL: "D MMMM YYYY ., HH:mm",
            LLLL: "dddd, D MMMM YYYY ., HH:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            lastDay: "[ ] LT",
            nextWeek: function() {
                return "[] dddd [] LT";
            },
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                  case 5:
                  case 6:
                    return "[ ] dddd [] LT";

                  case 1:
                  case 2:
                  case 4:
                    return "[ ] dddd [] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: "%s ",
            s: " ",
            m: relativeTimeWithPlural,
            mm: relativeTimeWithPlural,
            h: relativeTimeWithPlural,
            hh: relativeTimeWithPlural,
            d: "",
            dd: relativeTimeWithPlural,
            M: "",
            MM: relativeTimeWithPlural,
            y: "",
            yy: relativeTimeWithPlural
        },
        meridiemParse: /|||/,
        isPM: function(input) {
            return /^(|)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "";
            } else if (hour < 12) {
                return "";
            } else if (hour < 17) {
                return "";
            } else {
                return "";
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
        ordinal: function(number, period) {
            switch (period) {
              case "M":
              case "d":
              case "DDD":
              case "w":
              case "W":
                return (number % 10 === 2 || number % 10 === 3) && number % 100 !== 12 && number % 100 !== 13 ? number + "-" : number + "-";

              case "D":
                return number + "-";

              default:
                return number;
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("bg", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "D.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY H:mm",
            LLLL: "dddd, D MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ ] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                  case 6:
                    return "[] dddd [] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[] dddd [] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: " ",
            ss: "%d ",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            w: "",
            ww: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
        ordinal: function(number) {
            var lastDigit = number % 10, last2Digits = number % 100;
            if (number === 0) {
                return number + "-";
            } else if (last2Digits === 0) {
                return number + "-";
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + "-";
            } else if (lastDigit === 1) {
                return number + "-";
            } else if (lastDigit === 2) {
                return number + "-";
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + "-";
            } else {
                return number + "-";
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("bm", {
        months: "Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo".split("_"),
        monthsShort: "Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des".split("_"),
        weekdays: "Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri".split("_"),
        weekdaysShort: "Kar_Nt_Tar_Ara_Ala_Jum_Sib".split("_"),
        weekdaysMin: "Ka_Nt_Ta_Ar_Al_Ju_Si".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "MMMM [tile] D [san] YYYY",
            LLL: "MMMM [tile] D [san] YYYY [lr] HH:mm",
            LLLL: "dddd MMMM [tile] D [san] YYYY [lr] HH:mm"
        },
        calendar: {
            sameDay: "[Bi lr] LT",
            nextDay: "[Sini lr] LT",
            nextWeek: "dddd [don lr] LT",
            lastDay: "[Kunu lr] LT",
            lastWeek: "dddd [tmnen lr] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s kn",
            past: "a b %s b",
            s: "sanga dama dama",
            ss: "sekondi %d",
            m: "miniti kelen",
            mm: "miniti %d",
            h: "lr kelen",
            hh: "lr %d",
            d: "tile kelen",
            dd: "tile %d",
            M: "kalo kelen",
            MM: "kalo %d",
            y: "san kelen",
            yy: "san %d"
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var symbolMap$3 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$2 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("bn-bd", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm ",
            LTS: "A h:mm:ss ",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm ",
            LLLL: "dddd, D MMMM YYYY, A h:mm "
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$2[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$3[match];
            });
        },
        meridiemParse: /||||||/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "") {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour;
            } else if (meridiem === "") {
                return hour;
            } else if (meridiem === "") {
                return hour >= 3 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour + 12;
            } else if (meridiem === "") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "";
            } else if (hour < 6) {
                return "";
            } else if (hour < 12) {
                return "";
            } else if (hour < 15) {
                return "";
            } else if (hour < 18) {
                return "";
            } else if (hour < 20) {
                return "";
            } else {
                return "";
            }
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    var symbolMap$4 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$3 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("bn", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm ",
            LTS: "A h:mm:ss ",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm ",
            LLLL: "dddd, D MMMM YYYY, A h:mm "
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$3[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$4[match];
            });
        },
        meridiemParse: /||||/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "" && hour >= 4 || meridiem === "" && hour < 5 || meridiem === "") {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "";
            } else if (hour < 10) {
                return "";
            } else if (hour < 17) {
                return "";
            } else if (hour < 20) {
                return "";
            } else {
                return "";
            }
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    var symbolMap$5 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$4 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("bo", {
        months: "___________".split("_"),
        monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        monthsShortRegex: /^(\d{1,2})/,
        monthsParseExact: true,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm",
            LTS: "A h:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm",
            LLLL: "dddd, D MMMM YYYY, A h:mm"
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "[], LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: "",
            ss: "%d ",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$4[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$5[match];
            });
        },
        meridiemParse: /||||/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "" && hour >= 4 || meridiem === "" && hour < 5 || meridiem === "") {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "";
            } else if (hour < 10) {
                return "";
            } else if (hour < 17) {
                return "";
            } else if (hour < 20) {
                return "";
            } else {
                return "";
            }
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    function relativeTimeWithMutation(number, withoutSuffix, key) {
        var format = {
            mm: "munutenn",
            MM: "miz",
            dd: "devezh"
        };
        return number + " " + mutation(format[key], number);
    }
    function specialMutationForYears(number) {
        switch (lastNumber(number)) {
          case 1:
          case 3:
          case 4:
          case 5:
          case 9:
            return number + " bloaz";

          default:
            return number + " vloaz";
        }
    }
    function lastNumber(number) {
        if (number > 9) {
            return lastNumber(number % 10);
        }
        return number;
    }
    function mutation(text, number) {
        if (number === 2) {
            return softMutation(text);
        }
        return text;
    }
    function softMutation(text) {
        var mutationTable = {
            m: "v",
            b: "v",
            d: "z"
        };
        if (mutationTable[text.charAt(0)] === undefined) {
            return text;
        }
        return mutationTable[text.charAt(0)] + text.substring(1);
    }
    var monthsParse = [ /^gen/i, /^c[\']hwe/i, /^meu/i, /^ebr/i, /^mae/i, /^(mez|eve)/i, /^gou/i, /^eos/i, /^gwe/i, /^her/i, /^du/i, /^ker/i ], monthsRegex$1 = /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i, monthsStrictRegex = /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i, monthsShortStrictRegex = /^(gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i, fullWeekdaysParse = [ /^sul/i, /^lun/i, /^meurzh/i, /^merc[\']her/i, /^yaou/i, /^gwener/i, /^sadorn/i ], shortWeekdaysParse = [ /^Sul/i, /^Lun/i, /^Meu/i, /^Mer/i, /^Yao/i, /^Gwe/i, /^Sad/i ], minWeekdaysParse = [ /^Su/i, /^Lu/i, /^Me([^r]|$)/i, /^Mer/i, /^Ya/i, /^Gw/i, /^Sa/i ];
    hooks.defineLocale("br", {
        months: "Genver_Chwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"),
        monthsShort: "Gen_Chwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"),
        weekdays: "Sul_Lun_Meurzh_Mercher_Yaou_Gwener_Sadorn".split("_"),
        weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"),
        weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"),
        weekdaysParse: minWeekdaysParse,
        fullWeekdaysParse: fullWeekdaysParse,
        shortWeekdaysParse: shortWeekdaysParse,
        minWeekdaysParse: minWeekdaysParse,
        monthsRegex: monthsRegex$1,
        monthsShortRegex: monthsRegex$1,
        monthsStrictRegex: monthsStrictRegex,
        monthsShortStrictRegex: monthsShortStrictRegex,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D [a viz] MMMM YYYY",
            LLL: "D [a viz] MMMM YYYY HH:mm",
            LLLL: "dddd, D [a viz] MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Hiziv da] LT",
            nextDay: "[Warchoazh da] LT",
            nextWeek: "dddd [da] LT",
            lastDay: "[Dech da] LT",
            lastWeek: "dddd [paset da] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "a-benn %s",
            past: "%s zo",
            s: "un nebeud segondenno",
            ss: "%d eilenn",
            m: "ur vunutenn",
            mm: relativeTimeWithMutation,
            h: "un eur",
            hh: "%d eur",
            d: "un devezh",
            dd: relativeTimeWithMutation,
            M: "ur miz",
            MM: relativeTimeWithMutation,
            y: "ur bloaz",
            yy: specialMutationForYears
        },
        dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
        ordinal: function(number) {
            var output = number === 1 ? "a" : "vet";
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        },
        meridiemParse: /a.m.|g.m./,
        isPM: function(token) {
            return token === "g.m.";
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 12 ? "a.m." : "g.m.";
        }
    });
    function translate(number, withoutSuffix, key) {
        var result = number + " ";
        switch (key) {
          case "ss":
            if (number === 1) {
                result += "sekunda";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "sekunde";
            } else {
                result += "sekundi";
            }
            return result;

          case "m":
            return withoutSuffix ? "jedna minuta" : "jedne minute";

          case "mm":
            if (number === 1) {
                result += "minuta";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "minute";
            } else {
                result += "minuta";
            }
            return result;

          case "h":
            return withoutSuffix ? "jedan sat" : "jednog sata";

          case "hh":
            if (number === 1) {
                result += "sat";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "sata";
            } else {
                result += "sati";
            }
            return result;

          case "dd":
            if (number === 1) {
                result += "dan";
            } else {
                result += "dana";
            }
            return result;

          case "MM":
            if (number === 1) {
                result += "mjesec";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "mjeseca";
            } else {
                result += "mjeseci";
            }
            return result;

          case "yy":
            if (number === 1) {
                result += "godina";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "godine";
            } else {
                result += "godina";
            }
            return result;
        }
    }
    hooks.defineLocale("bs", {
        months: "januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split("_"),
        monthsShort: "jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split("_"),
        monthsParseExact: true,
        weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split("_"),
        weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"),
        weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[danas u] LT",
            nextDay: "[sutra u] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[u] [nedjelju] [u] LT";

                  case 3:
                    return "[u] [srijedu] [u] LT";

                  case 6:
                    return "[u] [subotu] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[u] dddd [u] LT";
                }
            },
            lastDay: "[juer u] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                    return "[prolu] dddd [u] LT";

                  case 6:
                    return "[prole] [subote] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[proli] dddd [u] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "prije %s",
            s: "par sekundi",
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: "dan",
            dd: translate,
            M: "mjesec",
            MM: translate,
            y: "godinu",
            yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("ca", {
        months: {
            standalone: "gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split("_"),
            format: "de gener_de febrer_de mar_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split("_"),
            isFormat: /D[oD]?(\s)+MMMM/
        },
        monthsShort: "gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.".split("_"),
        monthsParseExact: true,
        weekdays: "diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split("_"),
        weekdaysShort: "dg._dl._dt._dc._dj._dv._ds.".split("_"),
        weekdaysMin: "dg_dl_dt_dc_dj_dv_ds".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM [de] YYYY",
            ll: "D MMM YYYY",
            LLL: "D MMMM [de] YYYY [a les] H:mm",
            lll: "D MMM YYYY, H:mm",
            LLLL: "dddd D MMMM [de] YYYY [a les] H:mm",
            llll: "ddd D MMM YYYY, H:mm"
        },
        calendar: {
            sameDay: function() {
                return "[avui a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
            },
            nextDay: function() {
                return "[dem a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
            },
            nextWeek: function() {
                return "dddd [a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
            },
            lastDay: function() {
                return "[ahir a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
            },
            lastWeek: function() {
                return "[el] dddd [passat a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "d'aqu %s",
            past: "fa %s",
            s: "uns segons",
            ss: "%d segons",
            m: "un minut",
            mm: "%d minuts",
            h: "una hora",
            hh: "%d hores",
            d: "un dia",
            dd: "%d dies",
            M: "un mes",
            MM: "%d mesos",
            y: "un any",
            yy: "%d anys"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
        ordinal: function(number, period) {
            var output = number === 1 ? "r" : number === 2 ? "n" : number === 3 ? "r" : number === 4 ? "t" : "";
            if (period === "w" || period === "W") {
                output = "a";
            }
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var months$4 = "leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec".split("_"), monthsShort = "led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro".split("_"), monthsParse$1 = [ /^led/i, /^no/i, /^be/i, /^dub/i, /^kv/i, /^(vn|erven$|ervna)/i, /^(vc|ervenec|ervence)/i, /^srp/i, /^z/i, /^j/i, /^lis/i, /^pro/i ], monthsRegex$2 = /^(leden|nor|bezen|duben|kvten|ervenec|ervence|erven|ervna|srpen|z|jen|listopad|prosinec|led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i;
    function plural$1(n) {
        return n > 1 && n < 5 && ~~(n / 10) !== 1;
    }
    function translate$1(number, withoutSuffix, key, isFuture) {
        var result = number + " ";
        switch (key) {
          case "s":
            return withoutSuffix || isFuture ? "pr sekund" : "pr sekundami";

          case "ss":
            if (withoutSuffix || isFuture) {
                return result + (plural$1(number) ? "sekundy" : "sekund");
            } else {
                return result + "sekundami";
            }

          case "m":
            return withoutSuffix ? "minuta" : isFuture ? "minutu" : "minutou";

          case "mm":
            if (withoutSuffix || isFuture) {
                return result + (plural$1(number) ? "minuty" : "minut");
            } else {
                return result + "minutami";
            }

          case "h":
            return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";

          case "hh":
            if (withoutSuffix || isFuture) {
                return result + (plural$1(number) ? "hodiny" : "hodin");
            } else {
                return result + "hodinami";
            }

          case "d":
            return withoutSuffix || isFuture ? "den" : "dnem";

          case "dd":
            if (withoutSuffix || isFuture) {
                return result + (plural$1(number) ? "dny" : "dn");
            } else {
                return result + "dny";
            }

          case "M":
            return withoutSuffix || isFuture ? "msc" : "mscem";

          case "MM":
            if (withoutSuffix || isFuture) {
                return result + (plural$1(number) ? "msce" : "msc");
            } else {
                return result + "msci";
            }

          case "y":
            return withoutSuffix || isFuture ? "rok" : "rokem";

          case "yy":
            if (withoutSuffix || isFuture) {
                return result + (plural$1(number) ? "roky" : "let");
            } else {
                return result + "lety";
            }
        }
    }
    hooks.defineLocale("cs", {
        months: months$4,
        monthsShort: monthsShort,
        monthsRegex: monthsRegex$2,
        monthsShortRegex: monthsRegex$2,
        monthsStrictRegex: /^(leden|ledna|nora|nor|bezen|bezna|duben|dubna|kvten|kvtna|ervenec|ervence|erven|ervna|srpen|srpna|z|jen|jna|listopadu|listopad|prosinec|prosince)/i,
        monthsShortStrictRegex: /^(led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i,
        monthsParse: monthsParse$1,
        longMonthsParse: monthsParse$1,
        shortMonthsParse: monthsParse$1,
        weekdays: "nedle_pondl_ter_steda_tvrtek_ptek_sobota".split("_"),
        weekdaysShort: "ne_po_t_st_t_p_so".split("_"),
        weekdaysMin: "ne_po_t_st_t_p_so".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd D. MMMM YYYY H:mm",
            l: "D. M. YYYY"
        },
        calendar: {
            sameDay: "[dnes v] LT",
            nextDay: "[ztra v] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[v nedli v] LT";

                  case 1:
                  case 2:
                    return "[v] dddd [v] LT";

                  case 3:
                    return "[ve stedu v] LT";

                  case 4:
                    return "[ve tvrtek v] LT";

                  case 5:
                    return "[v ptek v] LT";

                  case 6:
                    return "[v sobotu v] LT";
                }
            },
            lastDay: "[vera v] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[minulou nedli v] LT";

                  case 1:
                  case 2:
                    return "[minul] dddd [v] LT";

                  case 3:
                    return "[minulou stedu v] LT";

                  case 4:
                  case 5:
                    return "[minul] dddd [v] LT";

                  case 6:
                    return "[minulou sobotu v] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "ped %s",
            s: translate$1,
            ss: translate$1,
            m: translate$1,
            mm: translate$1,
            h: translate$1,
            hh: translate$1,
            d: translate$1,
            dd: translate$1,
            M: translate$1,
            MM: translate$1,
            y: translate$1,
            yy: translate$1
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("cv", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD-MM-YYYY",
            LL: "YYYY [] MMMM [] D[-]",
            LLL: "YYYY [] MMMM [] D[-], HH:mm",
            LLLL: "dddd, YYYY [] MMMM [] D[-], HH:mm"
        },
        calendar: {
            sameDay: "[] LT []",
            nextDay: "[] LT []",
            lastDay: "[] LT []",
            nextWeek: "[] dddd LT []",
            lastWeek: "[] dddd LT []",
            sameElse: "L"
        },
        relativeTime: {
            future: function(output) {
                var affix = /$/i.exec(output) ? "" : /$/i.exec(output) ? "" : "";
                return output + affix;
            },
            past: "%s ",
            s: "- ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}-/,
        ordinal: "%d-",
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("cy", {
        months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"),
        monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"),
        weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"),
        weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"),
        weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Heddiw am] LT",
            nextDay: "[Yfory am] LT",
            nextWeek: "dddd [am] LT",
            lastDay: "[Ddoe am] LT",
            lastWeek: "dddd [diwethaf am] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "mewn %s",
            past: "%s yn l",
            s: "ychydig eiliadau",
            ss: "%d eiliad",
            m: "munud",
            mm: "%d munud",
            h: "awr",
            hh: "%d awr",
            d: "diwrnod",
            dd: "%d diwrnod",
            M: "mis",
            MM: "%d mis",
            y: "blwyddyn",
            yy: "%d flynedd"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        ordinal: function(number) {
            var b = number, output = "", lookup = [ "", "af", "il", "ydd", "ydd", "ed", "ed", "ed", "fed", "fed", "fed", "eg", "fed", "eg", "eg", "fed", "eg", "eg", "fed", "eg", "fed" ];
            if (b > 20) {
                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                    output = "fed";
                } else {
                    output = "ain";
                }
            } else if (b > 0) {
                output = lookup[b];
            }
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("da", {
        months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"),
        monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
        weekdays: "sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag".split("_"),
        weekdaysShort: "sn_man_tir_ons_tor_fre_lr".split("_"),
        weekdaysMin: "s_ma_ti_on_to_fr_l".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY HH:mm",
            LLLL: "dddd [d.] D. MMMM YYYY [kl.] HH:mm"
        },
        calendar: {
            sameDay: "[i dag kl.] LT",
            nextDay: "[i morgen kl.] LT",
            nextWeek: "p dddd [kl.] LT",
            lastDay: "[i gr kl.] LT",
            lastWeek: "[i] dddd[s kl.] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "om %s",
            past: "%s siden",
            s: "f sekunder",
            ss: "%d sekunder",
            m: "et minut",
            mm: "%d minutter",
            h: "en time",
            hh: "%d timer",
            d: "en dag",
            dd: "%d dage",
            M: "en mned",
            MM: "%d mneder",
            y: "et r",
            yy: "%d r"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            m: [ "eine Minute", "einer Minute" ],
            h: [ "eine Stunde", "einer Stunde" ],
            d: [ "ein Tag", "einem Tag" ],
            dd: [ number + " Tage", number + " Tagen" ],
            w: [ "eine Woche", "einer Woche" ],
            M: [ "ein Monat", "einem Monat" ],
            MM: [ number + " Monate", number + " Monaten" ],
            y: [ "ein Jahr", "einem Jahr" ],
            yy: [ number + " Jahre", number + " Jahren" ]
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    hooks.defineLocale("de-at", {
        months: "Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
        monthsShort: "Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
        monthsParseExact: true,
        weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
        weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
        weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY HH:mm",
            LLLL: "dddd, D. MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[heute um] LT [Uhr]",
            sameElse: "L",
            nextDay: "[morgen um] LT [Uhr]",
            nextWeek: "dddd [um] LT [Uhr]",
            lastDay: "[gestern um] LT [Uhr]",
            lastWeek: "[letzten] dddd [um] LT [Uhr]"
        },
        relativeTime: {
            future: "in %s",
            past: "vor %s",
            s: "ein paar Sekunden",
            ss: "%d Sekunden",
            m: processRelativeTime,
            mm: "%d Minuten",
            h: processRelativeTime,
            hh: "%d Stunden",
            d: processRelativeTime,
            dd: processRelativeTime,
            w: processRelativeTime,
            ww: "%d Wochen",
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    function processRelativeTime$1(number, withoutSuffix, key, isFuture) {
        var format = {
            m: [ "eine Minute", "einer Minute" ],
            h: [ "eine Stunde", "einer Stunde" ],
            d: [ "ein Tag", "einem Tag" ],
            dd: [ number + " Tage", number + " Tagen" ],
            w: [ "eine Woche", "einer Woche" ],
            M: [ "ein Monat", "einem Monat" ],
            MM: [ number + " Monate", number + " Monaten" ],
            y: [ "ein Jahr", "einem Jahr" ],
            yy: [ number + " Jahre", number + " Jahren" ]
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    hooks.defineLocale("de-ch", {
        months: "Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
        monthsShort: "Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
        monthsParseExact: true,
        weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
        weekdaysShort: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY HH:mm",
            LLLL: "dddd, D. MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[heute um] LT [Uhr]",
            sameElse: "L",
            nextDay: "[morgen um] LT [Uhr]",
            nextWeek: "dddd [um] LT [Uhr]",
            lastDay: "[gestern um] LT [Uhr]",
            lastWeek: "[letzten] dddd [um] LT [Uhr]"
        },
        relativeTime: {
            future: "in %s",
            past: "vor %s",
            s: "ein paar Sekunden",
            ss: "%d Sekunden",
            m: processRelativeTime$1,
            mm: "%d Minuten",
            h: processRelativeTime$1,
            hh: "%d Stunden",
            d: processRelativeTime$1,
            dd: processRelativeTime$1,
            w: processRelativeTime$1,
            ww: "%d Wochen",
            M: processRelativeTime$1,
            MM: processRelativeTime$1,
            y: processRelativeTime$1,
            yy: processRelativeTime$1
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    function processRelativeTime$2(number, withoutSuffix, key, isFuture) {
        var format = {
            m: [ "eine Minute", "einer Minute" ],
            h: [ "eine Stunde", "einer Stunde" ],
            d: [ "ein Tag", "einem Tag" ],
            dd: [ number + " Tage", number + " Tagen" ],
            w: [ "eine Woche", "einer Woche" ],
            M: [ "ein Monat", "einem Monat" ],
            MM: [ number + " Monate", number + " Monaten" ],
            y: [ "ein Jahr", "einem Jahr" ],
            yy: [ number + " Jahre", number + " Jahren" ]
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    hooks.defineLocale("de", {
        months: "Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
        monthsShort: "Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
        monthsParseExact: true,
        weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
        weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
        weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY HH:mm",
            LLLL: "dddd, D. MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[heute um] LT [Uhr]",
            sameElse: "L",
            nextDay: "[morgen um] LT [Uhr]",
            nextWeek: "dddd [um] LT [Uhr]",
            lastDay: "[gestern um] LT [Uhr]",
            lastWeek: "[letzten] dddd [um] LT [Uhr]"
        },
        relativeTime: {
            future: "in %s",
            past: "vor %s",
            s: "ein paar Sekunden",
            ss: "%d Sekunden",
            m: processRelativeTime$2,
            mm: "%d Minuten",
            h: processRelativeTime$2,
            hh: "%d Stunden",
            d: processRelativeTime$2,
            dd: processRelativeTime$2,
            w: processRelativeTime$2,
            ww: "%d Wochen",
            M: processRelativeTime$2,
            MM: processRelativeTime$2,
            y: processRelativeTime$2,
            yy: processRelativeTime$2
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var months$5 = [ "", "", "", "", "", "", "", "", "", "", "", "" ], weekdays = [ "", "", "", "", "", "", "" ];
    hooks.defineLocale("dv", {
        months: months$5,
        monthsShort: months$5,
        weekdays: weekdays,
        weekdaysShort: weekdays,
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "D/M/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return "" === input;
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: "",
            ss: "d% ",
            m: "",
            mm: " %d",
            h: "",
            hh: " %d",
            d: "",
            dd: " %d",
            M: "",
            MM: " %d",
            y: "",
            yy: " %d"
        },
        preparse: function(string) {
            return string.replace(//g, ",");
        },
        postformat: function(string) {
            return string.replace(/,/g, "");
        },
        week: {
            dow: 7,
            doy: 12
        }
    });
    function isFunction$1(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    hooks.defineLocale("el", {
        monthsNominativeEl: "___________".split("_"),
        monthsGenitiveEl: "___________".split("_"),
        months: function(momentToFormat, format) {
            if (!momentToFormat) {
                return this._monthsNominativeEl;
            } else if (typeof format === "string" && /D/.test(format.substring(0, format.indexOf("MMMM")))) {
                return this._monthsGenitiveEl[momentToFormat.month()];
            } else {
                return this._monthsNominativeEl[momentToFormat.month()];
            }
        },
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        meridiem: function(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? "" : "";
            } else {
                return isLower ? "" : "";
            }
        },
        isPM: function(input) {
            return (input + "").toLowerCase()[0] === "";
        },
        meridiemParse: /[]\.??\.?/i,
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY h:mm A",
            LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendarEl: {
            sameDay: "[ {}] LT",
            nextDay: "[ {}] LT",
            nextWeek: "dddd [{}] LT",
            lastDay: "[ {}] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 6:
                    return "[ ] dddd [{}] LT";

                  default:
                    return "[ ] dddd [{}] LT";
                }
            },
            sameElse: "L"
        },
        calendar: function(key, mom) {
            var output = this._calendarEl[key], hours = mom && mom.hours();
            if (isFunction$1(output)) {
                output = output.apply(mom);
            }
            return output.replace("{}", hours % 12 === 1 ? "" : "");
        },
        relativeTime: {
            future: " %s",
            past: "%s ",
            s: " ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("en-au", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY h:mm A",
            LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            ss: "%d seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        },
        week: {
            dow: 0,
            doy: 4
        }
    });
    hooks.defineLocale("en-ca", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "YYYY-MM-DD",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY h:mm A",
            LLLL: "dddd, MMMM D, YYYY h:mm A"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            ss: "%d seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        }
    });
    hooks.defineLocale("en-gb", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            ss: "%d seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("en-ie", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            ss: "%d seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("en-il", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            ss: "%d seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        }
    });
    hooks.defineLocale("en-in", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY h:mm A",
            LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            ss: "%d seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    hooks.defineLocale("en-nz", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY h:mm A",
            LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            ss: "%d seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("en-sg", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            ss: "%d seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("eo", {
        months: "januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro".split("_"),
        monthsShort: "jan_feb_mart_apr_maj_jun_jul_ag_sept_okt_nov_dec".split("_"),
        weekdays: "dimano_lundo_mardo_merkredo_ado_vendredo_sabato".split("_"),
        weekdaysShort: "dim_lun_mard_merk_a_ven_sab".split("_"),
        weekdaysMin: "di_lu_ma_me_a_ve_sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "[la] D[-an de] MMMM, YYYY",
            LLL: "[la] D[-an de] MMMM, YYYY HH:mm",
            LLLL: "dddd[n], [la] D[-an de] MMMM, YYYY HH:mm",
            llll: "ddd, [la] D[-an de] MMM, YYYY HH:mm"
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function(input) {
            return input.charAt(0).toLowerCase() === "p";
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? "p.t.m." : "P.T.M.";
            } else {
                return isLower ? "a.t.m." : "A.T.M.";
            }
        },
        calendar: {
            sameDay: "[Hodia je] LT",
            nextDay: "[Morga je] LT",
            nextWeek: "dddd[n je] LT",
            lastDay: "[Hiera je] LT",
            lastWeek: "[pasintan] dddd[n je] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "post %s",
            past: "anta %s",
            s: "kelkaj sekundoj",
            ss: "%d sekundoj",
            m: "unu minuto",
            mm: "%d minutoj",
            h: "unu horo",
            hh: "%d horoj",
            d: "unu tago",
            dd: "%d tagoj",
            M: "unu monato",
            MM: "%d monatoj",
            y: "unu jaro",
            yy: "%d jaroj"
        },
        dayOfMonthOrdinalParse: /\d{1,2}a/,
        ordinal: "%da",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), monthsShort$1 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse$2 = [ /^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i ], monthsRegex$3 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
    hooks.defineLocale("es-do", {
        months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
        monthsShort: function(m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort$1[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex: monthsRegex$3,
        monthsShortRegex: monthsRegex$3,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse$2,
        longMonthsParse: monthsParse$2,
        shortMonthsParse: monthsParse$2,
        weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
        weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
        weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D [de] MMMM [de] YYYY",
            LLL: "D [de] MMMM [de] YYYY h:mm A",
            LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A"
        },
        calendar: {
            sameDay: function() {
                return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            nextDay: function() {
                return "[maana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            nextWeek: function() {
                return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            lastDay: function() {
                return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            lastWeek: function() {
                return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "en %s",
            past: "hace %s",
            s: "unos segundos",
            ss: "%d segundos",
            m: "un minuto",
            mm: "%d minutos",
            h: "una hora",
            hh: "%d horas",
            d: "un da",
            dd: "%d das",
            w: "una semana",
            ww: "%d semanas",
            M: "un mes",
            MM: "%d meses",
            y: "un ao",
            yy: "%d aos"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var monthsShortDot$1 = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), monthsShort$2 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse$3 = [ /^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i ], monthsRegex$4 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
    hooks.defineLocale("es-mx", {
        months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
        monthsShort: function(m, format) {
            if (!m) {
                return monthsShortDot$1;
            } else if (/-MMM-/.test(format)) {
                return monthsShort$2[m.month()];
            } else {
                return monthsShortDot$1[m.month()];
            }
        },
        monthsRegex: monthsRegex$4,
        monthsShortRegex: monthsRegex$4,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse$3,
        longMonthsParse: monthsParse$3,
        shortMonthsParse: monthsParse$3,
        weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
        weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
        weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D [de] MMMM [de] YYYY",
            LLL: "D [de] MMMM [de] YYYY H:mm",
            LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
        },
        calendar: {
            sameDay: function() {
                return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            nextDay: function() {
                return "[maana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            nextWeek: function() {
                return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            lastDay: function() {
                return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            lastWeek: function() {
                return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "en %s",
            past: "hace %s",
            s: "unos segundos",
            ss: "%d segundos",
            m: "un minuto",
            mm: "%d minutos",
            h: "una hora",
            hh: "%d horas",
            d: "un da",
            dd: "%d das",
            w: "una semana",
            ww: "%d semanas",
            M: "un mes",
            MM: "%d meses",
            y: "un ao",
            yy: "%d aos"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 0,
            doy: 4
        },
        invalidDate: "Fecha invlida"
    });
    var monthsShortDot$2 = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), monthsShort$3 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse$4 = [ /^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i ], monthsRegex$5 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
    hooks.defineLocale("es-us", {
        months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
        monthsShort: function(m, format) {
            if (!m) {
                return monthsShortDot$2;
            } else if (/-MMM-/.test(format)) {
                return monthsShort$3[m.month()];
            } else {
                return monthsShortDot$2[m.month()];
            }
        },
        monthsRegex: monthsRegex$5,
        monthsShortRegex: monthsRegex$5,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse$4,
        longMonthsParse: monthsParse$4,
        shortMonthsParse: monthsParse$4,
        weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
        weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
        weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "MM/DD/YYYY",
            LL: "D [de] MMMM [de] YYYY",
            LLL: "D [de] MMMM [de] YYYY h:mm A",
            LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A"
        },
        calendar: {
            sameDay: function() {
                return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            nextDay: function() {
                return "[maana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            nextWeek: function() {
                return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            lastDay: function() {
                return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            lastWeek: function() {
                return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "en %s",
            past: "hace %s",
            s: "unos segundos",
            ss: "%d segundos",
            m: "un minuto",
            mm: "%d minutos",
            h: "una hora",
            hh: "%d horas",
            d: "un da",
            dd: "%d das",
            w: "una semana",
            ww: "%d semanas",
            M: "un mes",
            MM: "%d meses",
            y: "un ao",
            yy: "%d aos"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 0,
            doy: 6
        }
    });
    var monthsShortDot$3 = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), monthsShort$4 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse$5 = [ /^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i ], monthsRegex$6 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
    hooks.defineLocale("es", {
        months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
        monthsShort: function(m, format) {
            if (!m) {
                return monthsShortDot$3;
            } else if (/-MMM-/.test(format)) {
                return monthsShort$4[m.month()];
            } else {
                return monthsShortDot$3[m.month()];
            }
        },
        monthsRegex: monthsRegex$6,
        monthsShortRegex: monthsRegex$6,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse$5,
        longMonthsParse: monthsParse$5,
        shortMonthsParse: monthsParse$5,
        weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
        weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
        weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D [de] MMMM [de] YYYY",
            LLL: "D [de] MMMM [de] YYYY H:mm",
            LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
        },
        calendar: {
            sameDay: function() {
                return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            nextDay: function() {
                return "[maana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            nextWeek: function() {
                return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            lastDay: function() {
                return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            lastWeek: function() {
                return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "en %s",
            past: "hace %s",
            s: "unos segundos",
            ss: "%d segundos",
            m: "un minuto",
            mm: "%d minutos",
            h: "una hora",
            hh: "%d horas",
            d: "un da",
            dd: "%d das",
            w: "una semana",
            ww: "%d semanas",
            M: "un mes",
            MM: "%d meses",
            y: "un ao",
            yy: "%d aos"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        },
        invalidDate: "Fecha invlida"
    });
    function processRelativeTime$3(number, withoutSuffix, key, isFuture) {
        var format = {
            s: [ "mne sekundi", "mni sekund", "paar sekundit" ],
            ss: [ number + "sekundi", number + "sekundit" ],
            m: [ "he minuti", "ks minut" ],
            mm: [ number + " minuti", number + " minutit" ],
            h: [ "he tunni", "tund aega", "ks tund" ],
            hh: [ number + " tunni", number + " tundi" ],
            d: [ "he peva", "ks pev" ],
            M: [ "kuu aja", "kuu aega", "ks kuu" ],
            MM: [ number + " kuu", number + " kuud" ],
            y: [ "he aasta", "aasta", "ks aasta" ],
            yy: [ number + " aasta", number + " aastat" ]
        };
        if (withoutSuffix) {
            return format[key][2] ? format[key][2] : format[key][1];
        }
        return isFuture ? format[key][0] : format[key][1];
    }
    hooks.defineLocale("et", {
        months: "jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"),
        monthsShort: "jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"),
        weekdays: "phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev".split("_"),
        weekdaysShort: "P_E_T_K_N_R_L".split("_"),
        weekdaysMin: "P_E_T_K_N_R_L".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[Tna,] LT",
            nextDay: "[Homme,] LT",
            nextWeek: "[Jrgmine] dddd LT",
            lastDay: "[Eile,] LT",
            lastWeek: "[Eelmine] dddd LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s prast",
            past: "%s tagasi",
            s: processRelativeTime$3,
            ss: processRelativeTime$3,
            m: processRelativeTime$3,
            mm: processRelativeTime$3,
            h: processRelativeTime$3,
            hh: processRelativeTime$3,
            d: processRelativeTime$3,
            dd: "%d peva",
            M: processRelativeTime$3,
            MM: processRelativeTime$3,
            y: processRelativeTime$3,
            yy: processRelativeTime$3
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("eu", {
        months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"),
        monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"),
        monthsParseExact: true,
        weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"),
        weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"),
        weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "YYYY[ko] MMMM[ren] D[a]",
            LLL: "YYYY[ko] MMMM[ren] D[a] HH:mm",
            LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] HH:mm",
            l: "YYYY-M-D",
            ll: "YYYY[ko] MMM D[a]",
            lll: "YYYY[ko] MMM D[a] HH:mm",
            llll: "ddd, YYYY[ko] MMM D[a] HH:mm"
        },
        calendar: {
            sameDay: "[gaur] LT[etan]",
            nextDay: "[bihar] LT[etan]",
            nextWeek: "dddd LT[etan]",
            lastDay: "[atzo] LT[etan]",
            lastWeek: "[aurreko] dddd LT[etan]",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s barru",
            past: "duela %s",
            s: "segundo batzuk",
            ss: "%d segundo",
            m: "minutu bat",
            mm: "%d minutu",
            h: "ordu bat",
            hh: "%d ordu",
            d: "egun bat",
            dd: "%d egun",
            M: "hilabete bat",
            MM: "%d hilabete",
            y: "urte bat",
            yy: "%d urte"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var symbolMap$6 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$5 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("fa", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        meridiemParse: /  |  /,
        isPM: function(input) {
            return /  /.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "  ";
            } else {
                return "  ";
            }
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ ] LT",
            lastWeek: "dddd [] [] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: "%s ",
            s: " ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[-]/g, function(match) {
                return numberMap$5[match];
            }).replace(//g, ",");
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$6[match];
            }).replace(/,/g, "");
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 6,
            doy: 12
        }
    });
    var numbersPast = "nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn".split(" "), numbersFuture = [ "nolla", "yhden", "kahden", "kolmen", "neljn", "viiden", "kuuden", numbersPast[7], numbersPast[8], numbersPast[9] ];
    function translate$2(number, withoutSuffix, key, isFuture) {
        var result = "";
        switch (key) {
          case "s":
            return isFuture ? "muutaman sekunnin" : "muutama sekunti";

          case "ss":
            result = isFuture ? "sekunnin" : "sekuntia";
            break;

          case "m":
            return isFuture ? "minuutin" : "minuutti";

          case "mm":
            result = isFuture ? "minuutin" : "minuuttia";
            break;

          case "h":
            return isFuture ? "tunnin" : "tunti";

          case "hh":
            result = isFuture ? "tunnin" : "tuntia";
            break;

          case "d":
            return isFuture ? "pivn" : "piv";

          case "dd":
            result = isFuture ? "pivn" : "piv";
            break;

          case "M":
            return isFuture ? "kuukauden" : "kuukausi";

          case "MM":
            result = isFuture ? "kuukauden" : "kuukautta";
            break;

          case "y":
            return isFuture ? "vuoden" : "vuosi";

          case "yy":
            result = isFuture ? "vuoden" : "vuotta";
            break;
        }
        result = verbalNumber(number, isFuture) + " " + result;
        return result;
    }
    function verbalNumber(number, isFuture) {
        return number < 10 ? isFuture ? numbersFuture[number] : numbersPast[number] : number;
    }
    hooks.defineLocale("fi", {
        months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"),
        monthsShort: "tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu".split("_"),
        weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"),
        weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"),
        weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD.MM.YYYY",
            LL: "Do MMMM[ta] YYYY",
            LLL: "Do MMMM[ta] YYYY, [klo] HH.mm",
            LLLL: "dddd, Do MMMM[ta] YYYY, [klo] HH.mm",
            l: "D.M.YYYY",
            ll: "Do MMM YYYY",
            lll: "Do MMM YYYY, [klo] HH.mm",
            llll: "ddd, Do MMM YYYY, [klo] HH.mm"
        },
        calendar: {
            sameDay: "[tnn] [klo] LT",
            nextDay: "[huomenna] [klo] LT",
            nextWeek: "dddd [klo] LT",
            lastDay: "[eilen] [klo] LT",
            lastWeek: "[viime] dddd[na] [klo] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s pst",
            past: "%s sitten",
            s: translate$2,
            ss: translate$2,
            m: translate$2,
            mm: translate$2,
            h: translate$2,
            hh: translate$2,
            d: translate$2,
            dd: translate$2,
            M: translate$2,
            MM: translate$2,
            y: translate$2,
            yy: translate$2
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("fil", {
        months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),
        monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
        weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),
        weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
        weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "MM/D/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY HH:mm",
            LLLL: "dddd, MMMM DD, YYYY HH:mm"
        },
        calendar: {
            sameDay: "LT [ngayong araw]",
            nextDay: "[Bukas ng] LT",
            nextWeek: "LT [sa susunod na] dddd",
            lastDay: "LT [kahapon]",
            lastWeek: "LT [noong nakaraang] dddd",
            sameElse: "L"
        },
        relativeTime: {
            future: "sa loob ng %s",
            past: "%s ang nakalipas",
            s: "ilang segundo",
            ss: "%d segundo",
            m: "isang minuto",
            mm: "%d minuto",
            h: "isang oras",
            hh: "%d oras",
            d: "isang araw",
            dd: "%d araw",
            M: "isang buwan",
            MM: "%d buwan",
            y: "isang taon",
            yy: "%d taon"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function(number) {
            return number;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("fo", {
        months: "januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember".split("_"),
        monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
        weekdays: "sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur".split("_"),
        weekdaysShort: "sun_mn_ts_mik_hs_fr_ley".split("_"),
        weekdaysMin: "su_m_t_mi_h_fr_le".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D. MMMM, YYYY HH:mm"
        },
        calendar: {
            sameDay: "[ dag kl.] LT",
            nextDay: "[ morgin kl.] LT",
            nextWeek: "dddd [kl.] LT",
            lastDay: "[ gjr kl.] LT",
            lastWeek: "[sstu] dddd [kl] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "um %s",
            past: "%s sani",
            s: "f sekund",
            ss: "%d sekundir",
            m: "ein minuttur",
            mm: "%d minuttir",
            h: "ein tmi",
            hh: "%d tmar",
            d: "ein dagur",
            dd: "%d dagar",
            M: "ein mnaur",
            MM: "%d mnair",
            y: "eitt r",
            yy: "%d r"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("fr-ca", {
        months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"),
        monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"),
        monthsParseExact: true,
        weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
        weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
        weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Aujourdhui ] LT",
            nextDay: "[Demain ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[Hier ] LT",
            lastWeek: "dddd [dernier ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dans %s",
            past: "il y a %s",
            s: "quelques secondes",
            ss: "%d secondes",
            m: "une minute",
            mm: "%d minutes",
            h: "une heure",
            hh: "%d heures",
            d: "un jour",
            dd: "%d jours",
            M: "un mois",
            MM: "%d mois",
            y: "un an",
            yy: "%d ans"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal: function(number, period) {
            switch (period) {
              default:
              case "M":
              case "Q":
              case "D":
              case "DDD":
              case "d":
                return number + (number === 1 ? "er" : "e");

              case "w":
              case "W":
                return number + (number === 1 ? "re" : "e");
            }
        }
    });
    hooks.defineLocale("fr-ch", {
        months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"),
        monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"),
        monthsParseExact: true,
        weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
        weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
        weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Aujourdhui ] LT",
            nextDay: "[Demain ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[Hier ] LT",
            lastWeek: "dddd [dernier ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dans %s",
            past: "il y a %s",
            s: "quelques secondes",
            ss: "%d secondes",
            m: "une minute",
            mm: "%d minutes",
            h: "une heure",
            hh: "%d heures",
            d: "un jour",
            dd: "%d jours",
            M: "un mois",
            MM: "%d mois",
            y: "un an",
            yy: "%d ans"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal: function(number, period) {
            switch (period) {
              default:
              case "M":
              case "Q":
              case "D":
              case "DDD":
              case "d":
                return number + (number === 1 ? "er" : "e");

              case "w":
              case "W":
                return number + (number === 1 ? "re" : "e");
            }
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var monthsStrictRegex$1 = /^(janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i, monthsShortStrictRegex$1 = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?)/i, monthsRegex$7 = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?|janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i, monthsParse$6 = [ /^janv/i, /^fvr/i, /^mars/i, /^avr/i, /^mai/i, /^juin/i, /^juil/i, /^aot/i, /^sept/i, /^oct/i, /^nov/i, /^dc/i ];
    hooks.defineLocale("fr", {
        months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"),
        monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"),
        monthsRegex: monthsRegex$7,
        monthsShortRegex: monthsRegex$7,
        monthsStrictRegex: monthsStrictRegex$1,
        monthsShortStrictRegex: monthsShortStrictRegex$1,
        monthsParse: monthsParse$6,
        longMonthsParse: monthsParse$6,
        shortMonthsParse: monthsParse$6,
        weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
        weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
        weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Aujourdhui ] LT",
            nextDay: "[Demain ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[Hier ] LT",
            lastWeek: "dddd [dernier ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dans %s",
            past: "il y a %s",
            s: "quelques secondes",
            ss: "%d secondes",
            m: "une minute",
            mm: "%d minutes",
            h: "une heure",
            hh: "%d heures",
            d: "un jour",
            dd: "%d jours",
            w: "une semaine",
            ww: "%d semaines",
            M: "un mois",
            MM: "%d mois",
            y: "un an",
            yy: "%d ans"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
        ordinal: function(number, period) {
            switch (period) {
              case "D":
                return number + (number === 1 ? "er" : "");

              default:
              case "M":
              case "Q":
              case "DDD":
              case "d":
                return number + (number === 1 ? "er" : "e");

              case "w":
              case "W":
                return number + (number === 1 ? "re" : "e");
            }
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var monthsShortWithDots = "jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"), monthsShortWithoutDots = "jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");
    hooks.defineLocale("fy", {
        months: "jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split("_"),
        monthsShort: function(m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },
        monthsParseExact: true,
        weekdays: "snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split("_"),
        weekdaysShort: "si._mo._ti._wo._to._fr._so.".split("_"),
        weekdaysMin: "Si_Mo_Ti_Wo_To_Fr_So".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD-MM-YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[hjoed om] LT",
            nextDay: "[moarn om] LT",
            nextWeek: "dddd [om] LT",
            lastDay: "[juster om] LT",
            lastWeek: "[frne] dddd [om] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "oer %s",
            past: "%s lyn",
            s: "in pear sekonden",
            ss: "%d sekonden",
            m: "ien mint",
            mm: "%d minuten",
            h: "ien oere",
            hh: "%d oeren",
            d: "ien dei",
            dd: "%d dagen",
            M: "ien moanne",
            MM: "%d moannen",
            y: "ien jier",
            yy: "%d jierren"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function(number) {
            return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var months$6 = [ "Eanir", "Feabhra", "Mrta", "Aibren", "Bealtaine", "Meitheamh", "Iil", "Lnasa", "Men Fmhair", "Deireadh Fmhair", "Samhain", "Nollaig" ], monthsShort$5 = [ "Ean", "Feabh", "Mrt", "Aib", "Beal", "Meith", "Iil", "Ln", "M.F.", "D.F.", "Samh", "Noll" ], weekdays$1 = [ "D Domhnaigh", "D Luain", "D Mirt", "D Cadaoin", "Dardaoin", "D hAoine", "D Sathairn" ], weekdaysShort = [ "Domh", "Luan", "Mirt", "Cad", "Dar", "Aoine", "Sath" ], weekdaysMin = [ "Do", "Lu", "M", "C", "D", "A", "Sa" ];
    hooks.defineLocale("ga", {
        months: months$6,
        monthsShort: monthsShort$5,
        monthsParseExact: true,
        weekdays: weekdays$1,
        weekdaysShort: weekdaysShort,
        weekdaysMin: weekdaysMin,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Inniu ag] LT",
            nextDay: "[Amrach ag] LT",
            nextWeek: "dddd [ag] LT",
            lastDay: "[Inn ag] LT",
            lastWeek: "dddd [seo caite] [ag] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "i %s",
            past: "%s  shin",
            s: "cpla soicind",
            ss: "%d soicind",
            m: "nimad",
            mm: "%d nimad",
            h: "uair an chloig",
            hh: "%d uair an chloig",
            d: "l",
            dd: "%d l",
            M: "m",
            MM: "%d monna",
            y: "bliain",
            yy: "%d bliain"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
        ordinal: function(number) {
            var output = number === 1 ? "d" : number % 10 === 2 ? "na" : "mh";
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var months$7 = [ "Am Faoilleach", "An Gearran", "Am Mrt", "An Giblean", "An Citean", "An t-gmhios", "An t-Iuchar", "An Lnastal", "An t-Sultain", "An Dmhair", "An t-Samhain", "An Dbhlachd" ], monthsShort$6 = [ "Faoi", "Gear", "Mrt", "Gibl", "Cit", "gmh", "Iuch", "Ln", "Sult", "Dmh", "Samh", "Dbh" ], weekdays$2 = [ "Didmhnaich", "Diluain", "Dimirt", "Diciadain", "Diardaoin", "Dihaoine", "Disathairne" ], weekdaysShort$1 = [ "Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis" ], weekdaysMin$1 = [ "D", "Lu", "M", "Ci", "Ar", "Ha", "Sa" ];
    hooks.defineLocale("gd", {
        months: months$7,
        monthsShort: monthsShort$6,
        monthsParseExact: true,
        weekdays: weekdays$2,
        weekdaysShort: weekdaysShort$1,
        weekdaysMin: weekdaysMin$1,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[An-diugh aig] LT",
            nextDay: "[A-mireach aig] LT",
            nextWeek: "dddd [aig] LT",
            lastDay: "[An-d aig] LT",
            lastWeek: "dddd [seo chaidh] [aig] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "ann an %s",
            past: "bho chionn %s",
            s: "beagan diogan",
            ss: "%d diogan",
            m: "mionaid",
            mm: "%d mionaidean",
            h: "uair",
            hh: "%d uairean",
            d: "latha",
            dd: "%d latha",
            M: "mos",
            MM: "%d mosan",
            y: "bliadhna",
            yy: "%d bliadhna"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
        ordinal: function(number) {
            var output = number === 1 ? "d" : number % 10 === 2 ? "na" : "mh";
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("gl", {
        months: "xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro".split("_"),
        monthsShort: "xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.".split("_"),
        monthsParseExact: true,
        weekdays: "domingo_luns_martes_mrcores_xoves_venres_sbado".split("_"),
        weekdaysShort: "dom._lun._mar._mr._xov._ven._sb.".split("_"),
        weekdaysMin: "do_lu_ma_m_xo_ve_s".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D [de] MMMM [de] YYYY",
            LLL: "D [de] MMMM [de] YYYY H:mm",
            LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
        },
        calendar: {
            sameDay: function() {
                return "[hoxe " + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            nextDay: function() {
                return "[ma " + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            nextWeek: function() {
                return "dddd [" + (this.hours() !== 1 ? "s" : "a") + "] LT";
            },
            lastDay: function() {
                return "[onte " + (this.hours() !== 1 ? "" : "a") + "] LT";
            },
            lastWeek: function() {
                return "[o] dddd [pasado " + (this.hours() !== 1 ? "s" : "a") + "] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: function(str) {
                if (str.indexOf("un") === 0) {
                    return "n" + str;
                }
                return "en " + str;
            },
            past: "hai %s",
            s: "uns segundos",
            ss: "%d segundos",
            m: "un minuto",
            mm: "%d minutos",
            h: "unha hora",
            hh: "%d horas",
            d: "un da",
            dd: "%d das",
            M: "un mes",
            MM: "%d meses",
            y: "un ano",
            yy: "%d anos"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    });
    function processRelativeTime$4(number, withoutSuffix, key, isFuture) {
        var format = {
            s: [ " ", " " ],
            ss: [ number + " ", number + " " ],
            m: [ " ", " " ],
            mm: [ number + " ", number + " " ],
            h: [ " ", " " ],
            hh: [ number + " ", number + " " ],
            d: [ " ", " " ],
            dd: [ number + " ", number + " " ],
            M: [ " ", " " ],
            MM: [ number + " ", number + " " ],
            y: [ " ", " " ],
            yy: [ number + " ", number + " " ]
        };
        return isFuture ? format[key][0] : format[key][1];
    }
    hooks.defineLocale("gom-deva", {
        months: {
            standalone: "___________".split("_"),
            format: "___________".split("_"),
            isFormat: /MMMM(\s)+D[oD]?/
        },
        monthsShort: "._.__.___._._._._._.".split("_"),
        monthsParseExact: true,
        weekdays: "______".split("_"),
        weekdaysShort: "._._._._._._.".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "A h:mm []",
            LTS: "A h:mm:ss []",
            L: "DD-MM-YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY A h:mm []",
            LLLL: "dddd, MMMM Do, YYYY, A h:mm []",
            llll: "ddd, D MMM YYYY, A h:mm []"
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "[] dddd[,] LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd[,] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s",
            past: "%s ",
            s: processRelativeTime$4,
            ss: processRelativeTime$4,
            m: processRelativeTime$4,
            mm: processRelativeTime$4,
            h: processRelativeTime$4,
            hh: processRelativeTime$4,
            d: processRelativeTime$4,
            dd: processRelativeTime$4,
            M: processRelativeTime$4,
            MM: processRelativeTime$4,
            y: processRelativeTime$4,
            yy: processRelativeTime$4
        },
        dayOfMonthOrdinalParse: /\d{1,2}()/,
        ordinal: function(number, period) {
            switch (period) {
              case "D":
                return number + "";

              default:
              case "M":
              case "Q":
              case "DDD":
              case "d":
              case "w":
              case "W":
                return number;
            }
        },
        week: {
            dow: 0,
            doy: 3
        },
        meridiemParse: /|||/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "") {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour;
            } else if (meridiem === "") {
                return hour > 12 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "";
            } else if (hour < 12) {
                return "";
            } else if (hour < 16) {
                return "";
            } else if (hour < 20) {
                return "";
            } else {
                return "";
            }
        }
    });
    function processRelativeTime$5(number, withoutSuffix, key, isFuture) {
        var format = {
            s: [ "thoddea sekondamni", "thodde sekond" ],
            ss: [ number + " sekondamni", number + " sekond" ],
            m: [ "eka mintan", "ek minut" ],
            mm: [ number + " mintamni", number + " mintam" ],
            h: [ "eka voran", "ek vor" ],
            hh: [ number + " voramni", number + " voram" ],
            d: [ "eka disan", "ek dis" ],
            dd: [ number + " disamni", number + " dis" ],
            M: [ "eka mhoinean", "ek mhoino" ],
            MM: [ number + " mhoineamni", number + " mhoine" ],
            y: [ "eka vorsan", "ek voros" ],
            yy: [ number + " vorsamni", number + " vorsam" ]
        };
        return isFuture ? format[key][0] : format[key][1];
    }
    hooks.defineLocale("gom-latn", {
        months: {
            standalone: "Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr".split("_"),
            format: "Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea".split("_"),
            isFormat: /MMMM(\s)+D[oD]?/
        },
        monthsShort: "Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.".split("_"),
        monthsParseExact: true,
        weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split("_"),
        weekdaysShort: "Ait._Som._Mon._Bud._Bre._Suk._Son.".split("_"),
        weekdaysMin: "Ai_Sm_Mo_Bu_Br_Su_Sn".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "A h:mm [vazta]",
            LTS: "A h:mm:ss [vazta]",
            L: "DD-MM-YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY A h:mm [vazta]",
            LLLL: "dddd, MMMM Do, YYYY, A h:mm [vazta]",
            llll: "ddd, D MMM YYYY, A h:mm [vazta]"
        },
        calendar: {
            sameDay: "[Aiz] LT",
            nextDay: "[Faleam] LT",
            nextWeek: "[Fuddlo] dddd[,] LT",
            lastDay: "[Kal] LT",
            lastWeek: "[Fattlo] dddd[,] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s",
            past: "%s adim",
            s: processRelativeTime$5,
            ss: processRelativeTime$5,
            m: processRelativeTime$5,
            mm: processRelativeTime$5,
            h: processRelativeTime$5,
            hh: processRelativeTime$5,
            d: processRelativeTime$5,
            dd: processRelativeTime$5,
            M: processRelativeTime$5,
            MM: processRelativeTime$5,
            y: processRelativeTime$5,
            yy: processRelativeTime$5
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er)/,
        ordinal: function(number, period) {
            switch (period) {
              case "D":
                return number + "er";

              default:
              case "M":
              case "Q":
              case "DDD":
              case "d":
              case "w":
              case "W":
                return number;
            }
        },
        week: {
            dow: 0,
            doy: 3
        },
        meridiemParse: /rati|sokallim|donparam|sanje/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "rati") {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === "sokallim") {
                return hour;
            } else if (meridiem === "donparam") {
                return hour > 12 ? hour : hour + 12;
            } else if (meridiem === "sanje") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "rati";
            } else if (hour < 12) {
                return "sokallim";
            } else if (hour < 16) {
                return "donparam";
            } else if (hour < 20) {
                return "sanje";
            } else {
                return "rati";
            }
        }
    });
    var symbolMap$7 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$6 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("gu", {
        months: "___________".split("_"),
        monthsShort: "._.__.___._._._._._.".split("_"),
        monthsParseExact: true,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm ",
            LTS: "A h:mm:ss ",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm ",
            LLLL: "dddd, D MMMM YYYY, A h:mm "
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$6[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$7[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "") {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour;
            } else if (meridiem === "") {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "";
            } else if (hour < 10) {
                return "";
            } else if (hour < 17) {
                return "";
            } else if (hour < 20) {
                return "";
            } else {
                return "";
            }
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    hooks.defineLocale("he", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D []MMMM YYYY",
            LLL: "D []MMMM YYYY HH:mm",
            LLLL: "dddd, D []MMMM YYYY HH:mm",
            l: "D/M/YYYY",
            ll: "D MMM YYYY",
            lll: "D MMM YYYY HH:mm",
            llll: "ddd, D MMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[ ]LT",
            nextDay: "[ ]LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ ]LT",
            lastWeek: "[] dddd [ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: " ",
            ss: "%d ",
            m: "",
            mm: "%d ",
            h: "",
            hh: function(number) {
                if (number === 2) {
                    return "";
                }
                return number + " ";
            },
            d: "",
            dd: function(number) {
                if (number === 2) {
                    return "";
                }
                return number + " ";
            },
            M: "",
            MM: function(number) {
                if (number === 2) {
                    return "";
                }
                return number + " ";
            },
            y: "",
            yy: function(number) {
                if (number === 2) {
                    return "";
                } else if (number % 10 === 0 && number !== 10) {
                    return number + " ";
                }
                return number + " ";
            }
        },
        meridiemParse: /"|"| | | ||/i,
        isPM: function(input) {
            return /^("| |)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 5) {
                return " ";
            } else if (hour < 10) {
                return "";
            } else if (hour < 12) {
                return isLower ? '"' : " ";
            } else if (hour < 18) {
                return isLower ? '"' : " ";
            } else {
                return "";
            }
        }
    });
    var symbolMap$8 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$7 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    }, monthsParse$7 = [ /^/i, /^|/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^|/i, /^/i, /^|/i, /^|/i ], shortMonthsParse = [ /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i ];
    hooks.defineLocale("hi", {
        months: {
            format: "___________".split("_"),
            standalone: "___________".split("_")
        },
        monthsShort: "._.__.___._._._._._.".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm ",
            LTS: "A h:mm:ss ",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm ",
            LLLL: "dddd, D MMMM YYYY, A h:mm "
        },
        monthsParse: monthsParse$7,
        longMonthsParse: monthsParse$7,
        shortMonthsParse: shortMonthsParse,
        monthsRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,
        monthsShortRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,
        monthsStrictRegex: /^(?||?|?|?|?|?|?|?|||?\.?||\.?||?||?)/i,
        monthsShortStrictRegex: /^(\.?|\.?|?|\.?|?|?|\.?|\.?|\.?|\.?|\.?|\.?)/i,
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: "  ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$7[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$8[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "") {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour;
            } else if (meridiem === "") {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "";
            } else if (hour < 10) {
                return "";
            } else if (hour < 17) {
                return "";
            } else if (hour < 20) {
                return "";
            } else {
                return "";
            }
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    function translate$3(number, withoutSuffix, key) {
        var result = number + " ";
        switch (key) {
          case "ss":
            if (number === 1) {
                result += "sekunda";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "sekunde";
            } else {
                result += "sekundi";
            }
            return result;

          case "m":
            return withoutSuffix ? "jedna minuta" : "jedne minute";

          case "mm":
            if (number === 1) {
                result += "minuta";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "minute";
            } else {
                result += "minuta";
            }
            return result;

          case "h":
            return withoutSuffix ? "jedan sat" : "jednog sata";

          case "hh":
            if (number === 1) {
                result += "sat";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "sata";
            } else {
                result += "sati";
            }
            return result;

          case "dd":
            if (number === 1) {
                result += "dan";
            } else {
                result += "dana";
            }
            return result;

          case "MM":
            if (number === 1) {
                result += "mjesec";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "mjeseca";
            } else {
                result += "mjeseci";
            }
            return result;

          case "yy":
            if (number === 1) {
                result += "godina";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "godine";
            } else {
                result += "godina";
            }
            return result;
        }
    }
    hooks.defineLocale("hr", {
        months: {
            format: "sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca".split("_"),
            standalone: "sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_")
        },
        monthsShort: "sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"),
        monthsParseExact: true,
        weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split("_"),
        weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"),
        weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "Do MMMM YYYY",
            LLL: "Do MMMM YYYY H:mm",
            LLLL: "dddd, Do MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[danas u] LT",
            nextDay: "[sutra u] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[u] [nedjelju] [u] LT";

                  case 3:
                    return "[u] [srijedu] [u] LT";

                  case 6:
                    return "[u] [subotu] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[u] dddd [u] LT";
                }
            },
            lastDay: "[juer u] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[prolu] [nedjelju] [u] LT";

                  case 3:
                    return "[prolu] [srijedu] [u] LT";

                  case 6:
                    return "[prole] [subote] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[proli] dddd [u] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "prije %s",
            s: "par sekundi",
            ss: translate$3,
            m: translate$3,
            mm: translate$3,
            h: translate$3,
            hh: translate$3,
            d: "dan",
            dd: translate$3,
            M: "mjesec",
            MM: translate$3,
            y: "godinu",
            yy: translate$3
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var weekEndings = "vasrnap htfn kedden szerdn cstrtkn pnteken szombaton".split(" ");
    function translate$4(number, withoutSuffix, key, isFuture) {
        var num = number;
        switch (key) {
          case "s":
            return isFuture || withoutSuffix ? "nhny msodperc" : "nhny msodperce";

          case "ss":
            return num + (isFuture || withoutSuffix) ? " msodperc" : " msodperce";

          case "m":
            return "egy" + (isFuture || withoutSuffix ? " perc" : " perce");

          case "mm":
            return num + (isFuture || withoutSuffix ? " perc" : " perce");

          case "h":
            return "egy" + (isFuture || withoutSuffix ? " ra" : " rja");

          case "hh":
            return num + (isFuture || withoutSuffix ? " ra" : " rja");

          case "d":
            return "egy" + (isFuture || withoutSuffix ? " nap" : " napja");

          case "dd":
            return num + (isFuture || withoutSuffix ? " nap" : " napja");

          case "M":
            return "egy" + (isFuture || withoutSuffix ? " hnap" : " hnapja");

          case "MM":
            return num + (isFuture || withoutSuffix ? " hnap" : " hnapja");

          case "y":
            return "egy" + (isFuture || withoutSuffix ? " v" : " ve");

          case "yy":
            return num + (isFuture || withoutSuffix ? " v" : " ve");
        }
        return "";
    }
    function week(isFuture) {
        return (isFuture ? "" : "[mlt] ") + "[" + weekEndings[this.day()] + "] LT[-kor]";
    }
    hooks.defineLocale("hu", {
        months: "janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december".split("_"),
        monthsShort: "jan._feb._mrc._pr._mj._jn._jl._aug._szept._okt._nov._dec.".split("_"),
        monthsParseExact: true,
        weekdays: "vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat".split("_"),
        weekdaysShort: "vas_ht_kedd_sze_cst_pn_szo".split("_"),
        weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "YYYY.MM.DD.",
            LL: "YYYY. MMMM D.",
            LLL: "YYYY. MMMM D. H:mm",
            LLLL: "YYYY. MMMM D., dddd H:mm"
        },
        meridiemParse: /de|du/i,
        isPM: function(input) {
            return input.charAt(1).toLowerCase() === "u";
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours < 12) {
                return isLower === true ? "de" : "DE";
            } else {
                return isLower === true ? "du" : "DU";
            }
        },
        calendar: {
            sameDay: "[ma] LT[-kor]",
            nextDay: "[holnap] LT[-kor]",
            nextWeek: function() {
                return week.call(this, true);
            },
            lastDay: "[tegnap] LT[-kor]",
            lastWeek: function() {
                return week.call(this, false);
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "%s mlva",
            past: "%s",
            s: translate$4,
            ss: translate$4,
            m: translate$4,
            mm: translate$4,
            h: translate$4,
            hh: translate$4,
            d: translate$4,
            dd: translate$4,
            M: translate$4,
            MM: translate$4,
            y: translate$4,
            yy: translate$4
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("hy-am", {
        months: {
            format: "___________".split("_"),
            standalone: "___________".split("_")
        },
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY .",
            LLL: "D MMMM YYYY ., HH:mm",
            LLLL: "dddd, D MMMM YYYY ., HH:mm"
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            lastDay: "[] LT",
            nextWeek: function() {
                return "dddd [ ] LT";
            },
            lastWeek: function() {
                return "[] dddd [ ] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: "  ",
            ss: "%d ",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        meridiemParse: /|||/,
        isPM: function(input) {
            return /^(|)$/.test(input);
        },
        meridiem: function(hour) {
            if (hour < 4) {
                return "";
            } else if (hour < 12) {
                return "";
            } else if (hour < 17) {
                return "";
            } else {
                return "";
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
        ordinal: function(number, period) {
            switch (period) {
              case "DDD":
              case "w":
              case "W":
              case "DDDo":
                if (number === 1) {
                    return number + "-";
                }
                return number + "-";

              default:
                return number;
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("id", {
        months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des".split("_"),
        weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"),
        weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"),
        weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY [pukul] HH.mm",
            LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "pagi") {
                return hour;
            } else if (meridiem === "siang") {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === "sore" || meridiem === "malam") {
                return hour + 12;
            }
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours < 11) {
                return "pagi";
            } else if (hours < 15) {
                return "siang";
            } else if (hours < 19) {
                return "sore";
            } else {
                return "malam";
            }
        },
        calendar: {
            sameDay: "[Hari ini pukul] LT",
            nextDay: "[Besok pukul] LT",
            nextWeek: "dddd [pukul] LT",
            lastDay: "[Kemarin pukul] LT",
            lastWeek: "dddd [lalu pukul] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dalam %s",
            past: "%s yang lalu",
            s: "beberapa detik",
            ss: "%d detik",
            m: "semenit",
            mm: "%d menit",
            h: "sejam",
            hh: "%d jam",
            d: "sehari",
            dd: "%d hari",
            M: "sebulan",
            MM: "%d bulan",
            y: "setahun",
            yy: "%d tahun"
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    function plural$2(n) {
        if (n % 100 === 11) {
            return true;
        } else if (n % 10 === 1) {
            return false;
        }
        return true;
    }
    function translate$5(number, withoutSuffix, key, isFuture) {
        var result = number + " ";
        switch (key) {
          case "s":
            return withoutSuffix || isFuture ? "nokkrar sekndur" : "nokkrum sekndum";

          case "ss":
            if (plural$2(number)) {
                return result + (withoutSuffix || isFuture ? "sekndur" : "sekndum");
            }
            return result + "seknda";

          case "m":
            return withoutSuffix ? "mnta" : "mntu";

          case "mm":
            if (plural$2(number)) {
                return result + (withoutSuffix || isFuture ? "mntur" : "mntum");
            } else if (withoutSuffix) {
                return result + "mnta";
            }
            return result + "mntu";

          case "hh":
            if (plural$2(number)) {
                return result + (withoutSuffix || isFuture ? "klukkustundir" : "klukkustundum");
            }
            return result + "klukkustund";

          case "d":
            if (withoutSuffix) {
                return "dagur";
            }
            return isFuture ? "dag" : "degi";

          case "dd":
            if (plural$2(number)) {
                if (withoutSuffix) {
                    return result + "dagar";
                }
                return result + (isFuture ? "daga" : "dgum");
            } else if (withoutSuffix) {
                return result + "dagur";
            }
            return result + (isFuture ? "dag" : "degi");

          case "M":
            if (withoutSuffix) {
                return "mnuur";
            }
            return isFuture ? "mnu" : "mnui";

          case "MM":
            if (plural$2(number)) {
                if (withoutSuffix) {
                    return result + "mnuir";
                }
                return result + (isFuture ? "mnui" : "mnuum");
            } else if (withoutSuffix) {
                return result + "mnuur";
            }
            return result + (isFuture ? "mnu" : "mnui");

          case "y":
            return withoutSuffix || isFuture ? "r" : "ri";

          case "yy":
            if (plural$2(number)) {
                return result + (withoutSuffix || isFuture ? "r" : "rum");
            }
            return result + (withoutSuffix || isFuture ? "r" : "ri");
        }
    }
    hooks.defineLocale("is", {
        months: "janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember".split("_"),
        monthsShort: "jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des".split("_"),
        weekdays: "sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur".split("_"),
        weekdaysShort: "sun_mn_ri_mi_fim_fs_lau".split("_"),
        weekdaysMin: "Su_M_r_Mi_Fi_F_La".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY [kl.] H:mm",
            LLLL: "dddd, D. MMMM YYYY [kl.] H:mm"
        },
        calendar: {
            sameDay: "[ dag kl.] LT",
            nextDay: "[ morgun kl.] LT",
            nextWeek: "dddd [kl.] LT",
            lastDay: "[ gr kl.] LT",
            lastWeek: "[sasta] dddd [kl.] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "eftir %s",
            past: "fyrir %s san",
            s: translate$5,
            ss: translate$5,
            m: translate$5,
            mm: translate$5,
            h: "klukkustund",
            hh: translate$5,
            d: translate$5,
            dd: translate$5,
            M: translate$5,
            MM: translate$5,
            y: translate$5,
            yy: translate$5
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("it-ch", {
        months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),
        monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
        weekdays: "domenica_luned_marted_mercoled_gioved_venerd_sabato".split("_"),
        weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
        weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Oggi alle] LT",
            nextDay: "[Domani alle] LT",
            nextWeek: "dddd [alle] LT",
            lastDay: "[Ieri alle] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[la scorsa] dddd [alle] LT";

                  default:
                    return "[lo scorso] dddd [alle] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: function(s) {
                return (/^[0-9].+$/.test(s) ? "tra" : "in") + " " + s;
            },
            past: "%s fa",
            s: "alcuni secondi",
            ss: "%d secondi",
            m: "un minuto",
            mm: "%d minuti",
            h: "un'ora",
            hh: "%d ore",
            d: "un giorno",
            dd: "%d giorni",
            M: "un mese",
            MM: "%d mesi",
            y: "un anno",
            yy: "%d anni"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("it", {
        months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),
        monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
        weekdays: "domenica_luned_marted_mercoled_gioved_venerd_sabato".split("_"),
        weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
        weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: function() {
                return "[Oggi a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
            },
            nextDay: function() {
                return "[Domani a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
            },
            nextWeek: function() {
                return "dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
            },
            lastDay: function() {
                return "[Ieri a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
            },
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[La scorsa] dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";

                  default:
                    return "[Lo scorso] dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "tra %s",
            past: "%s fa",
            s: "alcuni secondi",
            ss: "%d secondi",
            m: "un minuto",
            mm: "%d minuti",
            h: "un'ora",
            hh: "%d ore",
            d: "un giorno",
            dd: "%d giorni",
            w: "una settimana",
            ww: "%d settimane",
            M: "un mese",
            MM: "%d mesi",
            y: "un anno",
            yy: "%d anni"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("ja", {
        eras: [ {
            since: "2019-05-01",
            offset: 1,
            name: "",
            narrow: "",
            abbr: "R"
        }, {
            since: "1989-01-08",
            until: "2019-04-30",
            offset: 1,
            name: "",
            narrow: "",
            abbr: "H"
        }, {
            since: "1926-12-25",
            until: "1989-01-07",
            offset: 1,
            name: "",
            narrow: "",
            abbr: "S"
        }, {
            since: "1912-07-30",
            until: "1926-12-24",
            offset: 1,
            name: "",
            narrow: "",
            abbr: "T"
        }, {
            since: "1873-01-01",
            until: "1912-07-29",
            offset: 6,
            name: "",
            narrow: "",
            abbr: "M"
        }, {
            since: "0001-01-01",
            until: "1873-12-31",
            offset: 1,
            name: "",
            narrow: "AD",
            abbr: "AD"
        }, {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "",
            narrow: "BC",
            abbr: "BC"
        } ],
        eraYearOrdinalRegex: /(|\d+)/,
        eraYearOrdinalParse: function(input, match) {
            return match[1] === "" ? 1 : parseInt(match[1] || input, 10);
        },
        months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY/MM/DD",
            LL: "YYYYMD",
            LLL: "YYYYMD HH:mm",
            LLLL: "YYYYMD dddd HH:mm",
            l: "YYYY/MM/DD",
            ll: "YYYYMD",
            lll: "YYYYMD HH:mm",
            llll: "YYYYMD(ddd) HH:mm"
        },
        meridiemParse: /|/i,
        isPM: function(input) {
            return input === "";
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: function(now) {
                if (now.week() !== this.week()) {
                    return "[]dddd LT";
                } else {
                    return "dddd LT";
                }
            },
            lastDay: "[] LT",
            lastWeek: function(now) {
                if (this.week() !== now.week()) {
                    return "[]dddd LT";
                } else {
                    return "dddd LT";
                }
            },
            sameElse: "L"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function(number, period) {
            switch (period) {
              case "y":
                return number === 1 ? "" : number + "";

              case "d":
              case "D":
              case "DDD":
                return number + "";

              default:
                return number;
            }
        },
        relativeTime: {
            future: "%s",
            past: "%s",
            s: "",
            ss: "%d",
            m: "1",
            mm: "%d",
            h: "1",
            hh: "%d",
            d: "1",
            dd: "%d",
            M: "1",
            MM: "%d",
            y: "1",
            yy: "%d"
        }
    });
    hooks.defineLocale("jv", {
        months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"),
        weekdays: "Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"),
        weekdaysShort: "Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"),
        weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY [pukul] HH.mm",
            LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "enjing") {
                return hour;
            } else if (meridiem === "siyang") {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === "sonten" || meridiem === "ndalu") {
                return hour + 12;
            }
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours < 11) {
                return "enjing";
            } else if (hours < 15) {
                return "siyang";
            } else if (hours < 19) {
                return "sonten";
            } else {
                return "ndalu";
            }
        },
        calendar: {
            sameDay: "[Dinten puniko pukul] LT",
            nextDay: "[Mbenjang pukul] LT",
            nextWeek: "dddd [pukul] LT",
            lastDay: "[Kala wingi pukul] LT",
            lastWeek: "dddd [kepengker pukul] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "wonten ing %s",
            past: "%s ingkang kepengker",
            s: "sawetawis detik",
            ss: "%d detik",
            m: "setunggal menit",
            mm: "%d menit",
            h: "setunggal jam",
            hh: "%d jam",
            d: "sedinten",
            dd: "%d dinten",
            M: "sewulan",
            MM: "%d wulan",
            y: "setaun",
            yy: "%d taun"
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("ka", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: {
            standalone: "______".split("_"),
            format: "______".split("_"),
            isFormat: /(|)/
        },
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[] LT[-]",
            nextDay: "[] LT[-]",
            lastDay: "[] LT[-]",
            nextWeek: "[] dddd LT[-]",
            lastWeek: "[] dddd LT-",
            sameElse: "L"
        },
        relativeTime: {
            future: function(s) {
                return s.replace(/(|||||)(|)/, function($0, $1, $2) {
                    return $2 === "" ? $1 + "" : $1 + $2 + "";
                });
            },
            past: function(s) {
                if (/(||||)/.test(s)) {
                    return s.replace(/(|)$/, " ");
                }
                if (//.test(s)) {
                    return s.replace(/$/, " ");
                }
                return s;
            },
            s: " ",
            ss: "%d ",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
        ordinal: function(number) {
            if (number === 0) {
                return number;
            }
            if (number === 1) {
                return number + "-";
            }
            if (number < 20 || number <= 100 && number % 20 === 0 || number % 100 === 0) {
                return "-" + number;
            }
            return number + "-";
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var suffixes$1 = {
        0: "-",
        1: "-",
        2: "-",
        3: "-",
        4: "-",
        5: "-",
        6: "-",
        7: "-",
        8: "-",
        9: "-",
        10: "-",
        20: "-",
        30: "-",
        40: "-",
        50: "-",
        60: "-",
        70: "-",
        80: "-",
        90: "-",
        100: "-"
    };
    hooks.defineLocale("kk", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ ] LT",
            lastWeek: "[ ] dddd [] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
        ordinal: function(number) {
            var a = number % 10, b = number >= 100 ? 100 : null;
            return number + (suffixes$1[number] || suffixes$1[a] || suffixes$1[b]);
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var symbolMap$9 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$8 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("km", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return input === "";
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ ] LT",
            lastWeek: "dddd [] [] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s",
            past: "%s",
            s: "",
            ss: "%d ",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$8[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$9[match];
            });
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var symbolMap$a = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$9 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("kn", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        monthsParseExact: true,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm",
            LTS: "A h:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm",
            LLLL: "dddd, D MMMM YYYY, A h:mm"
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$9[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$a[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "") {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour;
            } else if (meridiem === "") {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "";
            } else if (hour < 10) {
                return "";
            } else if (hour < 17) {
                return "";
            } else if (hour < 20) {
                return "";
            } else {
                return "";
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}()/,
        ordinal: function(number) {
            return number + "";
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    hooks.defineLocale("ko", {
        months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm",
            LTS: "A h:mm:ss",
            L: "YYYY.MM.DD.",
            LL: "YYYY MMMM D",
            LLL: "YYYY MMMM D A h:mm",
            LLLL: "YYYY MMMM D dddd A h:mm",
            l: "YYYY.MM.DD.",
            ll: "YYYY MMMM D",
            lll: "YYYY MMMM D A h:mm",
            llll: "YYYY MMMM D dddd A h:mm"
        },
        calendar: {
            sameDay: " LT",
            nextDay: " LT",
            nextWeek: "dddd LT",
            lastDay: " LT",
            lastWeek: " dddd LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            ss: "%d",
            m: "1",
            mm: "%d",
            h: " ",
            hh: "%d",
            d: "",
            dd: "%d",
            M: " ",
            MM: "%d",
            y: " ",
            yy: "%d"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal: function(number, period) {
            switch (period) {
              case "d":
              case "D":
              case "DDD":
                return number + "";

              case "M":
                return number + "";

              case "w":
              case "W":
                return number + "";

              default:
                return number;
            }
        },
        meridiemParse: /|/,
        isPM: function(token) {
            return token === "";
        },
        meridiem: function(hour, minute, isUpper) {
            return hour < 12 ? "" : "";
        }
    });
    var symbolMap$b = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$a = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    }, months$8 = [ " ", "", "", "", "", "", "", "", "", " ", " ", " " ];
    hooks.defineLocale("ku", {
        months: months$8,
        monthsShort: months$8,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return //.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ ] LT",
            lastWeek: "dddd [] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: "%s",
            s: " ",
            ss: " %d",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$a[match];
            }).replace(//g, ",");
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$b[match];
            }).replace(/,/g, "");
        },
        week: {
            dow: 6,
            doy: 12
        }
    });
    var suffixes$2 = {
        0: "-",
        1: "-",
        2: "-",
        3: "-",
        4: "-",
        5: "-",
        6: "-",
        7: "-",
        8: "-",
        9: "-",
        10: "-",
        20: "-",
        30: "-",
        40: "-",
        50: "-",
        60: "-",
        70: "-",
        80: "-",
        90: "-",
        100: "-"
    };
    hooks.defineLocale("ky", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ ] LT",
            lastWeek: "[ ] dddd [] [] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
        ordinal: function(number) {
            var a = number % 10, b = number >= 100 ? 100 : null;
            return number + (suffixes$2[number] || suffixes$2[a] || suffixes$2[b]);
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    function processRelativeTime$6(number, withoutSuffix, key, isFuture) {
        var format = {
            m: [ "eng Minutt", "enger Minutt" ],
            h: [ "eng Stonn", "enger Stonn" ],
            d: [ "een Dag", "engem Dag" ],
            M: [ "ee Mount", "engem Mount" ],
            y: [ "ee Joer", "engem Joer" ]
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processFutureTime(string) {
        var number = string.substr(0, string.indexOf(" "));
        if (eifelerRegelAppliesToNumber(number)) {
            return "a " + string;
        }
        return "an " + string;
    }
    function processPastTime(string) {
        var number = string.substr(0, string.indexOf(" "));
        if (eifelerRegelAppliesToNumber(number)) {
            return "viru " + string;
        }
        return "virun " + string;
    }
    function eifelerRegelAppliesToNumber(number) {
        number = parseInt(number, 10);
        if (isNaN(number)) {
            return false;
        }
        if (number < 0) {
            return true;
        } else if (number < 10) {
            if (4 <= number && number <= 7) {
                return true;
            }
            return false;
        } else if (number < 100) {
            var lastDigit = number % 10, firstDigit = number / 10;
            if (lastDigit === 0) {
                return eifelerRegelAppliesToNumber(firstDigit);
            }
            return eifelerRegelAppliesToNumber(lastDigit);
        } else if (number < 1e4) {
            while (number >= 10) {
                number = number / 10;
            }
            return eifelerRegelAppliesToNumber(number);
        } else {
            number = number / 1e3;
            return eifelerRegelAppliesToNumber(number);
        }
    }
    hooks.defineLocale("lb", {
        months: "Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
        monthsShort: "Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
        monthsParseExact: true,
        weekdays: "Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg".split("_"),
        weekdaysShort: "So._M._D._M._Do._Fr._Sa.".split("_"),
        weekdaysMin: "So_M_D_M_Do_Fr_Sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "H:mm [Auer]",
            LTS: "H:mm:ss [Auer]",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm [Auer]",
            LLLL: "dddd, D. MMMM YYYY H:mm [Auer]"
        },
        calendar: {
            sameDay: "[Haut um] LT",
            sameElse: "L",
            nextDay: "[Muer um] LT",
            nextWeek: "dddd [um] LT",
            lastDay: "[Gschter um] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 2:
                  case 4:
                    return "[Leschten] dddd [um] LT";

                  default:
                    return "[Leschte] dddd [um] LT";
                }
            }
        },
        relativeTime: {
            future: processFutureTime,
            past: processPastTime,
            s: "e puer Sekonnen",
            ss: "%d Sekonnen",
            m: processRelativeTime$6,
            mm: "%d Minutten",
            h: processRelativeTime$6,
            hh: "%d Stonnen",
            d: processRelativeTime$6,
            dd: "%d Deeg",
            M: processRelativeTime$6,
            MM: "%d Mint",
            y: processRelativeTime$6,
            yy: "%d Joer"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("lo", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return input === "";
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "[]dddd[] LT",
            lastDay: "[] LT",
            lastWeek: "[]dddd[] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: "%s",
            s: "",
            ss: "%d ",
            m: "1 ",
            mm: "%d ",
            h: "1 ",
            hh: "%d ",
            d: "1 ",
            dd: "%d ",
            M: "1 ",
            MM: "%d ",
            y: "1 ",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /()\d{1,2}/,
        ordinal: function(number) {
            return "" + number;
        }
    });
    var units = {
        ss: "sekund_sekundi_sekundes",
        m: "minut_minuts_minut",
        mm: "minuts_minui_minutes",
        h: "valanda_valandos_valand",
        hh: "valandos_valand_valandas",
        d: "diena_dienos_dien",
        dd: "dienos_dien_dienas",
        M: "mnuo_mnesio_mnes",
        MM: "mnesiai_mnesi_mnesius",
        y: "metai_met_metus",
        yy: "metai_met_metus"
    };
    function translateSeconds(number, withoutSuffix, key, isFuture) {
        if (withoutSuffix) {
            return "kelios sekunds";
        } else {
            return isFuture ? "keli sekundi" : "kelias sekundes";
        }
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
        return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
    }
    function special(number) {
        return number % 10 === 0 || number > 10 && number < 20;
    }
    function forms(key) {
        return units[key].split("_");
    }
    function translate$6(number, withoutSuffix, key, isFuture) {
        var result = number + " ";
        if (number === 1) {
            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
        } else if (withoutSuffix) {
            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
        } else {
            if (isFuture) {
                return result + forms(key)[1];
            } else {
                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
            }
        }
    }
    hooks.defineLocale("lt", {
        months: {
            format: "sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio".split("_"),
            standalone: "sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis".split("_"),
            isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
        },
        monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"),
        weekdays: {
            format: "sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien".split("_"),
            standalone: "sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis".split("_"),
            isFormat: /dddd HH:mm/
        },
        weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_e".split("_"),
        weekdaysMin: "S_P_A_T_K_Pn_".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "YYYY [m.] MMMM D [d.]",
            LLL: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
            LLLL: "YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]",
            l: "YYYY-MM-DD",
            ll: "YYYY [m.] MMMM D [d.]",
            lll: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
            llll: "YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]"
        },
        calendar: {
            sameDay: "[iandien] LT",
            nextDay: "[Rytoj] LT",
            nextWeek: "dddd LT",
            lastDay: "[Vakar] LT",
            lastWeek: "[Prajus] dddd LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "po %s",
            past: "prie %s",
            s: translateSeconds,
            ss: translate$6,
            m: translateSingular,
            mm: translate$6,
            h: translateSingular,
            hh: translate$6,
            d: translateSingular,
            dd: translate$6,
            M: translateSingular,
            MM: translate$6,
            y: translateSingular,
            yy: translate$6
        },
        dayOfMonthOrdinalParse: /\d{1,2}-oji/,
        ordinal: function(number) {
            return number + "-oji";
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var units$1 = {
        ss: "sekundes_sekundm_sekunde_sekundes".split("_"),
        m: "mintes_mintm_minte_mintes".split("_"),
        mm: "mintes_mintm_minte_mintes".split("_"),
        h: "stundas_stundm_stunda_stundas".split("_"),
        hh: "stundas_stundm_stunda_stundas".split("_"),
        d: "dienas_dienm_diena_dienas".split("_"),
        dd: "dienas_dienm_diena_dienas".split("_"),
        M: "mnea_mneiem_mnesis_mnei".split("_"),
        MM: "mnea_mneiem_mnesis_mnei".split("_"),
        y: "gada_gadiem_gads_gadi".split("_"),
        yy: "gada_gadiem_gads_gadi".split("_")
    };
    function format$1(forms, number, withoutSuffix) {
        if (withoutSuffix) {
            return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
        } else {
            return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
        }
    }
    function relativeTimeWithPlural$1(number, withoutSuffix, key) {
        return number + " " + format$1(units$1[key], number, withoutSuffix);
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
        return format$1(units$1[key], number, withoutSuffix);
    }
    function relativeSeconds(number, withoutSuffix) {
        return withoutSuffix ? "daas sekundes" : "dam sekundm";
    }
    hooks.defineLocale("lv", {
        months: "janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris".split("_"),
        monthsShort: "jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec".split("_"),
        weekdays: "svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena".split("_"),
        weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"),
        weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY.",
            LL: "YYYY. [gada] D. MMMM",
            LLL: "YYYY. [gada] D. MMMM, HH:mm",
            LLLL: "YYYY. [gada] D. MMMM, dddd, HH:mm"
        },
        calendar: {
            sameDay: "[odien pulksten] LT",
            nextDay: "[Rt pulksten] LT",
            nextWeek: "dddd [pulksten] LT",
            lastDay: "[Vakar pulksten] LT",
            lastWeek: "[Pagju] dddd [pulksten] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "pc %s",
            past: "pirms %s",
            s: relativeSeconds,
            ss: relativeTimeWithPlural$1,
            m: relativeTimeWithSingular,
            mm: relativeTimeWithPlural$1,
            h: relativeTimeWithSingular,
            hh: relativeTimeWithPlural$1,
            d: relativeTimeWithSingular,
            dd: relativeTimeWithPlural$1,
            M: relativeTimeWithSingular,
            MM: relativeTimeWithPlural$1,
            y: relativeTimeWithSingular,
            yy: relativeTimeWithPlural$1
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var translator = {
        words: {
            ss: [ "sekund", "sekunda", "sekundi" ],
            m: [ "jedan minut", "jednog minuta" ],
            mm: [ "minut", "minuta", "minuta" ],
            h: [ "jedan sat", "jednog sata" ],
            hh: [ "sat", "sata", "sati" ],
            dd: [ "dan", "dana", "dana" ],
            MM: [ "mjesec", "mjeseca", "mjeseci" ],
            yy: [ "godina", "godine", "godina" ]
        },
        correctGrammaticalCase: function(number, wordKey) {
            return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
        },
        translate: function(number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + " " + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };
    hooks.defineLocale("me", {
        months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),
        monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
        monthsParseExact: true,
        weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split("_"),
        weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"),
        weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[danas u] LT",
            nextDay: "[sjutra u] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[u] [nedjelju] [u] LT";

                  case 3:
                    return "[u] [srijedu] [u] LT";

                  case 6:
                    return "[u] [subotu] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[u] dddd [u] LT";
                }
            },
            lastDay: "[jue u] LT",
            lastWeek: function() {
                var lastWeekDays = [ "[prole] [nedjelje] [u] LT", "[prolog] [ponedjeljka] [u] LT", "[prolog] [utorka] [u] LT", "[prole] [srijede] [u] LT", "[prolog] [etvrtka] [u] LT", "[prolog] [petka] [u] LT", "[prole] [subote] [u] LT" ];
                return lastWeekDays[this.day()];
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "prije %s",
            s: "nekoliko sekundi",
            ss: translator.translate,
            m: translator.translate,
            mm: translator.translate,
            h: translator.translate,
            hh: translator.translate,
            d: "dan",
            dd: translator.translate,
            M: "mjesec",
            MM: translator.translate,
            y: "godinu",
            yy: translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("mi", {
        months: "Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea".split("_"),
        monthsShort: "Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki".split("_"),
        monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
        weekdays: "Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei".split("_"),
        weekdaysShort: "Ta_Ma_T_We_Ti_Pa_H".split("_"),
        weekdaysMin: "Ta_Ma_T_We_Ti_Pa_H".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY [i] HH:mm",
            LLLL: "dddd, D MMMM YYYY [i] HH:mm"
        },
        calendar: {
            sameDay: "[i teie mahana, i] LT",
            nextDay: "[apopo i] LT",
            nextWeek: "dddd [i] LT",
            lastDay: "[inanahi i] LT",
            lastWeek: "dddd [whakamutunga i] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "i roto i %s",
            past: "%s i mua",
            s: "te hkona ruarua",
            ss: "%d hkona",
            m: "he meneti",
            mm: "%d meneti",
            h: "te haora",
            hh: "%d haora",
            d: "he ra",
            dd: "%d ra",
            M: "he marama",
            MM: "%d marama",
            y: "he tau",
            yy: "%d tau"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("mk", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "e_o_____a".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "D.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY H:mm",
            LLLL: "dddd, D MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "[] dddd [] LT",
            lastDay: "[ ] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                  case 6:
                    return "[] dddd [] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[] dddd [] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: " ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
        ordinal: function(number) {
            var lastDigit = number % 10, last2Digits = number % 100;
            if (number === 0) {
                return number + "-";
            } else if (last2Digits === 0) {
                return number + "-";
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + "-";
            } else if (lastDigit === 1) {
                return number + "-";
            } else if (lastDigit === 2) {
                return number + "-";
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + "-";
            } else {
                return number + "-";
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("ml", {
        months: "___________".split("_"),
        monthsShort: "._._._.___._._._._._.".split("_"),
        monthsParseExact: true,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm -",
            LTS: "A h:mm:ss -",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm -",
            LLLL: "dddd, D MMMM YYYY, A h:mm -"
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        meridiemParse: /|| ||/i,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "" && hour >= 4 || meridiem === " " || meridiem === "") {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "";
            } else if (hour < 12) {
                return "";
            } else if (hour < 17) {
                return " ";
            } else if (hour < 20) {
                return "";
            } else {
                return "";
            }
        }
    });
    function translate$7(number, withoutSuffix, key, isFuture) {
        switch (key) {
          case "s":
            return withoutSuffix ? " " : " ";

          case "ss":
            return number + (withoutSuffix ? " " : " ");

          case "m":
          case "mm":
            return number + (withoutSuffix ? " " : " ");

          case "h":
          case "hh":
            return number + (withoutSuffix ? " " : " ");

          case "d":
          case "dd":
            return number + (withoutSuffix ? " " : " ");

          case "M":
          case "MM":
            return number + (withoutSuffix ? " " : " ");

          case "y":
          case "yy":
            return number + (withoutSuffix ? " " : " ");

          default:
            return number;
        }
    }
    hooks.defineLocale("mn", {
        months: " _ _ _ _ _ _ _ _ _ _  _  ".split("_"),
        monthsShort: "1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 ".split("_"),
        monthsParseExact: true,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "YYYY  MMMM D",
            LLL: "YYYY  MMMM D HH:mm",
            LLLL: "dddd, YYYY  MMMM D HH:mm"
        },
        meridiemParse: /|/i,
        isPM: function(input) {
            return input === "";
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "[] dddd LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: translate$7,
            ss: translate$7,
            m: translate$7,
            mm: translate$7,
            h: translate$7,
            hh: translate$7,
            d: translate$7,
            dd: translate$7,
            M: translate$7,
            MM: translate$7,
            y: translate$7,
            yy: translate$7
        },
        dayOfMonthOrdinalParse: /\d{1,2} /,
        ordinal: function(number, period) {
            switch (period) {
              case "d":
              case "D":
              case "DDD":
                return number + " ";

              default:
                return number;
            }
        }
    });
    var symbolMap$c = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$b = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    function relativeTimeMr(number, withoutSuffix, string, isFuture) {
        var output = "";
        if (withoutSuffix) {
            switch (string) {
              case "s":
                output = " ";
                break;

              case "ss":
                output = "%d ";
                break;

              case "m":
                output = " ";
                break;

              case "mm":
                output = "%d ";
                break;

              case "h":
                output = " ";
                break;

              case "hh":
                output = "%d ";
                break;

              case "d":
                output = " ";
                break;

              case "dd":
                output = "%d ";
                break;

              case "M":
                output = " ";
                break;

              case "MM":
                output = "%d ";
                break;

              case "y":
                output = " ";
                break;

              case "yy":
                output = "%d ";
                break;
            }
        } else {
            switch (string) {
              case "s":
                output = " ";
                break;

              case "ss":
                output = "%d ";
                break;

              case "m":
                output = " ";
                break;

              case "mm":
                output = "%d ";
                break;

              case "h":
                output = " ";
                break;

              case "hh":
                output = "%d ";
                break;

              case "d":
                output = " ";
                break;

              case "dd":
                output = "%d ";
                break;

              case "M":
                output = " ";
                break;

              case "MM":
                output = "%d ";
                break;

              case "y":
                output = " ";
                break;

              case "yy":
                output = "%d ";
                break;
            }
        }
        return output.replace(/%d/i, number);
    }
    hooks.defineLocale("mr", {
        months: "___________".split("_"),
        monthsShort: "._._._._._._._._._._._.".split("_"),
        monthsParseExact: true,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm ",
            LTS: "A h:mm:ss ",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm ",
            LLLL: "dddd, D MMMM YYYY, A h:mm "
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s",
            past: "%s",
            s: relativeTimeMr,
            ss: relativeTimeMr,
            m: relativeTimeMr,
            mm: relativeTimeMr,
            h: relativeTimeMr,
            hh: relativeTimeMr,
            d: relativeTimeMr,
            dd: relativeTimeMr,
            M: relativeTimeMr,
            MM: relativeTimeMr,
            y: relativeTimeMr,
            yy: relativeTimeMr
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$b[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$c[match];
            });
        },
        meridiemParse: /||||/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "" || meridiem === "") {
                return hour;
            } else if (meridiem === "" || meridiem === "" || meridiem === "") {
                return hour >= 12 ? hour : hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour >= 0 && hour < 6) {
                return "";
            } else if (hour < 12) {
                return "";
            } else if (hour < 17) {
                return "";
            } else if (hour < 20) {
                return "";
            } else {
                return "";
            }
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    hooks.defineLocale("ms-my", {
        months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
        monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
        weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
        weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
        weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY [pukul] HH.mm",
            LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "pagi") {
                return hour;
            } else if (meridiem === "tengahari") {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === "petang" || meridiem === "malam") {
                return hour + 12;
            }
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours < 11) {
                return "pagi";
            } else if (hours < 15) {
                return "tengahari";
            } else if (hours < 19) {
                return "petang";
            } else {
                return "malam";
            }
        },
        calendar: {
            sameDay: "[Hari ini pukul] LT",
            nextDay: "[Esok pukul] LT",
            nextWeek: "dddd [pukul] LT",
            lastDay: "[Kelmarin pukul] LT",
            lastWeek: "dddd [lepas pukul] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dalam %s",
            past: "%s yang lepas",
            s: "beberapa saat",
            ss: "%d saat",
            m: "seminit",
            mm: "%d minit",
            h: "sejam",
            hh: "%d jam",
            d: "sehari",
            dd: "%d hari",
            M: "sebulan",
            MM: "%d bulan",
            y: "setahun",
            yy: "%d tahun"
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("ms", {
        months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
        monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
        weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
        weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
        weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY [pukul] HH.mm",
            LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "pagi") {
                return hour;
            } else if (meridiem === "tengahari") {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === "petang" || meridiem === "malam") {
                return hour + 12;
            }
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours < 11) {
                return "pagi";
            } else if (hours < 15) {
                return "tengahari";
            } else if (hours < 19) {
                return "petang";
            } else {
                return "malam";
            }
        },
        calendar: {
            sameDay: "[Hari ini pukul] LT",
            nextDay: "[Esok pukul] LT",
            nextWeek: "dddd [pukul] LT",
            lastDay: "[Kelmarin pukul] LT",
            lastWeek: "dddd [lepas pukul] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dalam %s",
            past: "%s yang lepas",
            s: "beberapa saat",
            ss: "%d saat",
            m: "seminit",
            mm: "%d minit",
            h: "sejam",
            hh: "%d jam",
            d: "sehari",
            dd: "%d hari",
            M: "sebulan",
            MM: "%d bulan",
            y: "setahun",
            yy: "%d tahun"
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("mt", {
        months: "Jannar_Frar_Marzu_April_Mejju_unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diembru".split("_"),
        monthsShort: "Jan_Fra_Mar_Apr_Mej_un_Lul_Aww_Set_Ott_Nov_Di".split("_"),
        weekdays: "Il-add_It-Tnejn_It-Tlieta_L-Erbga_Il-amis_Il-imga_Is-Sibt".split("_"),
        weekdaysShort: "ad_Tne_Tli_Erb_am_im_Sib".split("_"),
        weekdaysMin: "a_Tn_Tl_Er_a_i_Si".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Illum fil-]LT",
            nextDay: "[Gada fil-]LT",
            nextWeek: "dddd [fil-]LT",
            lastDay: "[Il-biera fil-]LT",
            lastWeek: "dddd [li gadda] [fil-]LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "f %s",
            past: "%s ilu",
            s: "ftit sekondi",
            ss: "%d sekondi",
            m: "minuta",
            mm: "%d minuti",
            h: "siega",
            hh: "%d siegat",
            d: "urnata",
            dd: "%d ranet",
            M: "xahar",
            MM: "%d xhur",
            y: "sena",
            yy: "%d sni"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var symbolMap$d = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$c = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("my", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[.] LT []",
            nextDay: "[] LT []",
            nextWeek: "dddd LT []",
            lastDay: "[.] LT []",
            lastWeek: "[] dddd LT []",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s ",
            past: " %s ",
            s: ".",
            ss: "%d ",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$c[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$d[match];
            });
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("nb", {
        months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
        monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
        monthsParseExact: true,
        weekdays: "sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag".split("_"),
        weekdaysShort: "s._ma._ti._on._to._fr._l.".split("_"),
        weekdaysMin: "s_ma_ti_on_to_fr_l".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY [kl.] HH:mm",
            LLLL: "dddd D. MMMM YYYY [kl.] HH:mm"
        },
        calendar: {
            sameDay: "[i dag kl.] LT",
            nextDay: "[i morgen kl.] LT",
            nextWeek: "dddd [kl.] LT",
            lastDay: "[i gr kl.] LT",
            lastWeek: "[forrige] dddd [kl.] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "om %s",
            past: "%s siden",
            s: "noen sekunder",
            ss: "%d sekunder",
            m: "ett minutt",
            mm: "%d minutter",
            h: "en time",
            hh: "%d timer",
            d: "en dag",
            dd: "%d dager",
            w: "en uke",
            ww: "%d uker",
            M: "en mned",
            MM: "%d mneder",
            y: "ett r",
            yy: "%d r"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var symbolMap$e = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$d = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("ne", {
        months: "___________".split("_"),
        monthsShort: "._.__.___._._._._._.".split("_"),
        monthsParseExact: true,
        weekdays: "______".split("_"),
        weekdaysShort: "._._._._._._.".split("_"),
        weekdaysMin: "._._._._._._.".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "A h:mm ",
            LTS: "A h:mm:ss ",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm ",
            LLLL: "dddd, D MMMM YYYY, A h:mm "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$d[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$e[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "") {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour;
            } else if (meridiem === "") {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 3) {
                return "";
            } else if (hour < 12) {
                return "";
            } else if (hour < 16) {
                return "";
            } else if (hour < 20) {
                return "";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "[] dddd[,] LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd[,] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s",
            past: "%s ",
            s: " ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    var monthsShortWithDots$1 = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsShortWithoutDots$1 = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), monthsParse$8 = [ /^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i ], monthsRegex$8 = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
    hooks.defineLocale("nl-be", {
        months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
        monthsShort: function(m, format) {
            if (!m) {
                return monthsShortWithDots$1;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots$1[m.month()];
            } else {
                return monthsShortWithDots$1[m.month()];
            }
        },
        monthsRegex: monthsRegex$8,
        monthsShortRegex: monthsRegex$8,
        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
        monthsParse: monthsParse$8,
        longMonthsParse: monthsParse$8,
        shortMonthsParse: monthsParse$8,
        weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
        weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
        weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[vandaag om] LT",
            nextDay: "[morgen om] LT",
            nextWeek: "dddd [om] LT",
            lastDay: "[gisteren om] LT",
            lastWeek: "[afgelopen] dddd [om] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "over %s",
            past: "%s geleden",
            s: "een paar seconden",
            ss: "%d seconden",
            m: "n minuut",
            mm: "%d minuten",
            h: "n uur",
            hh: "%d uur",
            d: "n dag",
            dd: "%d dagen",
            M: "n maand",
            MM: "%d maanden",
            y: "n jaar",
            yy: "%d jaar"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function(number) {
            return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var monthsShortWithDots$2 = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsShortWithoutDots$2 = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), monthsParse$9 = [ /^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i ], monthsRegex$9 = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
    hooks.defineLocale("nl", {
        months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
        monthsShort: function(m, format) {
            if (!m) {
                return monthsShortWithDots$2;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots$2[m.month()];
            } else {
                return monthsShortWithDots$2[m.month()];
            }
        },
        monthsRegex: monthsRegex$9,
        monthsShortRegex: monthsRegex$9,
        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
        monthsParse: monthsParse$9,
        longMonthsParse: monthsParse$9,
        shortMonthsParse: monthsParse$9,
        weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
        weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
        weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD-MM-YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[vandaag om] LT",
            nextDay: "[morgen om] LT",
            nextWeek: "dddd [om] LT",
            lastDay: "[gisteren om] LT",
            lastWeek: "[afgelopen] dddd [om] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "over %s",
            past: "%s geleden",
            s: "een paar seconden",
            ss: "%d seconden",
            m: "n minuut",
            mm: "%d minuten",
            h: "n uur",
            hh: "%d uur",
            d: "n dag",
            dd: "%d dagen",
            w: "n week",
            ww: "%d weken",
            M: "n maand",
            MM: "%d maanden",
            y: "n jaar",
            yy: "%d jaar"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function(number) {
            return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("nn", {
        months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
        monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
        monthsParseExact: true,
        weekdays: "sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"),
        weekdaysShort: "su._m._ty._on._to._fr._lau.".split("_"),
        weekdaysMin: "su_m_ty_on_to_fr_la".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY [kl.] H:mm",
            LLLL: "dddd D. MMMM YYYY [kl.] HH:mm"
        },
        calendar: {
            sameDay: "[I dag klokka] LT",
            nextDay: "[I morgon klokka] LT",
            nextWeek: "dddd [klokka] LT",
            lastDay: "[I gr klokka] LT",
            lastWeek: "[Fregande] dddd [klokka] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "om %s",
            past: "%s sidan",
            s: "nokre sekund",
            ss: "%d sekund",
            m: "eit minutt",
            mm: "%d minutt",
            h: "ein time",
            hh: "%d timar",
            d: "ein dag",
            dd: "%d dagar",
            w: "ei veke",
            ww: "%d veker",
            M: "ein mnad",
            MM: "%d mnader",
            y: "eit r",
            yy: "%d r"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("oc-lnc", {
        months: {
            standalone: "genir_febrir_mar_abril_mai_junh_julhet_agost_setembre_octbre_novembre_decembre".split("_"),
            format: "de genir_de febrir_de mar_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octbre_de novembre_de decembre".split("_"),
            isFormat: /D[oD]?(\s)+MMMM/
        },
        monthsShort: "gen._febr._mar_abr._mai_junh_julh._ago._set._oct._nov._dec.".split("_"),
        monthsParseExact: true,
        weekdays: "dimenge_diluns_dimars_dimcres_dijus_divendres_dissabte".split("_"),
        weekdaysShort: "dg._dl._dm._dc._dj._dv._ds.".split("_"),
        weekdaysMin: "dg_dl_dm_dc_dj_dv_ds".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM [de] YYYY",
            ll: "D MMM YYYY",
            LLL: "D MMMM [de] YYYY [a] H:mm",
            lll: "D MMM YYYY, H:mm",
            LLLL: "dddd D MMMM [de] YYYY [a] H:mm",
            llll: "ddd D MMM YYYY, H:mm"
        },
        calendar: {
            sameDay: "[ui a] LT",
            nextDay: "[deman a] LT",
            nextWeek: "dddd [a] LT",
            lastDay: "[ir a] LT",
            lastWeek: "dddd [passat a] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "d'aqu %s",
            past: "fa %s",
            s: "unas segondas",
            ss: "%d segondas",
            m: "una minuta",
            mm: "%d minutas",
            h: "una ora",
            hh: "%d oras",
            d: "un jorn",
            dd: "%d jorns",
            M: "un mes",
            MM: "%d meses",
            y: "un an",
            yy: "%d ans"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
        ordinal: function(number, period) {
            var output = number === 1 ? "r" : number === 2 ? "n" : number === 3 ? "r" : number === 4 ? "t" : "";
            if (period === "w" || period === "W") {
                output = "a";
            }
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var symbolMap$f = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$e = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("pa-in", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm ",
            LTS: "A h:mm:ss ",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm ",
            LLLL: "dddd, D MMMM YYYY, A h:mm "
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "[] dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$e[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$f[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "") {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour;
            } else if (meridiem === "") {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "";
            } else if (hour < 10) {
                return "";
            } else if (hour < 17) {
                return "";
            } else if (hour < 20) {
                return "";
            } else {
                return "";
            }
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    var monthsNominative = "stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie".split("_"), monthsSubjective = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia".split("_"), monthsParse$a = [ /^sty/i, /^lut/i, /^mar/i, /^kwi/i, /^maj/i, /^cze/i, /^lip/i, /^sie/i, /^wrz/i, /^pa/i, /^lis/i, /^gru/i ];
    function plural$3(n) {
        return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
    }
    function translate$8(number, withoutSuffix, key) {
        var result = number + " ";
        switch (key) {
          case "ss":
            return result + (plural$3(number) ? "sekundy" : "sekund");

          case "m":
            return withoutSuffix ? "minuta" : "minut";

          case "mm":
            return result + (plural$3(number) ? "minuty" : "minut");

          case "h":
            return withoutSuffix ? "godzina" : "godzin";

          case "hh":
            return result + (plural$3(number) ? "godziny" : "godzin");

          case "ww":
            return result + (plural$3(number) ? "tygodnie" : "tygodni");

          case "MM":
            return result + (plural$3(number) ? "miesice" : "miesicy");

          case "yy":
            return result + (plural$3(number) ? "lata" : "lat");
        }
    }
    hooks.defineLocale("pl", {
        months: function(momentToFormat, format) {
            if (!momentToFormat) {
                return monthsNominative;
            } else if (/D MMMM/.test(format)) {
                return monthsSubjective[momentToFormat.month()];
            } else {
                return monthsNominative[momentToFormat.month()];
            }
        },
        monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru".split("_"),
        monthsParse: monthsParse$a,
        longMonthsParse: monthsParse$a,
        shortMonthsParse: monthsParse$a,
        weekdays: "niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota".split("_"),
        weekdaysShort: "ndz_pon_wt_r_czw_pt_sob".split("_"),
        weekdaysMin: "Nd_Pn_Wt_r_Cz_Pt_So".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Dzi o] LT",
            nextDay: "[Jutro o] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[W niedziel o] LT";

                  case 2:
                    return "[We wtorek o] LT";

                  case 3:
                    return "[W rod o] LT";

                  case 6:
                    return "[W sobot o] LT";

                  default:
                    return "[W] dddd [o] LT";
                }
            },
            lastDay: "[Wczoraj o] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[W zesz niedziel o] LT";

                  case 3:
                    return "[W zesz rod o] LT";

                  case 6:
                    return "[W zesz sobot o] LT";

                  default:
                    return "[W zeszy] dddd [o] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "%s temu",
            s: "kilka sekund",
            ss: translate$8,
            m: translate$8,
            mm: translate$8,
            h: translate$8,
            hh: translate$8,
            d: "1 dzie",
            dd: "%d dni",
            w: "tydzie",
            ww: translate$8,
            M: "miesic",
            MM: translate$8,
            y: "rok",
            yy: translate$8
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("pt-br", {
        months: "janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),
        monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
        weekdays: "domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado".split("_"),
        weekdaysShort: "dom_seg_ter_qua_qui_sex_sb".split("_"),
        weekdaysMin: "do_2_3_4_5_6_s".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D [de] MMMM [de] YYYY",
            LLL: "D [de] MMMM [de] YYYY [s] HH:mm",
            LLLL: "dddd, D [de] MMMM [de] YYYY [s] HH:mm"
        },
        calendar: {
            sameDay: "[Hoje s] LT",
            nextDay: "[Amanh s] LT",
            nextWeek: "dddd [s] LT",
            lastDay: "[Ontem s] LT",
            lastWeek: function() {
                return this.day() === 0 || this.day() === 6 ? "[ltimo] dddd [s] LT" : "[ltima] dddd [s] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "em %s",
            past: "h %s",
            s: "poucos segundos",
            ss: "%d segundos",
            m: "um minuto",
            mm: "%d minutos",
            h: "uma hora",
            hh: "%d horas",
            d: "um dia",
            dd: "%d dias",
            M: "um ms",
            MM: "%d meses",
            y: "um ano",
            yy: "%d anos"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        invalidDate: "Data invlida"
    });
    hooks.defineLocale("pt", {
        months: "janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),
        monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
        weekdays: "Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado".split("_"),
        weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sb".split("_"),
        weekdaysMin: "Do_2_3_4_5_6_S".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D [de] MMMM [de] YYYY",
            LLL: "D [de] MMMM [de] YYYY HH:mm",
            LLLL: "dddd, D [de] MMMM [de] YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Hoje s] LT",
            nextDay: "[Amanh s] LT",
            nextWeek: "dddd [s] LT",
            lastDay: "[Ontem s] LT",
            lastWeek: function() {
                return this.day() === 0 || this.day() === 6 ? "[ltimo] dddd [s] LT" : "[ltima] dddd [s] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "em %s",
            past: "h %s",
            s: "segundos",
            ss: "%d segundos",
            m: "um minuto",
            mm: "%d minutos",
            h: "uma hora",
            hh: "%d horas",
            d: "um dia",
            dd: "%d dias",
            w: "uma semana",
            ww: "%d semanas",
            M: "um ms",
            MM: "%d meses",
            y: "um ano",
            yy: "%d anos"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    });
    function relativeTimeWithPlural$2(number, withoutSuffix, key) {
        var format = {
            ss: "secunde",
            mm: "minute",
            hh: "ore",
            dd: "zile",
            ww: "sptmni",
            MM: "luni",
            yy: "ani"
        }, separator = " ";
        if (number % 100 >= 20 || number >= 100 && number % 100 === 0) {
            separator = " de ";
        }
        return number + separator + format[key];
    }
    hooks.defineLocale("ro", {
        months: "ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"),
        monthsShort: "ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"),
        monthsParseExact: true,
        weekdays: "duminic_luni_mari_miercuri_joi_vineri_smbt".split("_"),
        weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_Sm".split("_"),
        weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_S".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY H:mm",
            LLLL: "dddd, D MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[azi la] LT",
            nextDay: "[mine la] LT",
            nextWeek: "dddd [la] LT",
            lastDay: "[ieri la] LT",
            lastWeek: "[fosta] dddd [la] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "peste %s",
            past: "%s n urm",
            s: "cteva secunde",
            ss: relativeTimeWithPlural$2,
            m: "un minut",
            mm: relativeTimeWithPlural$2,
            h: "o or",
            hh: relativeTimeWithPlural$2,
            d: "o zi",
            dd: relativeTimeWithPlural$2,
            w: "o sptmn",
            ww: relativeTimeWithPlural$2,
            M: "o lun",
            MM: relativeTimeWithPlural$2,
            y: "un an",
            yy: relativeTimeWithPlural$2
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    function plural$4(word, num) {
        var forms = word.split("_");
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }
    function relativeTimeWithPlural$3(number, withoutSuffix, key) {
        var format = {
            ss: withoutSuffix ? "__" : "__",
            mm: withoutSuffix ? "__" : "__",
            hh: "__",
            dd: "__",
            ww: "__",
            MM: "__",
            yy: "__"
        };
        if (key === "m") {
            return withoutSuffix ? "" : "";
        } else {
            return number + " " + plural$4(format[key], +number);
        }
    }
    var monthsParse$b = [ /^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i ];
    hooks.defineLocale("ru", {
        months: {
            format: "___________".split("_"),
            standalone: "___________".split("_")
        },
        monthsShort: {
            format: "._._._.____._._._._.".split("_"),
            standalone: "._.__.____._._._._.".split("_")
        },
        weekdays: {
            standalone: "______".split("_"),
            format: "______".split("_"),
            isFormat: /\[ ?[] ?(?:||)? ?] ?dddd/
        },
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        monthsParse: monthsParse$b,
        longMonthsParse: monthsParse$b,
        shortMonthsParse: monthsParse$b,
        monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
        monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
        monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,
        monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY .",
            LLL: "D MMMM YYYY ., H:mm",
            LLLL: "dddd, D MMMM YYYY ., H:mm"
        },
        calendar: {
            sameDay: "[, ] LT",
            nextDay: "[, ] LT",
            lastDay: "[, ] LT",
            nextWeek: function(now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                      case 0:
                        return "[ ] dddd, [] LT";

                      case 1:
                      case 2:
                      case 4:
                        return "[ ] dddd, [] LT";

                      case 3:
                      case 5:
                      case 6:
                        return "[ ] dddd, [] LT";
                    }
                } else {
                    if (this.day() === 2) {
                        return "[] dddd, [] LT";
                    } else {
                        return "[] dddd, [] LT";
                    }
                }
            },
            lastWeek: function(now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                      case 0:
                        return "[ ] dddd, [] LT";

                      case 1:
                      case 2:
                      case 4:
                        return "[ ] dddd, [] LT";

                      case 3:
                      case 5:
                      case 6:
                        return "[ ] dddd, [] LT";
                    }
                } else {
                    if (this.day() === 2) {
                        return "[] dddd, [] LT";
                    } else {
                        return "[] dddd, [] LT";
                    }
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: "%s ",
            s: " ",
            ss: relativeTimeWithPlural$3,
            m: relativeTimeWithPlural$3,
            mm: relativeTimeWithPlural$3,
            h: "",
            hh: relativeTimeWithPlural$3,
            d: "",
            dd: relativeTimeWithPlural$3,
            w: "",
            ww: relativeTimeWithPlural$3,
            M: "",
            MM: relativeTimeWithPlural$3,
            y: "",
            yy: relativeTimeWithPlural$3
        },
        meridiemParse: /|||/i,
        isPM: function(input) {
            return /^(|)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "";
            } else if (hour < 12) {
                return "";
            } else if (hour < 17) {
                return "";
            } else {
                return "";
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
        ordinal: function(number, period) {
            switch (period) {
              case "M":
              case "d":
              case "DDD":
                return number + "-";

              case "D":
                return number + "-";

              case "w":
              case "W":
                return number + "-";

              default:
                return number;
            }
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var months$9 = [ "", "", "", "", "", "", "", "", "", "", "", "" ], days$1 = [ "", "", "", "", "", "", "" ];
    hooks.defineLocale("sd", {
        months: months$9,
        monthsShort: months$9,
        weekdays: days$1,
        weekdaysShort: days$1,
        weekdaysMin: days$1,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return "" === input;
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "";
            }
            return "";
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd [  ] LT",
            lastDay: "[] LT",
            lastWeek: "[ ] dddd [] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(//g, ",");
        },
        postformat: function(string) {
            return string.replace(/,/g, "");
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("se", {
        months: "oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu".split("_"),
        monthsShort: "oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov".split("_"),
        weekdays: "sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat".split("_"),
        weekdaysShort: "sotn_vuos_ma_gask_duor_bear_lv".split("_"),
        weekdaysMin: "s_v_m_g_d_b_L".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "MMMM D. [b.] YYYY",
            LLL: "MMMM D. [b.] YYYY [ti.] HH:mm",
            LLLL: "dddd, MMMM D. [b.] YYYY [ti.] HH:mm"
        },
        calendar: {
            sameDay: "[otne ti] LT",
            nextDay: "[ihttin ti] LT",
            nextWeek: "dddd [ti] LT",
            lastDay: "[ikte ti] LT",
            lastWeek: "[ovddit] dddd [ti] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s geaes",
            past: "mait %s",
            s: "moadde sekunddat",
            ss: "%d sekunddat",
            m: "okta minuhta",
            mm: "%d minuhtat",
            h: "okta diimmu",
            hh: "%d diimmut",
            d: "okta beaivi",
            dd: "%d beaivvit",
            M: "okta mnnu",
            MM: "%d mnut",
            y: "okta jahki",
            yy: "%d jagit"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("si", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "a h:mm",
            LTS: "a h:mm:ss",
            L: "YYYY/MM/DD",
            LL: "YYYY MMMM D",
            LLL: "YYYY MMMM D, a h:mm",
            LLLL: "YYYY MMMM D [] dddd, a h:mm:ss"
        },
        calendar: {
            sameDay: "[] LT[]",
            nextDay: "[] LT[]",
            nextWeek: "dddd LT[]",
            lastDay: "[] LT[]",
            lastWeek: "[] dddd LT[]",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s",
            past: "%s ",
            s: " ",
            ss: " %d",
            m: "",
            mm: " %d",
            h: "",
            hh: " %d",
            d: "",
            dd: " %d",
            M: "",
            MM: " %d",
            y: "",
            yy: " %d"
        },
        dayOfMonthOrdinalParse: /\d{1,2} /,
        ordinal: function(number) {
            return number + " ";
        },
        meridiemParse: / | |.|../,
        isPM: function(input) {
            return input === ".." || input === " ";
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? ".." : " ";
            } else {
                return isLower ? ".." : " ";
            }
        }
    });
    var months$a = "janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december".split("_"), monthsShort$7 = "jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec".split("_");
    function plural$5(n) {
        return n > 1 && n < 5;
    }
    function translate$9(number, withoutSuffix, key, isFuture) {
        var result = number + " ";
        switch (key) {
          case "s":
            return withoutSuffix || isFuture ? "pr seknd" : "pr sekundami";

          case "ss":
            if (withoutSuffix || isFuture) {
                return result + (plural$5(number) ? "sekundy" : "seknd");
            } else {
                return result + "sekundami";
            }

          case "m":
            return withoutSuffix ? "minta" : isFuture ? "mintu" : "mintou";

          case "mm":
            if (withoutSuffix || isFuture) {
                return result + (plural$5(number) ? "minty" : "mint");
            } else {
                return result + "mintami";
            }

          case "h":
            return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";

          case "hh":
            if (withoutSuffix || isFuture) {
                return result + (plural$5(number) ? "hodiny" : "hodn");
            } else {
                return result + "hodinami";
            }

          case "d":
            return withoutSuffix || isFuture ? "de" : "dom";

          case "dd":
            if (withoutSuffix || isFuture) {
                return result + (plural$5(number) ? "dni" : "dn");
            } else {
                return result + "dami";
            }

          case "M":
            return withoutSuffix || isFuture ? "mesiac" : "mesiacom";

          case "MM":
            if (withoutSuffix || isFuture) {
                return result + (plural$5(number) ? "mesiace" : "mesiacov");
            } else {
                return result + "mesiacmi";
            }

          case "y":
            return withoutSuffix || isFuture ? "rok" : "rokom";

          case "yy":
            if (withoutSuffix || isFuture) {
                return result + (plural$5(number) ? "roky" : "rokov");
            } else {
                return result + "rokmi";
            }
        }
    }
    hooks.defineLocale("sk", {
        months: months$a,
        monthsShort: monthsShort$7,
        weekdays: "nedea_pondelok_utorok_streda_tvrtok_piatok_sobota".split("_"),
        weekdaysShort: "ne_po_ut_st_t_pi_so".split("_"),
        weekdaysMin: "ne_po_ut_st_t_pi_so".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[dnes o] LT",
            nextDay: "[zajtra o] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[v nedeu o] LT";

                  case 1:
                  case 2:
                    return "[v] dddd [o] LT";

                  case 3:
                    return "[v stredu o] LT";

                  case 4:
                    return "[vo tvrtok o] LT";

                  case 5:
                    return "[v piatok o] LT";

                  case 6:
                    return "[v sobotu o] LT";
                }
            },
            lastDay: "[vera o] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[minul nedeu o] LT";

                  case 1:
                  case 2:
                    return "[minul] dddd [o] LT";

                  case 3:
                    return "[minul stredu o] LT";

                  case 4:
                  case 5:
                    return "[minul] dddd [o] LT";

                  case 6:
                    return "[minul sobotu o] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "pred %s",
            s: translate$9,
            ss: translate$9,
            m: translate$9,
            mm: translate$9,
            h: translate$9,
            hh: translate$9,
            d: translate$9,
            dd: translate$9,
            M: translate$9,
            MM: translate$9,
            y: translate$9,
            yy: translate$9
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    function processRelativeTime$7(number, withoutSuffix, key, isFuture) {
        var result = number + " ";
        switch (key) {
          case "s":
            return withoutSuffix || isFuture ? "nekaj sekund" : "nekaj sekundami";

          case "ss":
            if (number === 1) {
                result += withoutSuffix ? "sekundo" : "sekundi";
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? "sekundi" : "sekundah";
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? "sekunde" : "sekundah";
            } else {
                result += "sekund";
            }
            return result;

          case "m":
            return withoutSuffix ? "ena minuta" : "eno minuto";

          case "mm":
            if (number === 1) {
                result += withoutSuffix ? "minuta" : "minuto";
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? "minuti" : "minutama";
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? "minute" : "minutami";
            } else {
                result += withoutSuffix || isFuture ? "minut" : "minutami";
            }
            return result;

          case "h":
            return withoutSuffix ? "ena ura" : "eno uro";

          case "hh":
            if (number === 1) {
                result += withoutSuffix ? "ura" : "uro";
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? "uri" : "urama";
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? "ure" : "urami";
            } else {
                result += withoutSuffix || isFuture ? "ur" : "urami";
            }
            return result;

          case "d":
            return withoutSuffix || isFuture ? "en dan" : "enim dnem";

          case "dd":
            if (number === 1) {
                result += withoutSuffix || isFuture ? "dan" : "dnem";
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? "dni" : "dnevoma";
            } else {
                result += withoutSuffix || isFuture ? "dni" : "dnevi";
            }
            return result;

          case "M":
            return withoutSuffix || isFuture ? "en mesec" : "enim mesecem";

          case "MM":
            if (number === 1) {
                result += withoutSuffix || isFuture ? "mesec" : "mesecem";
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? "meseca" : "mesecema";
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? "mesece" : "meseci";
            } else {
                result += withoutSuffix || isFuture ? "mesecev" : "meseci";
            }
            return result;

          case "y":
            return withoutSuffix || isFuture ? "eno leto" : "enim letom";

          case "yy":
            if (number === 1) {
                result += withoutSuffix || isFuture ? "leto" : "letom";
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? "leti" : "letoma";
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? "leta" : "leti";
            } else {
                result += withoutSuffix || isFuture ? "let" : "leti";
            }
            return result;
        }
    }
    hooks.defineLocale("sl", {
        months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"),
        monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"),
        monthsParseExact: true,
        weekdays: "nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota".split("_"),
        weekdaysShort: "ned._pon._tor._sre._et._pet._sob.".split("_"),
        weekdaysMin: "ne_po_to_sr_e_pe_so".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD. MM. YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[danes ob] LT",
            nextDay: "[jutri ob] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[v] [nedeljo] [ob] LT";

                  case 3:
                    return "[v] [sredo] [ob] LT";

                  case 6:
                    return "[v] [soboto] [ob] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[v] dddd [ob] LT";
                }
            },
            lastDay: "[veraj ob] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[prejnjo] [nedeljo] [ob] LT";

                  case 3:
                    return "[prejnjo] [sredo] [ob] LT";

                  case 6:
                    return "[prejnjo] [soboto] [ob] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[prejnji] dddd [ob] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "ez %s",
            past: "pred %s",
            s: processRelativeTime$7,
            ss: processRelativeTime$7,
            m: processRelativeTime$7,
            mm: processRelativeTime$7,
            h: processRelativeTime$7,
            hh: processRelativeTime$7,
            d: processRelativeTime$7,
            dd: processRelativeTime$7,
            M: processRelativeTime$7,
            MM: processRelativeTime$7,
            y: processRelativeTime$7,
            yy: processRelativeTime$7
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("sq", {
        months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor".split("_"),
        monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj".split("_"),
        weekdays: "E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun".split("_"),
        weekdaysShort: "Die_Hn_Mar_Mr_Enj_Pre_Sht".split("_"),
        weekdaysMin: "D_H_Ma_M_E_P_Sh".split("_"),
        weekdaysParseExact: true,
        meridiemParse: /PD|MD/,
        isPM: function(input) {
            return input.charAt(0) === "M";
        },
        meridiem: function(hours, minutes, isLower) {
            return hours < 12 ? "PD" : "MD";
        },
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Sot n] LT",
            nextDay: "[Nesr n] LT",
            nextWeek: "dddd [n] LT",
            lastDay: "[Dje n] LT",
            lastWeek: "dddd [e kaluar n] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "n %s",
            past: "%s m par",
            s: "disa sekonda",
            ss: "%d sekonda",
            m: "nj minut",
            mm: "%d minuta",
            h: "nj or",
            hh: "%d or",
            d: "nj dit",
            dd: "%d dit",
            M: "nj muaj",
            MM: "%d muaj",
            y: "nj vit",
            yy: "%d vite"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var translator$1 = {
        words: {
            ss: [ "", "", "" ],
            m: [ " ", " " ],
            mm: [ "", "", "" ],
            h: [ " ", " " ],
            hh: [ "", "", "" ],
            dd: [ "", "", "" ],
            MM: [ "", "", "" ],
            yy: [ "", "", "" ]
        },
        correctGrammaticalCase: function(number, wordKey) {
            return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
        },
        translate: function(number, withoutSuffix, key) {
            var wordKey = translator$1.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + " " + translator$1.correctGrammaticalCase(number, wordKey);
            }
        }
    };
    hooks.defineLocale("sr-cyrl", {
        months: "___________".split("_"),
        monthsShort: "._._._.____._._._._.".split("_"),
        monthsParseExact: true,
        weekdays: "______".split("_"),
        weekdaysShort: "._._._._._._.".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "D. M. YYYY.",
            LL: "D. MMMM YYYY.",
            LLL: "D. MMMM YYYY. H:mm",
            LLLL: "dddd, D. MMMM YYYY. H:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[] [] [] LT";

                  case 3:
                    return "[] [] [] LT";

                  case 6:
                    return "[] [] [] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[] dddd [] LT";
                }
            },
            lastDay: "[ ] LT",
            lastWeek: function() {
                var lastWeekDays = [ "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT" ];
                return lastWeekDays[this.day()];
            },
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: " ",
            ss: translator$1.translate,
            m: translator$1.translate,
            mm: translator$1.translate,
            h: translator$1.translate,
            hh: translator$1.translate,
            d: "",
            dd: translator$1.translate,
            M: "",
            MM: translator$1.translate,
            y: "",
            yy: translator$1.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var translator$2 = {
        words: {
            ss: [ "sekunda", "sekunde", "sekundi" ],
            m: [ "jedan minut", "jedne minute" ],
            mm: [ "minut", "minute", "minuta" ],
            h: [ "jedan sat", "jednog sata" ],
            hh: [ "sat", "sata", "sati" ],
            dd: [ "dan", "dana", "dana" ],
            MM: [ "mesec", "meseca", "meseci" ],
            yy: [ "godina", "godine", "godina" ]
        },
        correctGrammaticalCase: function(number, wordKey) {
            return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
        },
        translate: function(number, withoutSuffix, key) {
            var wordKey = translator$2.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + " " + translator$2.correctGrammaticalCase(number, wordKey);
            }
        }
    };
    hooks.defineLocale("sr", {
        months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),
        monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
        monthsParseExact: true,
        weekdays: "nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota".split("_"),
        weekdaysShort: "ned._pon._uto._sre._et._pet._sub.".split("_"),
        weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "D. M. YYYY.",
            LL: "D. MMMM YYYY.",
            LLL: "D. MMMM YYYY. H:mm",
            LLLL: "dddd, D. MMMM YYYY. H:mm"
        },
        calendar: {
            sameDay: "[danas u] LT",
            nextDay: "[sutra u] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[u] [nedelju] [u] LT";

                  case 3:
                    return "[u] [sredu] [u] LT";

                  case 6:
                    return "[u] [subotu] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[u] dddd [u] LT";
                }
            },
            lastDay: "[jue u] LT",
            lastWeek: function() {
                var lastWeekDays = [ "[prole] [nedelje] [u] LT", "[prolog] [ponedeljka] [u] LT", "[prolog] [utorka] [u] LT", "[prole] [srede] [u] LT", "[prolog] [etvrtka] [u] LT", "[prolog] [petka] [u] LT", "[prole] [subote] [u] LT" ];
                return lastWeekDays[this.day()];
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "pre %s",
            s: "nekoliko sekundi",
            ss: translator$2.translate,
            m: translator$2.translate,
            mm: translator$2.translate,
            h: translator$2.translate,
            hh: translator$2.translate,
            d: "dan",
            dd: translator$2.translate,
            M: "mesec",
            MM: translator$2.translate,
            y: "godinu",
            yy: translator$2.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("ss", {
        months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split("_"),
        monthsShort: "Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo".split("_"),
        weekdays: "Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo".split("_"),
        weekdaysShort: "Lis_Umb_Lsb_Les_Lsi_Lsh_Umg".split("_"),
        weekdaysMin: "Li_Us_Lb_Lt_Ls_Lh_Ug".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY h:mm A",
            LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
            sameDay: "[Namuhla nga] LT",
            nextDay: "[Kusasa nga] LT",
            nextWeek: "dddd [nga] LT",
            lastDay: "[Itolo nga] LT",
            lastWeek: "dddd [leliphelile] [nga] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "nga %s",
            past: "wenteka nga %s",
            s: "emizuzwana lomcane",
            ss: "%d mzuzwana",
            m: "umzuzu",
            mm: "%d emizuzu",
            h: "lihora",
            hh: "%d emahora",
            d: "lilanga",
            dd: "%d emalanga",
            M: "inyanga",
            MM: "%d tinyanga",
            y: "umnyaka",
            yy: "%d iminyaka"
        },
        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
        meridiem: function(hours, minutes, isLower) {
            if (hours < 11) {
                return "ekuseni";
            } else if (hours < 15) {
                return "emini";
            } else if (hours < 19) {
                return "entsambama";
            } else {
                return "ebusuku";
            }
        },
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "ekuseni") {
                return hour;
            } else if (meridiem === "emini") {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === "entsambama" || meridiem === "ebusuku") {
                if (hour === 0) {
                    return 0;
                }
                return hour + 12;
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("sv", {
        months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"),
        monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
        weekdays: "sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag".split("_"),
        weekdaysShort: "sn_mn_tis_ons_tor_fre_lr".split("_"),
        weekdaysMin: "s_m_ti_on_to_fr_l".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY [kl.] HH:mm",
            LLLL: "dddd D MMMM YYYY [kl.] HH:mm",
            lll: "D MMM YYYY HH:mm",
            llll: "ddd D MMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Idag] LT",
            nextDay: "[Imorgon] LT",
            lastDay: "[Igr] LT",
            nextWeek: "[P] dddd LT",
            lastWeek: "[I] dddd[s] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "om %s",
            past: "fr %s sedan",
            s: "ngra sekunder",
            ss: "%d sekunder",
            m: "en minut",
            mm: "%d minuter",
            h: "en timme",
            hh: "%d timmar",
            d: "en dag",
            dd: "%d dagar",
            M: "en mnad",
            MM: "%d mnader",
            y: "ett r",
            yy: "%d r"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/,
        ordinal: function(number) {
            var b = number % 10, output = ~~(number % 100 / 10) === 1 ? ":e" : b === 1 ? ":a" : b === 2 ? ":a" : b === 3 ? ":e" : ":e";
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("sw", {
        months: "Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba".split("_"),
        monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des".split("_"),
        weekdays: "Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi".split("_"),
        weekdaysShort: "Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos".split("_"),
        weekdaysMin: "J2_J3_J4_J5_Al_Ij_J1".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "hh:mm A",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[leo saa] LT",
            nextDay: "[kesho saa] LT",
            nextWeek: "[wiki ijayo] dddd [saat] LT",
            lastDay: "[jana] LT",
            lastWeek: "[wiki iliyopita] dddd [saat] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s baadaye",
            past: "tokea %s",
            s: "hivi punde",
            ss: "sekunde %d",
            m: "dakika moja",
            mm: "dakika %d",
            h: "saa limoja",
            hh: "masaa %d",
            d: "siku moja",
            dd: "siku %d",
            M: "mwezi mmoja",
            MM: "miezi %d",
            y: "mwaka mmoja",
            yy: "miaka %d"
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var symbolMap$g = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$f = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("ta", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, HH:mm",
            LLLL: "dddd, D MMMM YYYY, HH:mm"
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[ ] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: "  ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: "  ",
            hh: "%d  ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function(number) {
            return number + "";
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$f[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$g[match];
            });
        },
        meridiemParse: /|||||/,
        meridiem: function(hour, minute, isLower) {
            if (hour < 2) {
                return " ";
            } else if (hour < 6) {
                return " ";
            } else if (hour < 10) {
                return " ";
            } else if (hour < 14) {
                return " ";
            } else if (hour < 18) {
                return " ";
            } else if (hour < 22) {
                return " ";
            } else {
                return " ";
            }
        },
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "") {
                return hour < 2 ? hour : hour + 12;
            } else if (meridiem === "" || meridiem === "") {
                return hour;
            } else if (meridiem === "") {
                return hour >= 10 ? hour : hour + 12;
            } else {
                return hour + 12;
            }
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    hooks.defineLocale("te", {
        months: "___________".split("_"),
        monthsShort: "._.__.____._._._._.".split("_"),
        monthsParseExact: true,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm",
            LTS: "A h:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm",
            LLLL: "dddd, D MMMM YYYY, A h:mm"
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        meridiemParse: /|||/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "") {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour;
            } else if (meridiem === "") {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "";
            } else if (hour < 10) {
                return "";
            } else if (hour < 17) {
                return "";
            } else if (hour < 20) {
                return "";
            } else {
                return "";
            }
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    hooks.defineLocale("tet", {
        months: "Janeiru_Fevereiru_Marsu_Abril_Maiu_Juu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru".split("_"),
        monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),
        weekdays: "Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu".split("_"),
        weekdaysShort: "Dom_Seg_Ters_Kua_Kint_Sest_Sab".split("_"),
        weekdaysMin: "Do_Seg_Te_Ku_Ki_Ses_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Ohin iha] LT",
            nextDay: "[Aban iha] LT",
            nextWeek: "dddd [iha] LT",
            lastDay: "[Horiseik iha] LT",
            lastWeek: "dddd [semana kotuk] [iha] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "iha %s",
            past: "%s liuba",
            s: "segundu balun",
            ss: "segundu %d",
            m: "minutu ida",
            mm: "minutu %d",
            h: "oras ida",
            hh: "oras %d",
            d: "loron ida",
            dd: "loron %d",
            M: "fulan ida",
            MM: "fulan %d",
            y: "tinan ida",
            yy: "tinan %d"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var suffixes$3 = {
        0: "-",
        1: "-",
        2: "-",
        3: "-",
        4: "-",
        5: "-",
        6: "-",
        7: "-",
        8: "-",
        9: "-",
        10: "-",
        12: "-",
        13: "-",
        20: "-",
        30: "-",
        40: "-",
        50: "-",
        60: "-",
        70: "-",
        80: "-",
        90: "-",
        100: "-"
    };
    hooks.defineLocale("tg", {
        months: {
            format: "___________".split("_"),
            standalone: "___________".split("_")
        },
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            lastDay: "[ ] LT",
            nextWeek: "dddd[] [  ] LT",
            lastWeek: "dddd[] [  ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: "%s ",
            s: " ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        meridiemParse: /|||/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "") {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour;
            } else if (meridiem === "") {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === "") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "";
            } else if (hour < 11) {
                return "";
            } else if (hour < 16) {
                return "";
            } else if (hour < 19) {
                return "";
            } else {
                return "";
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
        ordinal: function(number) {
            var a = number % 10, b = number >= 100 ? 100 : null;
            return number + (suffixes$3[number] || suffixes$3[a] || suffixes$3[b]);
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("th", {
        months: "___________".split("_"),
        monthsShort: ".._.._.._.._.._.._.._.._.._.._.._..".split("_"),
        monthsParseExact: true,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "._._._._._._.".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY  H:mm",
            LLLL: "dddd D MMMM YYYY  H:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return input === "";
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd[ ] LT",
            lastDay: "[ ] LT",
            lastWeek: "[]dddd[ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: "%s",
            s: "",
            ss: "%d ",
            m: "1 ",
            mm: "%d ",
            h: "1 ",
            hh: "%d ",
            d: "1 ",
            dd: "%d ",
            w: "1 ",
            ww: "%d ",
            M: "1 ",
            MM: "%d ",
            y: "1 ",
            yy: "%d "
        }
    });
    var suffixes$4 = {
        1: "'inji",
        5: "'inji",
        8: "'inji",
        70: "'inji",
        80: "'inji",
        2: "'nji",
        7: "'nji",
        20: "'nji",
        50: "'nji",
        3: "'nji",
        4: "'nji",
        100: "'nji",
        6: "'njy",
        9: "'unjy",
        10: "'unjy",
        30: "'unjy",
        60: "'ynjy",
        90: "'ynjy"
    };
    hooks.defineLocale("tk", {
        months: "anwar_Fewral_Mart_Aprel_Ma_Iun_Iul_Awgust_Sentabr_Oktabr_Noabr_Dekabr".split("_"),
        monthsShort: "an_Few_Mar_Apr_Ma_In_Il_Awg_Sen_Okt_No_Dek".split("_"),
        weekdays: "ekenbe_Duenbe_Sienbe_arenbe_Penenbe_Anna_enbe".split("_"),
        weekdaysShort: "ek_Du_Si_ar_Pen_Ann_en".split("_"),
        weekdaysMin: "k_D_S_r_Pn_An_n".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[bugn sagat] LT",
            nextDay: "[ertir sagat] LT",
            nextWeek: "[indiki] dddd [sagat] LT",
            lastDay: "[dn] LT",
            lastWeek: "[geen] dddd [sagat] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s so",
            past: "%s ",
            s: "birne sekunt",
            m: "bir minut",
            mm: "%d minut",
            h: "bir sagat",
            hh: "%d sagat",
            d: "bir gn",
            dd: "%d gn",
            M: "bir a",
            MM: "%d a",
            y: "bir yl",
            yy: "%d yl"
        },
        ordinal: function(number, period) {
            switch (period) {
              case "d":
              case "D":
              case "Do":
              case "DD":
                return number;

              default:
                if (number === 0) {
                    return number + "'unjy";
                }
                var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
                return number + (suffixes$4[a] || suffixes$4[b] || suffixes$4[c]);
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("tl-ph", {
        months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),
        monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
        weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),
        weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
        weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "MM/D/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY HH:mm",
            LLLL: "dddd, MMMM DD, YYYY HH:mm"
        },
        calendar: {
            sameDay: "LT [ngayong araw]",
            nextDay: "[Bukas ng] LT",
            nextWeek: "LT [sa susunod na] dddd",
            lastDay: "LT [kahapon]",
            lastWeek: "LT [noong nakaraang] dddd",
            sameElse: "L"
        },
        relativeTime: {
            future: "sa loob ng %s",
            past: "%s ang nakalipas",
            s: "ilang segundo",
            ss: "%d segundo",
            m: "isang minuto",
            mm: "%d minuto",
            h: "isang oras",
            hh: "%d oras",
            d: "isang araw",
            dd: "%d araw",
            M: "isang buwan",
            MM: "%d buwan",
            y: "isang taon",
            yy: "%d taon"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function(number) {
            return number;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var numbersNouns = "pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut".split("_");
    function translateFuture(output) {
        var time = output;
        time = output.indexOf("jaj") !== -1 ? time.slice(0, -3) + "leS" : output.indexOf("jar") !== -1 ? time.slice(0, -3) + "waQ" : output.indexOf("DIS") !== -1 ? time.slice(0, -3) + "nem" : time + " pIq";
        return time;
    }
    function translatePast(output) {
        var time = output;
        time = output.indexOf("jaj") !== -1 ? time.slice(0, -3) + "Hu" : output.indexOf("jar") !== -1 ? time.slice(0, -3) + "wen" : output.indexOf("DIS") !== -1 ? time.slice(0, -3) + "ben" : time + " ret";
        return time;
    }
    function translate$a(number, withoutSuffix, string, isFuture) {
        var numberNoun = numberAsNoun(number);
        switch (string) {
          case "ss":
            return numberNoun + " lup";

          case "mm":
            return numberNoun + " tup";

          case "hh":
            return numberNoun + " rep";

          case "dd":
            return numberNoun + " jaj";

          case "MM":
            return numberNoun + " jar";

          case "yy":
            return numberNoun + " DIS";
        }
    }
    function numberAsNoun(number) {
        var hundred = Math.floor(number % 1e3 / 100), ten = Math.floor(number % 100 / 10), one = number % 10, word = "";
        if (hundred > 0) {
            word += numbersNouns[hundred] + "vatlh";
        }
        if (ten > 0) {
            word += (word !== "" ? " " : "") + numbersNouns[ten] + "maH";
        }
        if (one > 0) {
            word += (word !== "" ? " " : "") + numbersNouns[one];
        }
        return word === "" ? "pagh" : word;
    }
    hooks.defineLocale("tlh", {
        months: "tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha".split("_"),
        monthsShort: "jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha".split("_"),
        monthsParseExact: true,
        weekdays: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
        weekdaysShort: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
        weekdaysMin: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[DaHjaj] LT",
            nextDay: "[waleS] LT",
            nextWeek: "LLL",
            lastDay: "[waHu] LT",
            lastWeek: "LLL",
            sameElse: "L"
        },
        relativeTime: {
            future: translateFuture,
            past: translatePast,
            s: "puS lup",
            ss: translate$a,
            m: "wa tup",
            mm: translate$a,
            h: "wa rep",
            hh: translate$a,
            d: "wa jaj",
            dd: translate$a,
            M: "wa jar",
            MM: translate$a,
            y: "wa DIS",
            yy: translate$a
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var suffixes$5 = {
        1: "'inci",
        5: "'inci",
        8: "'inci",
        70: "'inci",
        80: "'inci",
        2: "'nci",
        7: "'nci",
        20: "'nci",
        50: "'nci",
        3: "'nc",
        4: "'nc",
        100: "'nc",
        6: "'nc",
        9: "'uncu",
        10: "'uncu",
        30: "'uncu",
        60: "'nc",
        90: "'nc"
    };
    hooks.defineLocale("tr", {
        months: "Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk".split("_"),
        monthsShort: "Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara".split("_"),
        weekdays: "Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi".split("_"),
        weekdaysShort: "Paz_Pts_Sal_ar_Per_Cum_Cts".split("_"),
        weekdaysMin: "Pz_Pt_Sa_a_Pe_Cu_Ct".split("_"),
        meridiem: function(hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? "" : "";
            } else {
                return isLower ? "s" : "S";
            }
        },
        meridiemParse: /||s|S/,
        isPM: function(input) {
            return input === "s" || input === "S";
        },
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[bugn saat] LT",
            nextDay: "[yarn saat] LT",
            nextWeek: "[gelecek] dddd [saat] LT",
            lastDay: "[dn] LT",
            lastWeek: "[geen] dddd [saat] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s sonra",
            past: "%s nce",
            s: "birka saniye",
            ss: "%d saniye",
            m: "bir dakika",
            mm: "%d dakika",
            h: "bir saat",
            hh: "%d saat",
            d: "bir gn",
            dd: "%d gn",
            w: "bir hafta",
            ww: "%d hafta",
            M: "bir ay",
            MM: "%d ay",
            y: "bir yl",
            yy: "%d yl"
        },
        ordinal: function(number, period) {
            switch (period) {
              case "d":
              case "D":
              case "Do":
              case "DD":
                return number;

              default:
                if (number === 0) {
                    return number + "'nc";
                }
                var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
                return number + (suffixes$5[a] || suffixes$5[b] || suffixes$5[c]);
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("tzl", {
        months: "Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar".split("_"),
        monthsShort: "Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec".split("_"),
        weekdays: "Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi".split("_"),
        weekdaysShort: "Sl_Ln_Mai_Mr_Xh_Vi_St".split("_"),
        weekdaysMin: "S_L_Ma_M_Xh_Vi_S".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM [dallas] YYYY",
            LLL: "D. MMMM [dallas] YYYY HH.mm",
            LLLL: "dddd, [li] D. MMMM [dallas] YYYY HH.mm"
        },
        meridiemParse: /d\'o|d\'a/i,
        isPM: function(input) {
            return "d'o" === input.toLowerCase();
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? "d'o" : "D'O";
            } else {
                return isLower ? "d'a" : "D'A";
            }
        },
        calendar: {
            sameDay: "[oxhi ] LT",
            nextDay: "[dem ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ieiri ] LT",
            lastWeek: "[sr el] dddd [lasteu ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "osprei %s",
            past: "ja%s",
            s: processRelativeTime$8,
            ss: processRelativeTime$8,
            m: processRelativeTime$8,
            mm: processRelativeTime$8,
            h: processRelativeTime$8,
            hh: processRelativeTime$8,
            d: processRelativeTime$8,
            dd: processRelativeTime$8,
            M: processRelativeTime$8,
            MM: processRelativeTime$8,
            y: processRelativeTime$8,
            yy: processRelativeTime$8
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    function processRelativeTime$8(number, withoutSuffix, key, isFuture) {
        var format = {
            s: [ "viensas secunds", "'iensas secunds" ],
            ss: [ number + " secunds", "" + number + " secunds" ],
            m: [ "'n mut", "'iens mut" ],
            mm: [ number + " muts", "" + number + " muts" ],
            h: [ "'n ora", "'iensa ora" ],
            hh: [ number + " oras", "" + number + " oras" ],
            d: [ "'n ziua", "'iensa ziua" ],
            dd: [ number + " ziuas", "" + number + " ziuas" ],
            M: [ "'n mes", "'iens mes" ],
            MM: [ number + " mesen", "" + number + " mesen" ],
            y: [ "'n ar", "'iens ar" ],
            yy: [ number + " ars", "" + number + " ars" ]
        };
        return isFuture ? format[key][0] : withoutSuffix ? format[key][0] : format[key][1];
    }
    hooks.defineLocale("tzm-latn", {
        months: "innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir".split("_"),
        monthsShort: "innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir".split("_"),
        weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"),
        weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"),
        weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[asdkh g] LT",
            nextDay: "[aska g] LT",
            nextWeek: "dddd [g] LT",
            lastDay: "[assant g] LT",
            lastWeek: "dddd [g] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dadkh s yan %s",
            past: "yan %s",
            s: "imik",
            ss: "%d imik",
            m: "minu",
            mm: "%d minu",
            h: "saa",
            hh: "%d tassain",
            d: "ass",
            dd: "%d ossan",
            M: "ayowr",
            MM: "%d iyyirn",
            y: "asgas",
            yy: "%d isgasn"
        },
        week: {
            dow: 6,
            doy: 12
        }
    });
    hooks.defineLocale("tzm", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ ] LT",
            lastWeek: "dddd [] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "   %s",
            past: " %s",
            s: "",
            ss: "%d ",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d o",
            M: "o",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        week: {
            dow: 6,
            doy: 12
        }
    });
    hooks.defineLocale("ug-cn", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "YYYY-M-D-",
            LLL: "YYYY-M-D- HH:mm",
            LLLL: "dddd YYYY-M-D- HH:mm"
        },
        meridiemParse: / || || |/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === " " || meridiem === "" || meridiem === " ") {
                return hour;
            } else if (meridiem === " " || meridiem === "") {
                return hour + 12;
            } else {
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return " ";
            } else if (hm < 900) {
                return "";
            } else if (hm < 1130) {
                return " ";
            } else if (hm < 1230) {
                return "";
            } else if (hm < 1800) {
                return " ";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "[] dddd [] LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd [] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}(-|-|-)/,
        ordinal: function(number, period) {
            switch (period) {
              case "d":
              case "D":
              case "DDD":
                return number + "-";

              case "w":
              case "W":
                return number + "-";

              default:
                return number;
            }
        },
        preparse: function(string) {
            return string.replace(//g, ",");
        },
        postformat: function(string) {
            return string.replace(/,/g, "");
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    function plural$6(word, num) {
        var forms = word.split("_");
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }
    function relativeTimeWithPlural$4(number, withoutSuffix, key) {
        var format = {
            ss: withoutSuffix ? "__" : "__",
            mm: withoutSuffix ? "__" : "__",
            hh: withoutSuffix ? "__" : "__",
            dd: "__",
            MM: "__",
            yy: "__"
        };
        if (key === "m") {
            return withoutSuffix ? "" : "";
        } else if (key === "h") {
            return withoutSuffix ? "" : "";
        } else {
            return number + " " + plural$6(format[key], +number);
        }
    }
    function weekdaysCaseReplace(m, format) {
        var weekdays = {
            nominative: "______".split("_"),
            accusative: "______".split("_"),
            genitive: "______".split("_")
        }, nounCase;
        if (m === true) {
            return weekdays["nominative"].slice(1, 7).concat(weekdays["nominative"].slice(0, 1));
        }
        if (!m) {
            return weekdays["nominative"];
        }
        nounCase = /(\[[]\]) ?dddd/.test(format) ? "accusative" : /\[?(?:|)? ?\] ?dddd/.test(format) ? "genitive" : "nominative";
        return weekdays[nounCase][m.day()];
    }
    function processHoursFunction(str) {
        return function() {
            return str + "" + (this.hours() === 11 ? "" : "") + "] LT";
        };
    }
    hooks.defineLocale("uk", {
        months: {
            format: "___________".split("_"),
            standalone: "___________".split("_")
        },
        monthsShort: "___________".split("_"),
        weekdays: weekdaysCaseReplace,
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY .",
            LLL: "D MMMM YYYY ., HH:mm",
            LLLL: "dddd, D MMMM YYYY ., HH:mm"
        },
        calendar: {
            sameDay: processHoursFunction("[ "),
            nextDay: processHoursFunction("[ "),
            lastDay: processHoursFunction("[ "),
            nextWeek: processHoursFunction("[] dddd ["),
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                  case 5:
                  case 6:
                    return processHoursFunction("[] dddd [").call(this);

                  case 1:
                  case 2:
                  case 4:
                    return processHoursFunction("[] dddd [").call(this);
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: "%s ",
            s: " ",
            ss: relativeTimeWithPlural$4,
            m: relativeTimeWithPlural$4,
            mm: relativeTimeWithPlural$4,
            h: "",
            hh: relativeTimeWithPlural$4,
            d: "",
            dd: relativeTimeWithPlural$4,
            M: "",
            MM: relativeTimeWithPlural$4,
            y: "",
            yy: relativeTimeWithPlural$4
        },
        meridiemParse: /|||/,
        isPM: function(input) {
            return /^(|)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "";
            } else if (hour < 12) {
                return "";
            } else if (hour < 17) {
                return "";
            } else {
                return "";
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
        ordinal: function(number, period) {
            switch (period) {
              case "M":
              case "d":
              case "DDD":
              case "w":
              case "W":
                return number + "-";

              case "D":
                return number + "-";

              default:
                return number;
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var months$b = [ "", "", "", "", "", "", "", "", "", "", "", "" ], days$2 = [ "", "", "", "", "", "", "" ];
    hooks.defineLocale("ur", {
        months: months$b,
        monthsShort: months$b,
        weekdays: days$2,
        weekdaysShort: days$2,
        weekdaysMin: days$2,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return "" === input;
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "";
            }
            return "";
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[  ] LT",
            lastWeek: "[] dddd [] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(//g, ",");
        },
        postformat: function(string) {
            return string.replace(/,/g, "");
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("uz-latn", {
        months: "Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr".split("_"),
        monthsShort: "Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek".split("_"),
        weekdays: "Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba".split("_"),
        weekdaysShort: "Yak_Dush_Sesh_Chor_Pay_Jum_Shan".split("_"),
        weekdaysMin: "Ya_Du_Se_Cho_Pa_Ju_Sha".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "D MMMM YYYY, dddd HH:mm"
        },
        calendar: {
            sameDay: "[Bugun soat] LT [da]",
            nextDay: "[Ertaga] LT [da]",
            nextWeek: "dddd [kuni soat] LT [da]",
            lastDay: "[Kecha soat] LT [da]",
            lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
            sameElse: "L"
        },
        relativeTime: {
            future: "Yaqin %s ichida",
            past: "Bir necha %s oldin",
            s: "soniya",
            ss: "%d soniya",
            m: "bir daqiqa",
            mm: "%d daqiqa",
            h: "bir soat",
            hh: "%d soat",
            d: "bir kun",
            dd: "%d kun",
            M: "bir oy",
            MM: "%d oy",
            y: "bir yil",
            yy: "%d yil"
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("uz", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "D MMMM YYYY, dddd HH:mm"
        },
        calendar: {
            sameDay: "[ ] LT []",
            nextDay: "[] LT []",
            nextWeek: "dddd [ ] LT []",
            lastDay: "[ ] LT []",
            lastWeek: "[] dddd [ ] LT []",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s ",
            past: "  %s ",
            s: "",
            ss: "%d ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    hooks.defineLocale("vi", {
        months: "thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12".split("_"),
        monthsShort: "Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12".split("_"),
        monthsParseExact: true,
        weekdays: "ch nht_th hai_th ba_th t_th nm_th su_th by".split("_"),
        weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"),
        weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"),
        weekdaysParseExact: true,
        meridiemParse: /sa|ch/i,
        isPM: function(input) {
            return /^ch$/i.test(input);
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? "sa" : "SA";
            } else {
                return isLower ? "ch" : "CH";
            }
        },
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM [nm] YYYY",
            LLL: "D MMMM [nm] YYYY HH:mm",
            LLLL: "dddd, D MMMM [nm] YYYY HH:mm",
            l: "DD/M/YYYY",
            ll: "D MMM YYYY",
            lll: "D MMM YYYY HH:mm",
            llll: "ddd, D MMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Hm nay lc] LT",
            nextDay: "[Ngy mai lc] LT",
            nextWeek: "dddd [tun ti lc] LT",
            lastDay: "[Hm qua lc] LT",
            lastWeek: "dddd [tun trc lc] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ti",
            past: "%s trc",
            s: "vi giy",
            ss: "%d giy",
            m: "mt pht",
            mm: "%d pht",
            h: "mt gi",
            hh: "%d gi",
            d: "mt ngy",
            dd: "%d ngy",
            w: "mt tun",
            ww: "%d tun",
            M: "mt thng",
            MM: "%d thng",
            y: "mt nm",
            yy: "%d nm"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function(number) {
            return number;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("x-pseudo", {
        months: "J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr".split("_"),
        monthsShort: "J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc".split("_"),
        monthsParseExact: true,
        weekdays: "S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d".split("_"),
        weekdaysShort: "S~_~M_~T_~Wd_~Th_~Fr_~St".split("_"),
        weekdaysMin: "S~_M~_T_~W_T~h_Fr~_S".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: "HH:mm",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[T~d~ t] LT",
            nextDay: "[T~m~rr~w t] LT",
            nextWeek: "dddd [t] LT",
            lastDay: "[~st~rd~ t] LT",
            lastWeek: "[L~st] dddd [t] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "~ %s",
            past: "%s ~g",
            s: " ~fw ~sc~ds",
            ss: "%d s~c~ds",
            m: " ~m~t",
            mm: "%d m~~ts",
            h: "~ h~r",
            hh: "%d h~rs",
            d: " ~d",
            dd: "%d d~s",
            M: " ~m~th",
            MM: "%d m~t~hs",
            y: " ~r",
            yy: "%d ~rs"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("yo", {
        months: "Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p".split("_"),
        monthsShort: "Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p".split("_"),
        weekdays: "Aiku_Aje_Isgun_jru_jb_ti_Abamta".split("_"),
        weekdaysShort: "Aik_Aje_Is_jr_jb_ti_Aba".split("_"),
        weekdaysMin: "Ai_Aj_Is_r_b_t_Ab".split("_"),
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY h:mm A",
            LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
            sameDay: "[Oni ni] LT",
            nextDay: "[la ni] LT",
            nextWeek: "dddd [s ton'b] [ni] LT",
            lastDay: "[Ana ni] LT",
            lastWeek: "dddd [s tol] [ni] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "ni %s",
            past: "%s kja",
            s: "isju aaya die",
            ss: "aaya %d",
            m: "isju kan",
            mm: "isju %d",
            h: "wakati kan",
            hh: "wakati %d",
            d: "j kan",
            dd: "j %d",
            M: "osu kan",
            MM: "osu %d",
            y: "dun kan",
            yy: "dun %d"
        },
        dayOfMonthOrdinalParse: /j\s\d{1,2}/,
        ordinal: "j %d",
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("zh-cn", {
        months: "___________".split("_"),
        monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY/MM/DD",
            LL: "YYYYMD",
            LLL: "YYYYMDAhmm",
            LLLL: "YYYYMDddddAhmm",
            l: "YYYY/M/D",
            ll: "YYYYMD",
            lll: "YYYYMD HH:mm",
            llll: "YYYYMDdddd HH:mm"
        },
        meridiemParse: /|||||/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "" || meridiem === "" || meridiem === "") {
                return hour;
            } else if (meridiem === "" || meridiem === "") {
                return hour + 12;
            } else {
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return "";
            } else if (hm < 900) {
                return "";
            } else if (hm < 1130) {
                return "";
            } else if (hm < 1230) {
                return "";
            } else if (hm < 1800) {
                return "";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[]LT",
            nextDay: "[]LT",
            nextWeek: function(now) {
                if (now.week() !== this.week()) {
                    return "[]dddLT";
                } else {
                    return "[]dddLT";
                }
            },
            lastDay: "[]LT",
            lastWeek: function(now) {
                if (this.week() !== now.week()) {
                    return "[]dddLT";
                } else {
                    return "[]dddLT";
                }
            },
            sameElse: "L"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal: function(number, period) {
            switch (period) {
              case "d":
              case "D":
              case "DDD":
                return number + "";

              case "M":
                return number + "";

              case "w":
              case "W":
                return number + "";

              default:
                return number;
            }
        },
        relativeTime: {
            future: "%s",
            past: "%s",
            s: "",
            ss: "%d ",
            m: "1 ",
            mm: "%d ",
            h: "1 ",
            hh: "%d ",
            d: "1 ",
            dd: "%d ",
            w: "1 ",
            ww: "%d ",
            M: "1 ",
            MM: "%d ",
            y: "1 ",
            yy: "%d "
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    hooks.defineLocale("zh-hk", {
        months: "___________".split("_"),
        monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY/MM/DD",
            LL: "YYYYMD",
            LLL: "YYYYMD HH:mm",
            LLLL: "YYYYMDdddd HH:mm",
            l: "YYYY/M/D",
            ll: "YYYYMD",
            lll: "YYYYMD HH:mm",
            llll: "YYYYMDdddd HH:mm"
        },
        meridiemParse: /|||||/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "" || meridiem === "" || meridiem === "") {
                return hour;
            } else if (meridiem === "") {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === "" || meridiem === "") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return "";
            } else if (hm < 900) {
                return "";
            } else if (hm < 1200) {
                return "";
            } else if (hm === 1200) {
                return "";
            } else if (hm < 1800) {
                return "";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[]LT",
            nextDay: "[]LT",
            nextWeek: "[]ddddLT",
            lastDay: "[]LT",
            lastWeek: "[]ddddLT",
            sameElse: "L"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal: function(number, period) {
            switch (period) {
              case "d":
              case "D":
              case "DDD":
                return number + "";

              case "M":
                return number + "";

              case "w":
              case "W":
                return number + "";

              default:
                return number;
            }
        },
        relativeTime: {
            future: "%s",
            past: "%s",
            s: "",
            ss: "%d ",
            m: "1 ",
            mm: "%d ",
            h: "1 ",
            hh: "%d ",
            d: "1 ",
            dd: "%d ",
            M: "1 ",
            MM: "%d ",
            y: "1 ",
            yy: "%d "
        }
    });
    hooks.defineLocale("zh-mo", {
        months: "___________".split("_"),
        monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "YYYYMD",
            LLL: "YYYYMD HH:mm",
            LLLL: "YYYYMDdddd HH:mm",
            l: "D/M/YYYY",
            ll: "YYYYMD",
            lll: "YYYYMD HH:mm",
            llll: "YYYYMDdddd HH:mm"
        },
        meridiemParse: /|||||/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "" || meridiem === "" || meridiem === "") {
                return hour;
            } else if (meridiem === "") {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === "" || meridiem === "") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return "";
            } else if (hm < 900) {
                return "";
            } else if (hm < 1130) {
                return "";
            } else if (hm < 1230) {
                return "";
            } else if (hm < 1800) {
                return "";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "[]dddd LT",
            lastDay: "[] LT",
            lastWeek: "[]dddd LT",
            sameElse: "L"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal: function(number, period) {
            switch (period) {
              case "d":
              case "D":
              case "DDD":
                return number + "";

              case "M":
                return number + "";

              case "w":
              case "W":
                return number + "";

              default:
                return number;
            }
        },
        relativeTime: {
            future: "%s",
            past: "%s",
            s: "",
            ss: "%d ",
            m: "1 ",
            mm: "%d ",
            h: "1 ",
            hh: "%d ",
            d: "1 ",
            dd: "%d ",
            M: "1 ",
            MM: "%d ",
            y: "1 ",
            yy: "%d "
        }
    });
    hooks.defineLocale("zh-tw", {
        months: "___________".split("_"),
        monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY/MM/DD",
            LL: "YYYYMD",
            LLL: "YYYYMD HH:mm",
            LLLL: "YYYYMDdddd HH:mm",
            l: "YYYY/M/D",
            ll: "YYYYMD",
            lll: "YYYYMD HH:mm",
            llll: "YYYYMDdddd HH:mm"
        },
        meridiemParse: /|||||/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "" || meridiem === "" || meridiem === "") {
                return hour;
            } else if (meridiem === "") {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === "" || meridiem === "") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return "";
            } else if (hm < 900) {
                return "";
            } else if (hm < 1130) {
                return "";
            } else if (hm < 1230) {
                return "";
            } else if (hm < 1800) {
                return "";
            } else {
                return "";
            }
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "[]dddd LT",
            lastDay: "[] LT",
            lastWeek: "[]dddd LT",
            sameElse: "L"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal: function(number, period) {
            switch (period) {
              case "d":
              case "D":
              case "DDD":
                return number + "";

              case "M":
                return number + "";

              case "w":
              case "W":
                return number + "";

              default:
                return number;
            }
        },
        relativeTime: {
            future: "%s",
            past: "%s",
            s: "",
            ss: "%d ",
            m: "1 ",
            mm: "%d ",
            h: "1 ",
            hh: "%d ",
            d: "1 ",
            dd: "%d ",
            M: "1 ",
            MM: "%d ",
            y: "1 ",
            yy: "%d "
        }
    });
    hooks.locale("en");
    return hooks;
});

(function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, 
    global.bootstrap = factory());
})(this, function() {
    "use strict";
    const MAX_UID = 1e6;
    const MILLISECONDS_MULTIPLIER = 1e3;
    const TRANSITION_END = "transitionend";
    const toType = obj => {
        if (obj === null || obj === undefined) {
            return `${obj}`;
        }
        return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
    };
    const getUID = prefix => {
        do {
            prefix += Math.floor(Math.random() * MAX_UID);
        } while (document.getElementById(prefix));
        return prefix;
    };
    const getSelector = element => {
        let selector = element.getAttribute("data-bs-target");
        if (!selector || selector === "#") {
            let hrefAttr = element.getAttribute("href");
            if (!hrefAttr || !hrefAttr.includes("#") && !hrefAttr.startsWith(".")) {
                return null;
            }
            if (hrefAttr.includes("#") && !hrefAttr.startsWith("#")) {
                hrefAttr = `#${hrefAttr.split("#")[1]}`;
            }
            selector = hrefAttr && hrefAttr !== "#" ? hrefAttr.trim() : null;
        }
        return selector;
    };
    const getSelectorFromElement = element => {
        const selector = getSelector(element);
        if (selector) {
            return document.querySelector(selector) ? selector : null;
        }
        return null;
    };
    const getElementFromSelector = element => {
        const selector = getSelector(element);
        return selector ? document.querySelector(selector) : null;
    };
    const getTransitionDurationFromElement = element => {
        if (!element) {
            return 0;
        }
        let {
            transitionDuration,
            transitionDelay
        } = window.getComputedStyle(element);
        const floatTransitionDuration = Number.parseFloat(transitionDuration);
        const floatTransitionDelay = Number.parseFloat(transitionDelay);
        if (!floatTransitionDuration && !floatTransitionDelay) {
            return 0;
        }
        transitionDuration = transitionDuration.split(",")[0];
        transitionDelay = transitionDelay.split(",")[0];
        return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
    };
    const triggerTransitionEnd = element => {
        element.dispatchEvent(new Event(TRANSITION_END));
    };
    const isElement$1 = obj => (obj[0] || obj).nodeType;
    const emulateTransitionEnd = (element, duration) => {
        let called = false;
        const durationPadding = 5;
        const emulatedDuration = duration + durationPadding;
        function listener() {
            called = true;
            element.removeEventListener(TRANSITION_END, listener);
        }
        element.addEventListener(TRANSITION_END, listener);
        setTimeout(() => {
            if (!called) {
                triggerTransitionEnd(element);
            }
        }, emulatedDuration);
    };
    const typeCheckConfig = (componentName, config, configTypes) => {
        Object.keys(configTypes).forEach(property => {
            const expectedTypes = configTypes[property];
            const value = config[property];
            const valueType = value && isElement$1(value) ? "element" : toType(value);
            if (!new RegExp(expectedTypes).test(valueType)) {
                throw new TypeError(`${componentName.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
            }
        });
    };
    const isVisible = element => {
        if (!element) {
            return false;
        }
        if (element.style && element.parentNode && element.parentNode.style) {
            const elementStyle = getComputedStyle(element);
            const parentNodeStyle = getComputedStyle(element.parentNode);
            return elementStyle.display !== "none" && parentNodeStyle.display !== "none" && elementStyle.visibility !== "hidden";
        }
        return false;
    };
    const isDisabled = element => {
        if (!element || element.nodeType !== Node.ELEMENT_NODE) {
            return true;
        }
        if (element.classList.contains("disabled")) {
            return true;
        }
        if (typeof element.disabled !== "undefined") {
            return element.disabled;
        }
        return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
    };
    const findShadowRoot = element => {
        if (!document.documentElement.attachShadow) {
            return null;
        }
        if (typeof element.getRootNode === "function") {
            const root = element.getRootNode();
            return root instanceof ShadowRoot ? root : null;
        }
        if (element instanceof ShadowRoot) {
            return element;
        }
        if (!element.parentNode) {
            return null;
        }
        return findShadowRoot(element.parentNode);
    };
    const noop = () => {};
    const reflow = element => element.offsetHeight;
    const getjQuery = () => {
        const {
            jQuery
        } = window;
        if (jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
            return jQuery;
        }
        return null;
    };
    const onDOMContentLoaded = callback => {
        if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", callback);
        } else {
            callback();
        }
    };
    const isRTL = () => document.documentElement.dir === "rtl";
    const defineJQueryPlugin = (name, plugin) => {
        onDOMContentLoaded(() => {
            const $ = getjQuery();
            if ($) {
                const JQUERY_NO_CONFLICT = $.fn[name];
                $.fn[name] = plugin.jQueryInterface;
                $.fn[name].Constructor = plugin;
                $.fn[name].noConflict = () => {
                    $.fn[name] = JQUERY_NO_CONFLICT;
                    return plugin.jQueryInterface;
                };
            }
        });
    };
    const execute = callback => {
        if (typeof callback === "function") {
            callback();
        }
    };
    const elementMap = new Map();
    var Data = {
        set(element, key, instance) {
            if (!elementMap.has(element)) {
                elementMap.set(element, new Map());
            }
            const instanceMap = elementMap.get(element);
            if (!instanceMap.has(key) && instanceMap.size !== 0) {
                console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
                return;
            }
            instanceMap.set(key, instance);
        },
        get(element, key) {
            if (elementMap.has(element)) {
                return elementMap.get(element).get(key) || null;
            }
            return null;
        },
        remove(element, key) {
            if (!elementMap.has(element)) {
                return;
            }
            const instanceMap = elementMap.get(element);
            instanceMap.delete(key);
            if (instanceMap.size === 0) {
                elementMap.delete(element);
            }
        }
    };
    const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
    const stripNameRegex = /\..*/;
    const stripUidRegex = /::\d+$/;
    const eventRegistry = {};
    let uidEvent = 1;
    const customEvents = {
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    };
    const customEventsRegex = /^(mouseenter|mouseleave)/i;
    const nativeEvents = new Set([ "click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll" ]);
    function getUidEvent(element, uid) {
        return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
    }
    function getEvent(element) {
        const uid = getUidEvent(element);
        element.uidEvent = uid;
        eventRegistry[uid] = eventRegistry[uid] || {};
        return eventRegistry[uid];
    }
    function bootstrapHandler(element, fn) {
        return function handler(event) {
            event.delegateTarget = element;
            if (handler.oneOff) {
                EventHandler.off(element, event.type, fn);
            }
            return fn.apply(element, [ event ]);
        };
    }
    function bootstrapDelegationHandler(element, selector, fn) {
        return function handler(event) {
            const domElements = element.querySelectorAll(selector);
            for (let {
                target
            } = event; target && target !== this; target = target.parentNode) {
                for (let i = domElements.length; i--; ) {
                    if (domElements[i] === target) {
                        event.delegateTarget = target;
                        if (handler.oneOff) {
                            EventHandler.off(element, event.type, selector, fn);
                        }
                        return fn.apply(target, [ event ]);
                    }
                }
            }
            return null;
        };
    }
    function findHandler(events, handler, delegationSelector = null) {
        const uidEventList = Object.keys(events);
        for (let i = 0, len = uidEventList.length; i < len; i++) {
            const event = events[uidEventList[i]];
            if (event.originalHandler === handler && event.delegationSelector === delegationSelector) {
                return event;
            }
        }
        return null;
    }
    function normalizeParams(originalTypeEvent, handler, delegationFn) {
        const delegation = typeof handler === "string";
        const originalHandler = delegation ? delegationFn : handler;
        let typeEvent = getTypeEvent(originalTypeEvent);
        const isNative = nativeEvents.has(typeEvent);
        if (!isNative) {
            typeEvent = originalTypeEvent;
        }
        return [ delegation, originalHandler, typeEvent ];
    }
    function addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) {
        if (typeof originalTypeEvent !== "string" || !element) {
            return;
        }
        if (!handler) {
            handler = delegationFn;
            delegationFn = null;
        }
        if (customEventsRegex.test(originalTypeEvent)) {
            const wrapFn = fn => {
                return function(event) {
                    if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
                        return fn.call(this, event);
                    }
                };
            };
            if (delegationFn) {
                delegationFn = wrapFn(delegationFn);
            } else {
                handler = wrapFn(handler);
            }
        }
        const [ delegation, originalHandler, typeEvent ] = normalizeParams(originalTypeEvent, handler, delegationFn);
        const events = getEvent(element);
        const handlers = events[typeEvent] || (events[typeEvent] = {});
        const previousFn = findHandler(handlers, originalHandler, delegation ? handler : null);
        if (previousFn) {
            previousFn.oneOff = previousFn.oneOff && oneOff;
            return;
        }
        const uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex, ""));
        const fn = delegation ? bootstrapDelegationHandler(element, handler, delegationFn) : bootstrapHandler(element, handler);
        fn.delegationSelector = delegation ? handler : null;
        fn.originalHandler = originalHandler;
        fn.oneOff = oneOff;
        fn.uidEvent = uid;
        handlers[uid] = fn;
        element.addEventListener(typeEvent, fn, delegation);
    }
    function removeHandler(element, events, typeEvent, handler, delegationSelector) {
        const fn = findHandler(events[typeEvent], handler, delegationSelector);
        if (!fn) {
            return;
        }
        element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
        delete events[typeEvent][fn.uidEvent];
    }
    function removeNamespacedHandlers(element, events, typeEvent, namespace) {
        const storeElementEvent = events[typeEvent] || {};
        Object.keys(storeElementEvent).forEach(handlerKey => {
            if (handlerKey.includes(namespace)) {
                const event = storeElementEvent[handlerKey];
                removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
            }
        });
    }
    function getTypeEvent(event) {
        event = event.replace(stripNameRegex, "");
        return customEvents[event] || event;
    }
    const EventHandler = {
        on(element, event, handler, delegationFn) {
            addHandler(element, event, handler, delegationFn, false);
        },
        one(element, event, handler, delegationFn) {
            addHandler(element, event, handler, delegationFn, true);
        },
        off(element, originalTypeEvent, handler, delegationFn) {
            if (typeof originalTypeEvent !== "string" || !element) {
                return;
            }
            const [ delegation, originalHandler, typeEvent ] = normalizeParams(originalTypeEvent, handler, delegationFn);
            const inNamespace = typeEvent !== originalTypeEvent;
            const events = getEvent(element);
            const isNamespace = originalTypeEvent.startsWith(".");
            if (typeof originalHandler !== "undefined") {
                if (!events || !events[typeEvent]) {
                    return;
                }
                removeHandler(element, events, typeEvent, originalHandler, delegation ? handler : null);
                return;
            }
            if (isNamespace) {
                Object.keys(events).forEach(elementEvent => {
                    removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
                });
            }
            const storeElementEvent = events[typeEvent] || {};
            Object.keys(storeElementEvent).forEach(keyHandlers => {
                const handlerKey = keyHandlers.replace(stripUidRegex, "");
                if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
                    const event = storeElementEvent[keyHandlers];
                    removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
                }
            });
        },
        trigger(element, event, args) {
            if (typeof event !== "string" || !element) {
                return null;
            }
            const $ = getjQuery();
            const typeEvent = getTypeEvent(event);
            const inNamespace = event !== typeEvent;
            const isNative = nativeEvents.has(typeEvent);
            let jQueryEvent;
            let bubbles = true;
            let nativeDispatch = true;
            let defaultPrevented = false;
            let evt = null;
            if (inNamespace && $) {
                jQueryEvent = $.Event(event, args);
                $(element).trigger(jQueryEvent);
                bubbles = !jQueryEvent.isPropagationStopped();
                nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
                defaultPrevented = jQueryEvent.isDefaultPrevented();
            }
            if (isNative) {
                evt = document.createEvent("HTMLEvents");
                evt.initEvent(typeEvent, bubbles, true);
            } else {
                evt = new CustomEvent(event, {
                    bubbles: bubbles,
                    cancelable: true
                });
            }
            if (typeof args !== "undefined") {
                Object.keys(args).forEach(key => {
                    Object.defineProperty(evt, key, {
                        get() {
                            return args[key];
                        }
                    });
                });
            }
            if (defaultPrevented) {
                evt.preventDefault();
            }
            if (nativeDispatch) {
                element.dispatchEvent(evt);
            }
            if (evt.defaultPrevented && typeof jQueryEvent !== "undefined") {
                jQueryEvent.preventDefault();
            }
            return evt;
        }
    };
    const VERSION = "5.0.0";
    class BaseComponent {
        constructor(element) {
            element = typeof element === "string" ? document.querySelector(element) : element;
            if (!element) {
                return;
            }
            this._element = element;
            Data.set(this._element, this.constructor.DATA_KEY, this);
        }
        dispose() {
            Data.remove(this._element, this.constructor.DATA_KEY);
            EventHandler.off(this._element, `.${this.constructor.DATA_KEY}`);
            this._element = null;
        }
        static getInstance(element) {
            return Data.get(element, this.DATA_KEY);
        }
        static get VERSION() {
            return VERSION;
        }
    }
    const NAME$c = "alert";
    const DATA_KEY$b = "bs.alert";
    const EVENT_KEY$b = `.${DATA_KEY$b}`;
    const DATA_API_KEY$8 = ".data-api";
    const SELECTOR_DISMISS = '[data-bs-dismiss="alert"]';
    const EVENT_CLOSE = `close${EVENT_KEY$b}`;
    const EVENT_CLOSED = `closed${EVENT_KEY$b}`;
    const EVENT_CLICK_DATA_API$7 = `click${EVENT_KEY$b}${DATA_API_KEY$8}`;
    const CLASS_NAME_ALERT = "alert";
    const CLASS_NAME_FADE$6 = "fade";
    const CLASS_NAME_SHOW$9 = "show";
    class Alert extends BaseComponent {
        static get DATA_KEY() {
            return DATA_KEY$b;
        }
        close(element) {
            const rootElement = element ? this._getRootElement(element) : this._element;
            const customEvent = this._triggerCloseEvent(rootElement);
            if (customEvent === null || customEvent.defaultPrevented) {
                return;
            }
            this._removeElement(rootElement);
        }
        _getRootElement(element) {
            return getElementFromSelector(element) || element.closest(`.${CLASS_NAME_ALERT}`);
        }
        _triggerCloseEvent(element) {
            return EventHandler.trigger(element, EVENT_CLOSE);
        }
        _removeElement(element) {
            element.classList.remove(CLASS_NAME_SHOW$9);
            if (!element.classList.contains(CLASS_NAME_FADE$6)) {
                this._destroyElement(element);
                return;
            }
            const transitionDuration = getTransitionDurationFromElement(element);
            EventHandler.one(element, "transitionend", () => this._destroyElement(element));
            emulateTransitionEnd(element, transitionDuration);
        }
        _destroyElement(element) {
            if (element.parentNode) {
                element.parentNode.removeChild(element);
            }
            EventHandler.trigger(element, EVENT_CLOSED);
        }
        static jQueryInterface(config) {
            return this.each(function() {
                let data = Data.get(this, DATA_KEY$b);
                if (!data) {
                    data = new Alert(this);
                }
                if (config === "close") {
                    data[config](this);
                }
            });
        }
        static handleDismiss(alertInstance) {
            return function(event) {
                if (event) {
                    event.preventDefault();
                }
                alertInstance.close(this);
            };
        }
    }
    EventHandler.on(document, EVENT_CLICK_DATA_API$7, SELECTOR_DISMISS, Alert.handleDismiss(new Alert()));
    defineJQueryPlugin(NAME$c, Alert);
    const NAME$b = "button";
    const DATA_KEY$a = "bs.button";
    const EVENT_KEY$a = `.${DATA_KEY$a}`;
    const DATA_API_KEY$7 = ".data-api";
    const CLASS_NAME_ACTIVE$3 = "active";
    const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
    const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$7}`;
    class Button extends BaseComponent {
        static get DATA_KEY() {
            return DATA_KEY$a;
        }
        toggle() {
            this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
        }
        static jQueryInterface(config) {
            return this.each(function() {
                let data = Data.get(this, DATA_KEY$a);
                if (!data) {
                    data = new Button(this);
                }
                if (config === "toggle") {
                    data[config]();
                }
            });
        }
    }
    EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {
        event.preventDefault();
        const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
        let data = Data.get(button, DATA_KEY$a);
        if (!data) {
            data = new Button(button);
        }
        data.toggle();
    });
    defineJQueryPlugin(NAME$b, Button);
    function normalizeData(val) {
        if (val === "true") {
            return true;
        }
        if (val === "false") {
            return false;
        }
        if (val === Number(val).toString()) {
            return Number(val);
        }
        if (val === "" || val === "null") {
            return null;
        }
        return val;
    }
    function normalizeDataKey(key) {
        return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);
    }
    const Manipulator = {
        setDataAttribute(element, key, value) {
            element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
        },
        removeDataAttribute(element, key) {
            element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
        },
        getDataAttributes(element) {
            if (!element) {
                return {};
            }
            const attributes = {};
            Object.keys(element.dataset).filter(key => key.startsWith("bs")).forEach(key => {
                let pureKey = key.replace(/^bs/, "");
                pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
                attributes[pureKey] = normalizeData(element.dataset[key]);
            });
            return attributes;
        },
        getDataAttribute(element, key) {
            return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
        },
        offset(element) {
            const rect = element.getBoundingClientRect();
            return {
                top: rect.top + document.body.scrollTop,
                left: rect.left + document.body.scrollLeft
            };
        },
        position(element) {
            return {
                top: element.offsetTop,
                left: element.offsetLeft
            };
        }
    };
    const NODE_TEXT = 3;
    const SelectorEngine = {
        find(selector, element = document.documentElement) {
            return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
        },
        findOne(selector, element = document.documentElement) {
            return Element.prototype.querySelector.call(element, selector);
        },
        children(element, selector) {
            return [].concat(...element.children).filter(child => child.matches(selector));
        },
        parents(element, selector) {
            const parents = [];
            let ancestor = element.parentNode;
            while (ancestor && ancestor.nodeType === Node.ELEMENT_NODE && ancestor.nodeType !== NODE_TEXT) {
                if (ancestor.matches(selector)) {
                    parents.push(ancestor);
                }
                ancestor = ancestor.parentNode;
            }
            return parents;
        },
        prev(element, selector) {
            let previous = element.previousElementSibling;
            while (previous) {
                if (previous.matches(selector)) {
                    return [ previous ];
                }
                previous = previous.previousElementSibling;
            }
            return [];
        },
        next(element, selector) {
            let next = element.nextElementSibling;
            while (next) {
                if (next.matches(selector)) {
                    return [ next ];
                }
                next = next.nextElementSibling;
            }
            return [];
        }
    };
    const NAME$a = "carousel";
    const DATA_KEY$9 = "bs.carousel";
    const EVENT_KEY$9 = `.${DATA_KEY$9}`;
    const DATA_API_KEY$6 = ".data-api";
    const ARROW_LEFT_KEY = "ArrowLeft";
    const ARROW_RIGHT_KEY = "ArrowRight";
    const TOUCHEVENT_COMPAT_WAIT = 500;
    const SWIPE_THRESHOLD = 40;
    const Default$9 = {
        interval: 5e3,
        keyboard: true,
        slide: false,
        pause: "hover",
        wrap: true,
        touch: true
    };
    const DefaultType$9 = {
        interval: "(number|boolean)",
        keyboard: "boolean",
        slide: "(boolean|string)",
        pause: "(string|boolean)",
        wrap: "boolean",
        touch: "boolean"
    };
    const ORDER_NEXT = "next";
    const ORDER_PREV = "prev";
    const DIRECTION_LEFT = "left";
    const DIRECTION_RIGHT = "right";
    const EVENT_SLIDE = `slide${EVENT_KEY$9}`;
    const EVENT_SLID = `slid${EVENT_KEY$9}`;
    const EVENT_KEYDOWN = `keydown${EVENT_KEY$9}`;
    const EVENT_MOUSEENTER = `mouseenter${EVENT_KEY$9}`;
    const EVENT_MOUSELEAVE = `mouseleave${EVENT_KEY$9}`;
    const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
    const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
    const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
    const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
    const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
    const EVENT_DRAG_START = `dragstart${EVENT_KEY$9}`;
    const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$9}${DATA_API_KEY$6}`;
    const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$9}${DATA_API_KEY$6}`;
    const CLASS_NAME_CAROUSEL = "carousel";
    const CLASS_NAME_ACTIVE$2 = "active";
    const CLASS_NAME_SLIDE = "slide";
    const CLASS_NAME_END = "carousel-item-end";
    const CLASS_NAME_START = "carousel-item-start";
    const CLASS_NAME_NEXT = "carousel-item-next";
    const CLASS_NAME_PREV = "carousel-item-prev";
    const CLASS_NAME_POINTER_EVENT = "pointer-event";
    const SELECTOR_ACTIVE$1 = ".active";
    const SELECTOR_ACTIVE_ITEM = ".active.carousel-item";
    const SELECTOR_ITEM = ".carousel-item";
    const SELECTOR_ITEM_IMG = ".carousel-item img";
    const SELECTOR_NEXT_PREV = ".carousel-item-next, .carousel-item-prev";
    const SELECTOR_INDICATORS = ".carousel-indicators";
    const SELECTOR_INDICATOR = "[data-bs-target]";
    const SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
    const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
    const POINTER_TYPE_TOUCH = "touch";
    const POINTER_TYPE_PEN = "pen";
    class Carousel extends BaseComponent {
        constructor(element, config) {
            super(element);
            this._items = null;
            this._interval = null;
            this._activeElement = null;
            this._isPaused = false;
            this._isSliding = false;
            this.touchTimeout = null;
            this.touchStartX = 0;
            this.touchDeltaX = 0;
            this._config = this._getConfig(config);
            this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
            this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
            this._pointerEvent = Boolean(window.PointerEvent);
            this._addEventListeners();
        }
        static get Default() {
            return Default$9;
        }
        static get DATA_KEY() {
            return DATA_KEY$9;
        }
        next() {
            if (!this._isSliding) {
                this._slide(ORDER_NEXT);
            }
        }
        nextWhenVisible() {
            if (!document.hidden && isVisible(this._element)) {
                this.next();
            }
        }
        prev() {
            if (!this._isSliding) {
                this._slide(ORDER_PREV);
            }
        }
        pause(event) {
            if (!event) {
                this._isPaused = true;
            }
            if (SelectorEngine.findOne(SELECTOR_NEXT_PREV, this._element)) {
                triggerTransitionEnd(this._element);
                this.cycle(true);
            }
            clearInterval(this._interval);
            this._interval = null;
        }
        cycle(event) {
            if (!event) {
                this._isPaused = false;
            }
            if (this._interval) {
                clearInterval(this._interval);
                this._interval = null;
            }
            if (this._config && this._config.interval && !this._isPaused) {
                this._updateInterval();
                this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
            }
        }
        to(index) {
            this._activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
            const activeIndex = this._getItemIndex(this._activeElement);
            if (index > this._items.length - 1 || index < 0) {
                return;
            }
            if (this._isSliding) {
                EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
                return;
            }
            if (activeIndex === index) {
                this.pause();
                this.cycle();
                return;
            }
            const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
            this._slide(order, this._items[index]);
        }
        dispose() {
            this._items = null;
            this._config = null;
            this._interval = null;
            this._isPaused = null;
            this._isSliding = null;
            this._activeElement = null;
            this._indicatorsElement = null;
            super.dispose();
        }
        _getConfig(config) {
            config = {
                ...Default$9,
                ...config
            };
            typeCheckConfig(NAME$a, config, DefaultType$9);
            return config;
        }
        _handleSwipe() {
            const absDeltax = Math.abs(this.touchDeltaX);
            if (absDeltax <= SWIPE_THRESHOLD) {
                return;
            }
            const direction = absDeltax / this.touchDeltaX;
            this.touchDeltaX = 0;
            if (!direction) {
                return;
            }
            this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);
        }
        _addEventListeners() {
            if (this._config.keyboard) {
                EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));
            }
            if (this._config.pause === "hover") {
                EventHandler.on(this._element, EVENT_MOUSEENTER, event => this.pause(event));
                EventHandler.on(this._element, EVENT_MOUSELEAVE, event => this.cycle(event));
            }
            if (this._config.touch && this._touchSupported) {
                this._addTouchEventListeners();
            }
        }
        _addTouchEventListeners() {
            const start = event => {
                if (this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)) {
                    this.touchStartX = event.clientX;
                } else if (!this._pointerEvent) {
                    this.touchStartX = event.touches[0].clientX;
                }
            };
            const move = event => {
                this.touchDeltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this.touchStartX;
            };
            const end = event => {
                if (this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)) {
                    this.touchDeltaX = event.clientX - this.touchStartX;
                }
                this._handleSwipe();
                if (this._config.pause === "hover") {
                    this.pause();
                    if (this.touchTimeout) {
                        clearTimeout(this.touchTimeout);
                    }
                    this.touchTimeout = setTimeout(event => this.cycle(event), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
                }
            };
            SelectorEngine.find(SELECTOR_ITEM_IMG, this._element).forEach(itemImg => {
                EventHandler.on(itemImg, EVENT_DRAG_START, e => e.preventDefault());
            });
            if (this._pointerEvent) {
                EventHandler.on(this._element, EVENT_POINTERDOWN, event => start(event));
                EventHandler.on(this._element, EVENT_POINTERUP, event => end(event));
                this._element.classList.add(CLASS_NAME_POINTER_EVENT);
            } else {
                EventHandler.on(this._element, EVENT_TOUCHSTART, event => start(event));
                EventHandler.on(this._element, EVENT_TOUCHMOVE, event => move(event));
                EventHandler.on(this._element, EVENT_TOUCHEND, event => end(event));
            }
        }
        _keydown(event) {
            if (/input|textarea/i.test(event.target.tagName)) {
                return;
            }
            if (event.key === ARROW_LEFT_KEY) {
                event.preventDefault();
                this._slide(DIRECTION_RIGHT);
            } else if (event.key === ARROW_RIGHT_KEY) {
                event.preventDefault();
                this._slide(DIRECTION_LEFT);
            }
        }
        _getItemIndex(element) {
            this._items = element && element.parentNode ? SelectorEngine.find(SELECTOR_ITEM, element.parentNode) : [];
            return this._items.indexOf(element);
        }
        _getItemByOrder(order, activeElement) {
            const isNext = order === ORDER_NEXT;
            const isPrev = order === ORDER_PREV;
            const activeIndex = this._getItemIndex(activeElement);
            const lastItemIndex = this._items.length - 1;
            const isGoingToWrap = isPrev && activeIndex === 0 || isNext && activeIndex === lastItemIndex;
            if (isGoingToWrap && !this._config.wrap) {
                return activeElement;
            }
            const delta = isPrev ? -1 : 1;
            const itemIndex = (activeIndex + delta) % this._items.length;
            return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
        }
        _triggerSlideEvent(relatedTarget, eventDirectionName) {
            const targetIndex = this._getItemIndex(relatedTarget);
            const fromIndex = this._getItemIndex(SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element));
            return EventHandler.trigger(this._element, EVENT_SLIDE, {
                relatedTarget: relatedTarget,
                direction: eventDirectionName,
                from: fromIndex,
                to: targetIndex
            });
        }
        _setActiveIndicatorElement(element) {
            if (this._indicatorsElement) {
                const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE$1, this._indicatorsElement);
                activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
                activeIndicator.removeAttribute("aria-current");
                const indicators = SelectorEngine.find(SELECTOR_INDICATOR, this._indicatorsElement);
                for (let i = 0; i < indicators.length; i++) {
                    if (Number.parseInt(indicators[i].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(element)) {
                        indicators[i].classList.add(CLASS_NAME_ACTIVE$2);
                        indicators[i].setAttribute("aria-current", "true");
                        break;
                    }
                }
            }
        }
        _updateInterval() {
            const element = this._activeElement || SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
            if (!element) {
                return;
            }
            const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
            if (elementInterval) {
                this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
                this._config.interval = elementInterval;
            } else {
                this._config.interval = this._config.defaultInterval || this._config.interval;
            }
        }
        _slide(directionOrOrder, element) {
            const order = this._directionToOrder(directionOrOrder);
            const activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
            const activeElementIndex = this._getItemIndex(activeElement);
            const nextElement = element || this._getItemByOrder(order, activeElement);
            const nextElementIndex = this._getItemIndex(nextElement);
            const isCycling = Boolean(this._interval);
            const isNext = order === ORDER_NEXT;
            const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
            const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
            const eventDirectionName = this._orderToDirection(order);
            if (nextElement && nextElement.classList.contains(CLASS_NAME_ACTIVE$2)) {
                this._isSliding = false;
                return;
            }
            const slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);
            if (slideEvent.defaultPrevented) {
                return;
            }
            if (!activeElement || !nextElement) {
                return;
            }
            this._isSliding = true;
            if (isCycling) {
                this.pause();
            }
            this._setActiveIndicatorElement(nextElement);
            this._activeElement = nextElement;
            if (this._element.classList.contains(CLASS_NAME_SLIDE)) {
                nextElement.classList.add(orderClassName);
                reflow(nextElement);
                activeElement.classList.add(directionalClassName);
                nextElement.classList.add(directionalClassName);
                const transitionDuration = getTransitionDurationFromElement(activeElement);
                EventHandler.one(activeElement, "transitionend", () => {
                    nextElement.classList.remove(directionalClassName, orderClassName);
                    nextElement.classList.add(CLASS_NAME_ACTIVE$2);
                    activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
                    this._isSliding = false;
                    setTimeout(() => {
                        EventHandler.trigger(this._element, EVENT_SLID, {
                            relatedTarget: nextElement,
                            direction: eventDirectionName,
                            from: activeElementIndex,
                            to: nextElementIndex
                        });
                    }, 0);
                });
                emulateTransitionEnd(activeElement, transitionDuration);
            } else {
                activeElement.classList.remove(CLASS_NAME_ACTIVE$2);
                nextElement.classList.add(CLASS_NAME_ACTIVE$2);
                this._isSliding = false;
                EventHandler.trigger(this._element, EVENT_SLID, {
                    relatedTarget: nextElement,
                    direction: eventDirectionName,
                    from: activeElementIndex,
                    to: nextElementIndex
                });
            }
            if (isCycling) {
                this.cycle();
            }
        }
        _directionToOrder(direction) {
            if (![ DIRECTION_RIGHT, DIRECTION_LEFT ].includes(direction)) {
                return direction;
            }
            if (isRTL()) {
                return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
            }
            return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
        }
        _orderToDirection(order) {
            if (![ ORDER_NEXT, ORDER_PREV ].includes(order)) {
                return order;
            }
            if (isRTL()) {
                return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
            }
            return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
        }
        static carouselInterface(element, config) {
            let data = Data.get(element, DATA_KEY$9);
            let _config = {
                ...Default$9,
                ...Manipulator.getDataAttributes(element)
            };
            if (typeof config === "object") {
                _config = {
                    ..._config,
                    ...config
                };
            }
            const action = typeof config === "string" ? config : _config.slide;
            if (!data) {
                data = new Carousel(element, _config);
            }
            if (typeof config === "number") {
                data.to(config);
            } else if (typeof action === "string") {
                if (typeof data[action] === "undefined") {
                    throw new TypeError(`No method named "${action}"`);
                }
                data[action]();
            } else if (_config.interval && _config.ride) {
                data.pause();
                data.cycle();
            }
        }
        static jQueryInterface(config) {
            return this.each(function() {
                Carousel.carouselInterface(this, config);
            });
        }
        static dataApiClickHandler(event) {
            const target = getElementFromSelector(this);
            if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
                return;
            }
            const config = {
                ...Manipulator.getDataAttributes(target),
                ...Manipulator.getDataAttributes(this)
            };
            const slideIndex = this.getAttribute("data-bs-slide-to");
            if (slideIndex) {
                config.interval = false;
            }
            Carousel.carouselInterface(target, config);
            if (slideIndex) {
                Data.get(target, DATA_KEY$9).to(slideIndex);
            }
            event.preventDefault();
        }
    }
    EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler);
    EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
        const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
        for (let i = 0, len = carousels.length; i < len; i++) {
            Carousel.carouselInterface(carousels[i], Data.get(carousels[i], DATA_KEY$9));
        }
    });
    defineJQueryPlugin(NAME$a, Carousel);
    const NAME$9 = "collapse";
    const DATA_KEY$8 = "bs.collapse";
    const EVENT_KEY$8 = `.${DATA_KEY$8}`;
    const DATA_API_KEY$5 = ".data-api";
    const Default$8 = {
        toggle: true,
        parent: ""
    };
    const DefaultType$8 = {
        toggle: "boolean",
        parent: "(string|element)"
    };
    const EVENT_SHOW$5 = `show${EVENT_KEY$8}`;
    const EVENT_SHOWN$5 = `shown${EVENT_KEY$8}`;
    const EVENT_HIDE$5 = `hide${EVENT_KEY$8}`;
    const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$8}`;
    const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
    const CLASS_NAME_SHOW$8 = "show";
    const CLASS_NAME_COLLAPSE = "collapse";
    const CLASS_NAME_COLLAPSING = "collapsing";
    const CLASS_NAME_COLLAPSED = "collapsed";
    const WIDTH = "width";
    const HEIGHT = "height";
    const SELECTOR_ACTIVES = ".show, .collapsing";
    const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
    class Collapse extends BaseComponent {
        constructor(element, config) {
            super(element);
            this._isTransitioning = false;
            this._config = this._getConfig(config);
            this._triggerArray = SelectorEngine.find(`${SELECTOR_DATA_TOGGLE$4}[href="#${this._element.id}"],` + `${SELECTOR_DATA_TOGGLE$4}[data-bs-target="#${this._element.id}"]`);
            const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
            for (let i = 0, len = toggleList.length; i < len; i++) {
                const elem = toggleList[i];
                const selector = getSelectorFromElement(elem);
                const filterElement = SelectorEngine.find(selector).filter(foundElem => foundElem === this._element);
                if (selector !== null && filterElement.length) {
                    this._selector = selector;
                    this._triggerArray.push(elem);
                }
            }
            this._parent = this._config.parent ? this._getParent() : null;
            if (!this._config.parent) {
                this._addAriaAndCollapsedClass(this._element, this._triggerArray);
            }
            if (this._config.toggle) {
                this.toggle();
            }
        }
        static get Default() {
            return Default$8;
        }
        static get DATA_KEY() {
            return DATA_KEY$8;
        }
        toggle() {
            if (this._element.classList.contains(CLASS_NAME_SHOW$8)) {
                this.hide();
            } else {
                this.show();
            }
        }
        show() {
            if (this._isTransitioning || this._element.classList.contains(CLASS_NAME_SHOW$8)) {
                return;
            }
            let actives;
            let activesData;
            if (this._parent) {
                actives = SelectorEngine.find(SELECTOR_ACTIVES, this._parent).filter(elem => {
                    if (typeof this._config.parent === "string") {
                        return elem.getAttribute("data-bs-parent") === this._config.parent;
                    }
                    return elem.classList.contains(CLASS_NAME_COLLAPSE);
                });
                if (actives.length === 0) {
                    actives = null;
                }
            }
            const container = SelectorEngine.findOne(this._selector);
            if (actives) {
                const tempActiveData = actives.find(elem => container !== elem);
                activesData = tempActiveData ? Data.get(tempActiveData, DATA_KEY$8) : null;
                if (activesData && activesData._isTransitioning) {
                    return;
                }
            }
            const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$5);
            if (startEvent.defaultPrevented) {
                return;
            }
            if (actives) {
                actives.forEach(elemActive => {
                    if (container !== elemActive) {
                        Collapse.collapseInterface(elemActive, "hide");
                    }
                    if (!activesData) {
                        Data.set(elemActive, DATA_KEY$8, null);
                    }
                });
            }
            const dimension = this._getDimension();
            this._element.classList.remove(CLASS_NAME_COLLAPSE);
            this._element.classList.add(CLASS_NAME_COLLAPSING);
            this._element.style[dimension] = 0;
            if (this._triggerArray.length) {
                this._triggerArray.forEach(element => {
                    element.classList.remove(CLASS_NAME_COLLAPSED);
                    element.setAttribute("aria-expanded", true);
                });
            }
            this.setTransitioning(true);
            const complete = () => {
                this._element.classList.remove(CLASS_NAME_COLLAPSING);
                this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$8);
                this._element.style[dimension] = "";
                this.setTransitioning(false);
                EventHandler.trigger(this._element, EVENT_SHOWN$5);
            };
            const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
            const scrollSize = `scroll${capitalizedDimension}`;
            const transitionDuration = getTransitionDurationFromElement(this._element);
            EventHandler.one(this._element, "transitionend", complete);
            emulateTransitionEnd(this._element, transitionDuration);
            this._element.style[dimension] = `${this._element[scrollSize]}px`;
        }
        hide() {
            if (this._isTransitioning || !this._element.classList.contains(CLASS_NAME_SHOW$8)) {
                return;
            }
            const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$5);
            if (startEvent.defaultPrevented) {
                return;
            }
            const dimension = this._getDimension();
            this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
            reflow(this._element);
            this._element.classList.add(CLASS_NAME_COLLAPSING);
            this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$8);
            const triggerArrayLength = this._triggerArray.length;
            if (triggerArrayLength > 0) {
                for (let i = 0; i < triggerArrayLength; i++) {
                    const trigger = this._triggerArray[i];
                    const elem = getElementFromSelector(trigger);
                    if (elem && !elem.classList.contains(CLASS_NAME_SHOW$8)) {
                        trigger.classList.add(CLASS_NAME_COLLAPSED);
                        trigger.setAttribute("aria-expanded", false);
                    }
                }
            }
            this.setTransitioning(true);
            const complete = () => {
                this.setTransitioning(false);
                this._element.classList.remove(CLASS_NAME_COLLAPSING);
                this._element.classList.add(CLASS_NAME_COLLAPSE);
                EventHandler.trigger(this._element, EVENT_HIDDEN$5);
            };
            this._element.style[dimension] = "";
            const transitionDuration = getTransitionDurationFromElement(this._element);
            EventHandler.one(this._element, "transitionend", complete);
            emulateTransitionEnd(this._element, transitionDuration);
        }
        setTransitioning(isTransitioning) {
            this._isTransitioning = isTransitioning;
        }
        dispose() {
            super.dispose();
            this._config = null;
            this._parent = null;
            this._triggerArray = null;
            this._isTransitioning = null;
        }
        _getConfig(config) {
            config = {
                ...Default$8,
                ...config
            };
            config.toggle = Boolean(config.toggle);
            typeCheckConfig(NAME$9, config, DefaultType$8);
            return config;
        }
        _getDimension() {
            return this._element.classList.contains(WIDTH) ? WIDTH : HEIGHT;
        }
        _getParent() {
            let {
                parent
            } = this._config;
            if (isElement$1(parent)) {
                if (typeof parent.jquery !== "undefined" || typeof parent[0] !== "undefined") {
                    parent = parent[0];
                }
            } else {
                parent = SelectorEngine.findOne(parent);
            }
            const selector = `${SELECTOR_DATA_TOGGLE$4}[data-bs-parent="${parent}"]`;
            SelectorEngine.find(selector, parent).forEach(element => {
                const selected = getElementFromSelector(element);
                this._addAriaAndCollapsedClass(selected, [ element ]);
            });
            return parent;
        }
        _addAriaAndCollapsedClass(element, triggerArray) {
            if (!element || !triggerArray.length) {
                return;
            }
            const isOpen = element.classList.contains(CLASS_NAME_SHOW$8);
            triggerArray.forEach(elem => {
                if (isOpen) {
                    elem.classList.remove(CLASS_NAME_COLLAPSED);
                } else {
                    elem.classList.add(CLASS_NAME_COLLAPSED);
                }
                elem.setAttribute("aria-expanded", isOpen);
            });
        }
        static collapseInterface(element, config) {
            let data = Data.get(element, DATA_KEY$8);
            const _config = {
                ...Default$8,
                ...Manipulator.getDataAttributes(element),
                ...typeof config === "object" && config ? config : {}
            };
            if (!data && _config.toggle && typeof config === "string" && /show|hide/.test(config)) {
                _config.toggle = false;
            }
            if (!data) {
                data = new Collapse(element, _config);
            }
            if (typeof config === "string") {
                if (typeof data[config] === "undefined") {
                    throw new TypeError(`No method named "${config}"`);
                }
                data[config]();
            }
        }
        static jQueryInterface(config) {
            return this.each(function() {
                Collapse.collapseInterface(this, config);
            });
        }
    }
    EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
        if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
            event.preventDefault();
        }
        const triggerData = Manipulator.getDataAttributes(this);
        const selector = getSelectorFromElement(this);
        const selectorElements = SelectorEngine.find(selector);
        selectorElements.forEach(element => {
            const data = Data.get(element, DATA_KEY$8);
            let config;
            if (data) {
                if (data._parent === null && typeof triggerData.parent === "string") {
                    data._config.parent = triggerData.parent;
                    data._parent = data._getParent();
                }
                config = "toggle";
            } else {
                config = triggerData;
            }
            Collapse.collapseInterface(element, config);
        });
    });
    defineJQueryPlugin(NAME$9, Collapse);
    var top = "top";
    var bottom = "bottom";
    var right = "right";
    var left = "left";
    var auto = "auto";
    var basePlacements = [ top, bottom, right, left ];
    var start = "start";
    var end = "end";
    var clippingParents = "clippingParents";
    var viewport = "viewport";
    var popper = "popper";
    var reference = "reference";
    var variationPlacements = basePlacements.reduce(function(acc, placement) {
        return acc.concat([ placement + "-" + start, placement + "-" + end ]);
    }, []);
    var placements = [].concat(basePlacements, [ auto ]).reduce(function(acc, placement) {
        return acc.concat([ placement, placement + "-" + start, placement + "-" + end ]);
    }, []);
    var beforeRead = "beforeRead";
    var read = "read";
    var afterRead = "afterRead";
    var beforeMain = "beforeMain";
    var main = "main";
    var afterMain = "afterMain";
    var beforeWrite = "beforeWrite";
    var write = "write";
    var afterWrite = "afterWrite";
    var modifierPhases = [ beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite ];
    function getNodeName(element) {
        return element ? (element.nodeName || "").toLowerCase() : null;
    }
    function getWindow(node) {
        if (node == null) {
            return window;
        }
        if (node.toString() !== "[object Window]") {
            var ownerDocument = node.ownerDocument;
            return ownerDocument ? ownerDocument.defaultView || window : window;
        }
        return node;
    }
    function isElement(node) {
        var OwnElement = getWindow(node).Element;
        return node instanceof OwnElement || node instanceof Element;
    }
    function isHTMLElement(node) {
        var OwnElement = getWindow(node).HTMLElement;
        return node instanceof OwnElement || node instanceof HTMLElement;
    }
    function isShadowRoot(node) {
        if (typeof ShadowRoot === "undefined") {
            return false;
        }
        var OwnElement = getWindow(node).ShadowRoot;
        return node instanceof OwnElement || node instanceof ShadowRoot;
    }
    function applyStyles(_ref) {
        var state = _ref.state;
        Object.keys(state.elements).forEach(function(name) {
            var style = state.styles[name] || {};
            var attributes = state.attributes[name] || {};
            var element = state.elements[name];
            if (!isHTMLElement(element) || !getNodeName(element)) {
                return;
            }
            Object.assign(element.style, style);
            Object.keys(attributes).forEach(function(name) {
                var value = attributes[name];
                if (value === false) {
                    element.removeAttribute(name);
                } else {
                    element.setAttribute(name, value === true ? "" : value);
                }
            });
        });
    }
    function effect$2(_ref2) {
        var state = _ref2.state;
        var initialStyles = {
            popper: {
                position: state.options.strategy,
                left: "0",
                top: "0",
                margin: "0"
            },
            arrow: {
                position: "absolute"
            },
            reference: {}
        };
        Object.assign(state.elements.popper.style, initialStyles.popper);
        state.styles = initialStyles;
        if (state.elements.arrow) {
            Object.assign(state.elements.arrow.style, initialStyles.arrow);
        }
        return function() {
            Object.keys(state.elements).forEach(function(name) {
                var element = state.elements[name];
                var attributes = state.attributes[name] || {};
                var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
                var style = styleProperties.reduce(function(style, property) {
                    style[property] = "";
                    return style;
                }, {});
                if (!isHTMLElement(element) || !getNodeName(element)) {
                    return;
                }
                Object.assign(element.style, style);
                Object.keys(attributes).forEach(function(attribute) {
                    element.removeAttribute(attribute);
                });
            });
        };
    }
    var applyStyles$1 = {
        name: "applyStyles",
        enabled: true,
        phase: "write",
        fn: applyStyles,
        effect: effect$2,
        requires: [ "computeStyles" ]
    };
    function getBasePlacement(placement) {
        return placement.split("-")[0];
    }
    function getBoundingClientRect(element) {
        var rect = element.getBoundingClientRect();
        return {
            width: rect.width,
            height: rect.height,
            top: rect.top,
            right: rect.right,
            bottom: rect.bottom,
            left: rect.left,
            x: rect.left,
            y: rect.top
        };
    }
    function getLayoutRect(element) {
        var clientRect = getBoundingClientRect(element);
        var width = element.offsetWidth;
        var height = element.offsetHeight;
        if (Math.abs(clientRect.width - width) <= 1) {
            width = clientRect.width;
        }
        if (Math.abs(clientRect.height - height) <= 1) {
            height = clientRect.height;
        }
        return {
            x: element.offsetLeft,
            y: element.offsetTop,
            width: width,
            height: height
        };
    }
    function contains(parent, child) {
        var rootNode = child.getRootNode && child.getRootNode();
        if (parent.contains(child)) {
            return true;
        } else if (rootNode && isShadowRoot(rootNode)) {
            var next = child;
            do {
                if (next && parent.isSameNode(next)) {
                    return true;
                }
                next = next.parentNode || next.host;
            } while (next);
        }
        return false;
    }
    function getComputedStyle$1(element) {
        return getWindow(element).getComputedStyle(element);
    }
    function isTableElement(element) {
        return [ "table", "td", "th" ].indexOf(getNodeName(element)) >= 0;
    }
    function getDocumentElement(element) {
        return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
    }
    function getParentNode(element) {
        if (getNodeName(element) === "html") {
            return element;
        }
        return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
    }
    function getTrueOffsetParent(element) {
        if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
            return null;
        }
        return element.offsetParent;
    }
    function getContainingBlock(element) {
        var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
        var isIE = navigator.userAgent.indexOf("Trident") !== -1;
        if (isIE && isHTMLElement(element)) {
            var elementCss = getComputedStyle$1(element);
            if (elementCss.position === "fixed") {
                return null;
            }
        }
        var currentNode = getParentNode(element);
        while (isHTMLElement(currentNode) && [ "html", "body" ].indexOf(getNodeName(currentNode)) < 0) {
            var css = getComputedStyle$1(currentNode);
            if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || [ "transform", "perspective" ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
                return currentNode;
            } else {
                currentNode = currentNode.parentNode;
            }
        }
        return null;
    }
    function getOffsetParent(element) {
        var window = getWindow(element);
        var offsetParent = getTrueOffsetParent(element);
        while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
            offsetParent = getTrueOffsetParent(offsetParent);
        }
        if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
            return window;
        }
        return offsetParent || getContainingBlock(element) || window;
    }
    function getMainAxisFromPlacement(placement) {
        return [ "top", "bottom" ].indexOf(placement) >= 0 ? "x" : "y";
    }
    var max = Math.max;
    var min = Math.min;
    var round = Math.round;
    function within(min$1, value, max$1) {
        return max(min$1, min(value, max$1));
    }
    function getFreshSideObject() {
        return {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        };
    }
    function mergePaddingObject(paddingObject) {
        return Object.assign({}, getFreshSideObject(), paddingObject);
    }
    function expandToHashMap(value, keys) {
        return keys.reduce(function(hashMap, key) {
            hashMap[key] = value;
            return hashMap;
        }, {});
    }
    var toPaddingObject = function toPaddingObject(padding, state) {
        padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
            placement: state.placement
        })) : padding;
        return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    };
    function arrow(_ref) {
        var _state$modifiersData$;
        var state = _ref.state, name = _ref.name, options = _ref.options;
        var arrowElement = state.elements.arrow;
        var popperOffsets = state.modifiersData.popperOffsets;
        var basePlacement = getBasePlacement(state.placement);
        var axis = getMainAxisFromPlacement(basePlacement);
        var isVertical = [ left, right ].indexOf(basePlacement) >= 0;
        var len = isVertical ? "height" : "width";
        if (!arrowElement || !popperOffsets) {
            return;
        }
        var paddingObject = toPaddingObject(options.padding, state);
        var arrowRect = getLayoutRect(arrowElement);
        var minProp = axis === "y" ? top : left;
        var maxProp = axis === "y" ? bottom : right;
        var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
        var startDiff = popperOffsets[axis] - state.rects.reference[axis];
        var arrowOffsetParent = getOffsetParent(arrowElement);
        var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
        var centerToReference = endDiff / 2 - startDiff / 2;
        var min = paddingObject[minProp];
        var max = clientSize - arrowRect[len] - paddingObject[maxProp];
        var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
        var offset = within(min, center, max);
        var axisProp = axis;
        state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, 
        _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
    }
    function effect$1(_ref2) {
        var state = _ref2.state, options = _ref2.options;
        var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
        if (arrowElement == null) {
            return;
        }
        if (typeof arrowElement === "string") {
            arrowElement = state.elements.popper.querySelector(arrowElement);
            if (!arrowElement) {
                return;
            }
        }
        if (!contains(state.elements.popper, arrowElement)) {
            return;
        }
        state.elements.arrow = arrowElement;
    }
    var arrow$1 = {
        name: "arrow",
        enabled: true,
        phase: "main",
        fn: arrow,
        effect: effect$1,
        requires: [ "popperOffsets" ],
        requiresIfExists: [ "preventOverflow" ]
    };
    var unsetSides = {
        top: "auto",
        right: "auto",
        bottom: "auto",
        left: "auto"
    };
    function roundOffsetsByDPR(_ref) {
        var x = _ref.x, y = _ref.y;
        var win = window;
        var dpr = win.devicePixelRatio || 1;
        return {
            x: round(round(x * dpr) / dpr) || 0,
            y: round(round(y * dpr) / dpr) || 0
        };
    }
    function mapToStyles(_ref2) {
        var _Object$assign2;
        var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets;
        var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === "function" ? roundOffsets(offsets) : offsets, _ref3$x = _ref3.x, x = _ref3$x === void 0 ? 0 : _ref3$x, _ref3$y = _ref3.y, y = _ref3$y === void 0 ? 0 : _ref3$y;
        var hasX = offsets.hasOwnProperty("x");
        var hasY = offsets.hasOwnProperty("y");
        var sideX = left;
        var sideY = top;
        var win = window;
        if (adaptive) {
            var offsetParent = getOffsetParent(popper);
            var heightProp = "clientHeight";
            var widthProp = "clientWidth";
            if (offsetParent === getWindow(popper)) {
                offsetParent = getDocumentElement(popper);
                if (getComputedStyle$1(offsetParent).position !== "static") {
                    heightProp = "scrollHeight";
                    widthProp = "scrollWidth";
                }
            }
            offsetParent = offsetParent;
            if (placement === top) {
                sideY = bottom;
                y -= offsetParent[heightProp] - popperRect.height;
                y *= gpuAcceleration ? 1 : -1;
            }
            if (placement === left) {
                sideX = right;
                x -= offsetParent[widthProp] - popperRect.width;
                x *= gpuAcceleration ? 1 : -1;
            }
        }
        var commonStyles = Object.assign({
            position: position
        }, adaptive && unsetSides);
        if (gpuAcceleration) {
            var _Object$assign;
            return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", 
            _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", 
            _Object$assign));
        }
        return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", 
        _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
    }
    function computeStyles(_ref4) {
        var state = _ref4.state, options = _ref4.options;
        var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
        var commonStyles = {
            placement: getBasePlacement(state.placement),
            popper: state.elements.popper,
            popperRect: state.rects.popper,
            gpuAcceleration: gpuAcceleration
        };
        if (state.modifiersData.popperOffsets != null) {
            state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
                offsets: state.modifiersData.popperOffsets,
                position: state.options.strategy,
                adaptive: adaptive,
                roundOffsets: roundOffsets
            })));
        }
        if (state.modifiersData.arrow != null) {
            state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
                offsets: state.modifiersData.arrow,
                position: "absolute",
                adaptive: false,
                roundOffsets: roundOffsets
            })));
        }
        state.attributes.popper = Object.assign({}, state.attributes.popper, {
            "data-popper-placement": state.placement
        });
    }
    var computeStyles$1 = {
        name: "computeStyles",
        enabled: true,
        phase: "beforeWrite",
        fn: computeStyles,
        data: {}
    };
    var passive = {
        passive: true
    };
    function effect(_ref) {
        var state = _ref.state, instance = _ref.instance, options = _ref.options;
        var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
        var window = getWindow(state.elements.popper);
        var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
        if (scroll) {
            scrollParents.forEach(function(scrollParent) {
                scrollParent.addEventListener("scroll", instance.update, passive);
            });
        }
        if (resize) {
            window.addEventListener("resize", instance.update, passive);
        }
        return function() {
            if (scroll) {
                scrollParents.forEach(function(scrollParent) {
                    scrollParent.removeEventListener("scroll", instance.update, passive);
                });
            }
            if (resize) {
                window.removeEventListener("resize", instance.update, passive);
            }
        };
    }
    var eventListeners = {
        name: "eventListeners",
        enabled: true,
        phase: "write",
        fn: function fn() {},
        effect: effect,
        data: {}
    };
    var hash$1 = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
    };
    function getOppositePlacement(placement) {
        return placement.replace(/left|right|bottom|top/g, function(matched) {
            return hash$1[matched];
        });
    }
    var hash = {
        start: "end",
        end: "start"
    };
    function getOppositeVariationPlacement(placement) {
        return placement.replace(/start|end/g, function(matched) {
            return hash[matched];
        });
    }
    function getWindowScroll(node) {
        var win = getWindow(node);
        var scrollLeft = win.pageXOffset;
        var scrollTop = win.pageYOffset;
        return {
            scrollLeft: scrollLeft,
            scrollTop: scrollTop
        };
    }
    function getWindowScrollBarX(element) {
        return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }
    function getViewportRect(element) {
        var win = getWindow(element);
        var html = getDocumentElement(element);
        var visualViewport = win.visualViewport;
        var width = html.clientWidth;
        var height = html.clientHeight;
        var x = 0;
        var y = 0;
        if (visualViewport) {
            width = visualViewport.width;
            height = visualViewport.height;
            if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
                x = visualViewport.offsetLeft;
                y = visualViewport.offsetTop;
            }
        }
        return {
            width: width,
            height: height,
            x: x + getWindowScrollBarX(element),
            y: y
        };
    }
    function getDocumentRect(element) {
        var _element$ownerDocumen;
        var html = getDocumentElement(element);
        var winScroll = getWindowScroll(element);
        var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
        var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
        var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
        var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
        var y = -winScroll.scrollTop;
        if (getComputedStyle$1(body || html).direction === "rtl") {
            x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
        }
        return {
            width: width,
            height: height,
            x: x,
            y: y
        };
    }
    function isScrollParent(element) {
        var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
        return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }
    function getScrollParent(node) {
        if ([ "html", "body", "#document" ].indexOf(getNodeName(node)) >= 0) {
            return node.ownerDocument.body;
        }
        if (isHTMLElement(node) && isScrollParent(node)) {
            return node;
        }
        return getScrollParent(getParentNode(node));
    }
    function listScrollParents(element, list) {
        var _element$ownerDocumen;
        if (list === void 0) {
            list = [];
        }
        var scrollParent = getScrollParent(element);
        var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
        var win = getWindow(scrollParent);
        var target = isBody ? [ win ].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
        var updatedList = list.concat(target);
        return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
    }
    function rectToClientRect(rect) {
        return Object.assign({}, rect, {
            left: rect.x,
            top: rect.y,
            right: rect.x + rect.width,
            bottom: rect.y + rect.height
        });
    }
    function getInnerBoundingClientRect(element) {
        var rect = getBoundingClientRect(element);
        rect.top = rect.top + element.clientTop;
        rect.left = rect.left + element.clientLeft;
        rect.bottom = rect.top + element.clientHeight;
        rect.right = rect.left + element.clientWidth;
        rect.width = element.clientWidth;
        rect.height = element.clientHeight;
        rect.x = rect.left;
        rect.y = rect.top;
        return rect;
    }
    function getClientRectFromMixedType(element, clippingParent) {
        return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    }
    function getClippingParents(element) {
        var clippingParents = listScrollParents(getParentNode(element));
        var canEscapeClipping = [ "absolute", "fixed" ].indexOf(getComputedStyle$1(element).position) >= 0;
        var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
        if (!isElement(clipperElement)) {
            return [];
        }
        return clippingParents.filter(function(clippingParent) {
            return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
        });
    }
    function getClippingRect(element, boundary, rootBoundary) {
        var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
        var clippingParents = [].concat(mainClippingParents, [ rootBoundary ]);
        var firstClippingParent = clippingParents[0];
        var clippingRect = clippingParents.reduce(function(accRect, clippingParent) {
            var rect = getClientRectFromMixedType(element, clippingParent);
            accRect.top = max(rect.top, accRect.top);
            accRect.right = min(rect.right, accRect.right);
            accRect.bottom = min(rect.bottom, accRect.bottom);
            accRect.left = max(rect.left, accRect.left);
            return accRect;
        }, getClientRectFromMixedType(element, firstClippingParent));
        clippingRect.width = clippingRect.right - clippingRect.left;
        clippingRect.height = clippingRect.bottom - clippingRect.top;
        clippingRect.x = clippingRect.left;
        clippingRect.y = clippingRect.top;
        return clippingRect;
    }
    function getVariation(placement) {
        return placement.split("-")[1];
    }
    function computeOffsets(_ref) {
        var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
        var basePlacement = placement ? getBasePlacement(placement) : null;
        var variation = placement ? getVariation(placement) : null;
        var commonX = reference.x + reference.width / 2 - element.width / 2;
        var commonY = reference.y + reference.height / 2 - element.height / 2;
        var offsets;
        switch (basePlacement) {
          case top:
            offsets = {
                x: commonX,
                y: reference.y - element.height
            };
            break;

          case bottom:
            offsets = {
                x: commonX,
                y: reference.y + reference.height
            };
            break;

          case right:
            offsets = {
                x: reference.x + reference.width,
                y: commonY
            };
            break;

          case left:
            offsets = {
                x: reference.x - element.width,
                y: commonY
            };
            break;

          default:
            offsets = {
                x: reference.x,
                y: reference.y
            };
        }
        var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
        if (mainAxis != null) {
            var len = mainAxis === "y" ? "height" : "width";
            switch (variation) {
              case start:
                offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
                break;

              case end:
                offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
                break;
            }
        }
        return offsets;
    }
    function detectOverflow(state, options) {
        if (options === void 0) {
            options = {};
        }
        var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
        var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
        var altContext = elementContext === popper ? reference : popper;
        var referenceElement = state.elements.reference;
        var popperRect = state.rects.popper;
        var element = state.elements[altBoundary ? altContext : elementContext];
        var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
        var referenceClientRect = getBoundingClientRect(referenceElement);
        var popperOffsets = computeOffsets({
            reference: referenceClientRect,
            element: popperRect,
            strategy: "absolute",
            placement: placement
        });
        var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
        var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
        var overflowOffsets = {
            top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
            bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
            left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
            right: elementClientRect.right - clippingClientRect.right + paddingObject.right
        };
        var offsetData = state.modifiersData.offset;
        if (elementContext === popper && offsetData) {
            var offset = offsetData[placement];
            Object.keys(overflowOffsets).forEach(function(key) {
                var multiply = [ right, bottom ].indexOf(key) >= 0 ? 1 : -1;
                var axis = [ top, bottom ].indexOf(key) >= 0 ? "y" : "x";
                overflowOffsets[key] += offset[axis] * multiply;
            });
        }
        return overflowOffsets;
    }
    function computeAutoPlacement(state, options) {
        if (options === void 0) {
            options = {};
        }
        var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
        var variation = getVariation(placement);
        var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement) {
            return getVariation(placement) === variation;
        }) : basePlacements;
        var allowedPlacements = placements$1.filter(function(placement) {
            return allowedAutoPlacements.indexOf(placement) >= 0;
        });
        if (allowedPlacements.length === 0) {
            allowedPlacements = placements$1;
        }
        var overflows = allowedPlacements.reduce(function(acc, placement) {
            acc[placement] = detectOverflow(state, {
                placement: placement,
                boundary: boundary,
                rootBoundary: rootBoundary,
                padding: padding
            })[getBasePlacement(placement)];
            return acc;
        }, {});
        return Object.keys(overflows).sort(function(a, b) {
            return overflows[a] - overflows[b];
        });
    }
    function getExpandedFallbackPlacements(placement) {
        if (getBasePlacement(placement) === auto) {
            return [];
        }
        var oppositePlacement = getOppositePlacement(placement);
        return [ getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement) ];
    }
    function flip(_ref) {
        var state = _ref.state, options = _ref.options, name = _ref.name;
        if (state.modifiersData[name]._skip) {
            return;
        }
        var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
        var preferredPlacement = state.options.placement;
        var basePlacement = getBasePlacement(preferredPlacement);
        var isBasePlacement = basePlacement === preferredPlacement;
        var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [ getOppositePlacement(preferredPlacement) ] : getExpandedFallbackPlacements(preferredPlacement));
        var placements = [ preferredPlacement ].concat(fallbackPlacements).reduce(function(acc, placement) {
            return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
                placement: placement,
                boundary: boundary,
                rootBoundary: rootBoundary,
                padding: padding,
                flipVariations: flipVariations,
                allowedAutoPlacements: allowedAutoPlacements
            }) : placement);
        }, []);
        var referenceRect = state.rects.reference;
        var popperRect = state.rects.popper;
        var checksMap = new Map();
        var makeFallbackChecks = true;
        var firstFittingPlacement = placements[0];
        for (var i = 0; i < placements.length; i++) {
            var placement = placements[i];
            var _basePlacement = getBasePlacement(placement);
            var isStartVariation = getVariation(placement) === start;
            var isVertical = [ top, bottom ].indexOf(_basePlacement) >= 0;
            var len = isVertical ? "width" : "height";
            var overflow = detectOverflow(state, {
                placement: placement,
                boundary: boundary,
                rootBoundary: rootBoundary,
                altBoundary: altBoundary,
                padding: padding
            });
            var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
            if (referenceRect[len] > popperRect[len]) {
                mainVariationSide = getOppositePlacement(mainVariationSide);
            }
            var altVariationSide = getOppositePlacement(mainVariationSide);
            var checks = [];
            if (checkMainAxis) {
                checks.push(overflow[_basePlacement] <= 0);
            }
            if (checkAltAxis) {
                checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
            }
            if (checks.every(function(check) {
                return check;
            })) {
                firstFittingPlacement = placement;
                makeFallbackChecks = false;
                break;
            }
            checksMap.set(placement, checks);
        }
        if (makeFallbackChecks) {
            var numberOfChecks = flipVariations ? 3 : 1;
            var _loop = function _loop(_i) {
                var fittingPlacement = placements.find(function(placement) {
                    var checks = checksMap.get(placement);
                    if (checks) {
                        return checks.slice(0, _i).every(function(check) {
                            return check;
                        });
                    }
                });
                if (fittingPlacement) {
                    firstFittingPlacement = fittingPlacement;
                    return "break";
                }
            };
            for (var _i = numberOfChecks; _i > 0; _i--) {
                var _ret = _loop(_i);
                if (_ret === "break") break;
            }
        }
        if (state.placement !== firstFittingPlacement) {
            state.modifiersData[name]._skip = true;
            state.placement = firstFittingPlacement;
            state.reset = true;
        }
    }
    var flip$1 = {
        name: "flip",
        enabled: true,
        phase: "main",
        fn: flip,
        requiresIfExists: [ "offset" ],
        data: {
            _skip: false
        }
    };
    function getSideOffsets(overflow, rect, preventedOffsets) {
        if (preventedOffsets === void 0) {
            preventedOffsets = {
                x: 0,
                y: 0
            };
        }
        return {
            top: overflow.top - rect.height - preventedOffsets.y,
            right: overflow.right - rect.width + preventedOffsets.x,
            bottom: overflow.bottom - rect.height + preventedOffsets.y,
            left: overflow.left - rect.width - preventedOffsets.x
        };
    }
    function isAnySideFullyClipped(overflow) {
        return [ top, right, bottom, left ].some(function(side) {
            return overflow[side] >= 0;
        });
    }
    function hide$1(_ref) {
        var state = _ref.state, name = _ref.name;
        var referenceRect = state.rects.reference;
        var popperRect = state.rects.popper;
        var preventedOffsets = state.modifiersData.preventOverflow;
        var referenceOverflow = detectOverflow(state, {
            elementContext: "reference"
        });
        var popperAltOverflow = detectOverflow(state, {
            altBoundary: true
        });
        var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
        var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
        var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
        var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
        state.modifiersData[name] = {
            referenceClippingOffsets: referenceClippingOffsets,
            popperEscapeOffsets: popperEscapeOffsets,
            isReferenceHidden: isReferenceHidden,
            hasPopperEscaped: hasPopperEscaped
        };
        state.attributes.popper = Object.assign({}, state.attributes.popper, {
            "data-popper-reference-hidden": isReferenceHidden,
            "data-popper-escaped": hasPopperEscaped
        });
    }
    var hide$2 = {
        name: "hide",
        enabled: true,
        phase: "main",
        requiresIfExists: [ "preventOverflow" ],
        fn: hide$1
    };
    function distanceAndSkiddingToXY(placement, rects, offset) {
        var basePlacement = getBasePlacement(placement);
        var invertDistance = [ left, top ].indexOf(basePlacement) >= 0 ? -1 : 1;
        var _ref = typeof offset === "function" ? offset(Object.assign({}, rects, {
            placement: placement
        })) : offset, skidding = _ref[0], distance = _ref[1];
        skidding = skidding || 0;
        distance = (distance || 0) * invertDistance;
        return [ left, right ].indexOf(basePlacement) >= 0 ? {
            x: distance,
            y: skidding
        } : {
            x: skidding,
            y: distance
        };
    }
    function offset(_ref2) {
        var state = _ref2.state, options = _ref2.options, name = _ref2.name;
        var _options$offset = options.offset, offset = _options$offset === void 0 ? [ 0, 0 ] : _options$offset;
        var data = placements.reduce(function(acc, placement) {
            acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
            return acc;
        }, {});
        var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
        if (state.modifiersData.popperOffsets != null) {
            state.modifiersData.popperOffsets.x += x;
            state.modifiersData.popperOffsets.y += y;
        }
        state.modifiersData[name] = data;
    }
    var offset$1 = {
        name: "offset",
        enabled: true,
        phase: "main",
        requires: [ "popperOffsets" ],
        fn: offset
    };
    function popperOffsets(_ref) {
        var state = _ref.state, name = _ref.name;
        state.modifiersData[name] = computeOffsets({
            reference: state.rects.reference,
            element: state.rects.popper,
            strategy: "absolute",
            placement: state.placement
        });
    }
    var popperOffsets$1 = {
        name: "popperOffsets",
        enabled: true,
        phase: "read",
        fn: popperOffsets,
        data: {}
    };
    function getAltAxis(axis) {
        return axis === "x" ? "y" : "x";
    }
    function preventOverflow(_ref) {
        var state = _ref.state, options = _ref.options, name = _ref.name;
        var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
        var overflow = detectOverflow(state, {
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding,
            altBoundary: altBoundary
        });
        var basePlacement = getBasePlacement(state.placement);
        var variation = getVariation(state.placement);
        var isBasePlacement = !variation;
        var mainAxis = getMainAxisFromPlacement(basePlacement);
        var altAxis = getAltAxis(mainAxis);
        var popperOffsets = state.modifiersData.popperOffsets;
        var referenceRect = state.rects.reference;
        var popperRect = state.rects.popper;
        var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
            placement: state.placement
        })) : tetherOffset;
        var data = {
            x: 0,
            y: 0
        };
        if (!popperOffsets) {
            return;
        }
        if (checkMainAxis || checkAltAxis) {
            var mainSide = mainAxis === "y" ? top : left;
            var altSide = mainAxis === "y" ? bottom : right;
            var len = mainAxis === "y" ? "height" : "width";
            var offset = popperOffsets[mainAxis];
            var min$1 = popperOffsets[mainAxis] + overflow[mainSide];
            var max$1 = popperOffsets[mainAxis] - overflow[altSide];
            var additive = tether ? -popperRect[len] / 2 : 0;
            var minLen = variation === start ? referenceRect[len] : popperRect[len];
            var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
            var arrowElement = state.elements.arrow;
            var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
                width: 0,
                height: 0
            };
            var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
            var arrowPaddingMin = arrowPaddingObject[mainSide];
            var arrowPaddingMax = arrowPaddingObject[altSide];
            var arrowLen = within(0, referenceRect[len], arrowRect[len]);
            var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
            var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
            var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
            var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
            var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
            var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
            var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;
            if (checkMainAxis) {
                var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
                popperOffsets[mainAxis] = preventedOffset;
                data[mainAxis] = preventedOffset - offset;
            }
            if (checkAltAxis) {
                var _mainSide = mainAxis === "x" ? top : left;
                var _altSide = mainAxis === "x" ? bottom : right;
                var _offset = popperOffsets[altAxis];
                var _min = _offset + overflow[_mainSide];
                var _max = _offset - overflow[_altSide];
                var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);
                popperOffsets[altAxis] = _preventedOffset;
                data[altAxis] = _preventedOffset - _offset;
            }
        }
        state.modifiersData[name] = data;
    }
    var preventOverflow$1 = {
        name: "preventOverflow",
        enabled: true,
        phase: "main",
        fn: preventOverflow,
        requiresIfExists: [ "offset" ]
    };
    function getHTMLElementScroll(element) {
        return {
            scrollLeft: element.scrollLeft,
            scrollTop: element.scrollTop
        };
    }
    function getNodeScroll(node) {
        if (node === getWindow(node) || !isHTMLElement(node)) {
            return getWindowScroll(node);
        } else {
            return getHTMLElementScroll(node);
        }
    }
    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
        if (isFixed === void 0) {
            isFixed = false;
        }
        var documentElement = getDocumentElement(offsetParent);
        var rect = getBoundingClientRect(elementOrVirtualElement);
        var isOffsetParentAnElement = isHTMLElement(offsetParent);
        var scroll = {
            scrollLeft: 0,
            scrollTop: 0
        };
        var offsets = {
            x: 0,
            y: 0
        };
        if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
            if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
                scroll = getNodeScroll(offsetParent);
            }
            if (isHTMLElement(offsetParent)) {
                offsets = getBoundingClientRect(offsetParent);
                offsets.x += offsetParent.clientLeft;
                offsets.y += offsetParent.clientTop;
            } else if (documentElement) {
                offsets.x = getWindowScrollBarX(documentElement);
            }
        }
        return {
            x: rect.left + scroll.scrollLeft - offsets.x,
            y: rect.top + scroll.scrollTop - offsets.y,
            width: rect.width,
            height: rect.height
        };
    }
    function order(modifiers) {
        var map = new Map();
        var visited = new Set();
        var result = [];
        modifiers.forEach(function(modifier) {
            map.set(modifier.name, modifier);
        });
        function sort(modifier) {
            visited.add(modifier.name);
            var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
            requires.forEach(function(dep) {
                if (!visited.has(dep)) {
                    var depModifier = map.get(dep);
                    if (depModifier) {
                        sort(depModifier);
                    }
                }
            });
            result.push(modifier);
        }
        modifiers.forEach(function(modifier) {
            if (!visited.has(modifier.name)) {
                sort(modifier);
            }
        });
        return result;
    }
    function orderModifiers(modifiers) {
        var orderedModifiers = order(modifiers);
        return modifierPhases.reduce(function(acc, phase) {
            return acc.concat(orderedModifiers.filter(function(modifier) {
                return modifier.phase === phase;
            }));
        }, []);
    }
    function debounce(fn) {
        var pending;
        return function() {
            if (!pending) {
                pending = new Promise(function(resolve) {
                    Promise.resolve().then(function() {
                        pending = undefined;
                        resolve(fn());
                    });
                });
            }
            return pending;
        };
    }
    function mergeByName(modifiers) {
        var merged = modifiers.reduce(function(merged, current) {
            var existing = merged[current.name];
            merged[current.name] = existing ? Object.assign({}, existing, current, {
                options: Object.assign({}, existing.options, current.options),
                data: Object.assign({}, existing.data, current.data)
            }) : current;
            return merged;
        }, {});
        return Object.keys(merged).map(function(key) {
            return merged[key];
        });
    }
    var DEFAULT_OPTIONS = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
    };
    function areValidElements() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }
        return !args.some(function(element) {
            return !(element && typeof element.getBoundingClientRect === "function");
        });
    }
    function popperGenerator(generatorOptions) {
        if (generatorOptions === void 0) {
            generatorOptions = {};
        }
        var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
        return function createPopper(reference, popper, options) {
            if (options === void 0) {
                options = defaultOptions;
            }
            var state = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
                modifiersData: {},
                elements: {
                    reference: reference,
                    popper: popper
                },
                attributes: {},
                styles: {}
            };
            var effectCleanupFns = [];
            var isDestroyed = false;
            var instance = {
                state: state,
                setOptions: function setOptions(options) {
                    cleanupModifierEffects();
                    state.options = Object.assign({}, defaultOptions, state.options, options);
                    state.scrollParents = {
                        reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
                        popper: listScrollParents(popper)
                    };
                    var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers)));
                    state.orderedModifiers = orderedModifiers.filter(function(m) {
                        return m.enabled;
                    });
                    runModifierEffects();
                    return instance.update();
                },
                forceUpdate: function forceUpdate() {
                    if (isDestroyed) {
                        return;
                    }
                    var _state$elements = state.elements, reference = _state$elements.reference, popper = _state$elements.popper;
                    if (!areValidElements(reference, popper)) {
                        return;
                    }
                    state.rects = {
                        reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === "fixed"),
                        popper: getLayoutRect(popper)
                    };
                    state.reset = false;
                    state.placement = state.options.placement;
                    state.orderedModifiers.forEach(function(modifier) {
                        return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                    });
                    for (var index = 0; index < state.orderedModifiers.length; index++) {
                        if (state.reset === true) {
                            state.reset = false;
                            index = -1;
                            continue;
                        }
                        var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                        if (typeof fn === "function") {
                            state = fn({
                                state: state,
                                options: _options,
                                name: name,
                                instance: instance
                            }) || state;
                        }
                    }
                },
                update: debounce(function() {
                    return new Promise(function(resolve) {
                        instance.forceUpdate();
                        resolve(state);
                    });
                }),
                destroy: function destroy() {
                    cleanupModifierEffects();
                    isDestroyed = true;
                }
            };
            if (!areValidElements(reference, popper)) {
                return instance;
            }
            instance.setOptions(options).then(function(state) {
                if (!isDestroyed && options.onFirstUpdate) {
                    options.onFirstUpdate(state);
                }
            });
            function runModifierEffects() {
                state.orderedModifiers.forEach(function(_ref3) {
                    var name = _ref3.name, _ref3$options = _ref3.options, options = _ref3$options === void 0 ? {} : _ref3$options, effect = _ref3.effect;
                    if (typeof effect === "function") {
                        var cleanupFn = effect({
                            state: state,
                            name: name,
                            instance: instance,
                            options: options
                        });
                        var noopFn = function noopFn() {};
                        effectCleanupFns.push(cleanupFn || noopFn);
                    }
                });
            }
            function cleanupModifierEffects() {
                effectCleanupFns.forEach(function(fn) {
                    return fn();
                });
                effectCleanupFns = [];
            }
            return instance;
        };
    }
    var createPopper$2 = popperGenerator();
    var defaultModifiers$1 = [ eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1 ];
    var createPopper$1 = popperGenerator({
        defaultModifiers: defaultModifiers$1
    });
    var defaultModifiers = [ eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$2 ];
    var createPopper = popperGenerator({
        defaultModifiers: defaultModifiers
    });
    var Popper = Object.freeze({
        __proto__: null,
        popperGenerator: popperGenerator,
        detectOverflow: detectOverflow,
        createPopperBase: createPopper$2,
        createPopper: createPopper,
        createPopperLite: createPopper$1,
        top: top,
        bottom: bottom,
        right: right,
        left: left,
        auto: auto,
        basePlacements: basePlacements,
        start: start,
        end: end,
        clippingParents: clippingParents,
        viewport: viewport,
        popper: popper,
        reference: reference,
        variationPlacements: variationPlacements,
        placements: placements,
        beforeRead: beforeRead,
        read: read,
        afterRead: afterRead,
        beforeMain: beforeMain,
        main: main,
        afterMain: afterMain,
        beforeWrite: beforeWrite,
        write: write,
        afterWrite: afterWrite,
        modifierPhases: modifierPhases,
        applyStyles: applyStyles$1,
        arrow: arrow$1,
        computeStyles: computeStyles$1,
        eventListeners: eventListeners,
        flip: flip$1,
        hide: hide$2,
        offset: offset$1,
        popperOffsets: popperOffsets$1,
        preventOverflow: preventOverflow$1
    });
    const NAME$8 = "dropdown";
    const DATA_KEY$7 = "bs.dropdown";
    const EVENT_KEY$7 = `.${DATA_KEY$7}`;
    const DATA_API_KEY$4 = ".data-api";
    const ESCAPE_KEY$2 = "Escape";
    const SPACE_KEY = "Space";
    const TAB_KEY = "Tab";
    const ARROW_UP_KEY = "ArrowUp";
    const ARROW_DOWN_KEY = "ArrowDown";
    const RIGHT_MOUSE_BUTTON = 2;
    const REGEXP_KEYDOWN = new RegExp(`${ARROW_UP_KEY}|${ARROW_DOWN_KEY}|${ESCAPE_KEY$2}`);
    const EVENT_HIDE$4 = `hide${EVENT_KEY$7}`;
    const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$7}`;
    const EVENT_SHOW$4 = `show${EVENT_KEY$7}`;
    const EVENT_SHOWN$4 = `shown${EVENT_KEY$7}`;
    const EVENT_CLICK = `click${EVENT_KEY$7}`;
    const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
    const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$7}${DATA_API_KEY$4}`;
    const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$7}${DATA_API_KEY$4}`;
    const CLASS_NAME_SHOW$7 = "show";
    const CLASS_NAME_DROPUP = "dropup";
    const CLASS_NAME_DROPEND = "dropend";
    const CLASS_NAME_DROPSTART = "dropstart";
    const CLASS_NAME_NAVBAR = "navbar";
    const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]';
    const SELECTOR_MENU = ".dropdown-menu";
    const SELECTOR_NAVBAR_NAV = ".navbar-nav";
    const SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
    const PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
    const PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
    const PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
    const PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
    const PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
    const PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
    const Default$7 = {
        offset: [ 0, 2 ],
        boundary: "clippingParents",
        reference: "toggle",
        display: "dynamic",
        popperConfig: null,
        autoClose: true
    };
    const DefaultType$7 = {
        offset: "(array|string|function)",
        boundary: "(string|element)",
        reference: "(string|element|object)",
        display: "string",
        popperConfig: "(null|object|function)",
        autoClose: "(boolean|string)"
    };
    class Dropdown extends BaseComponent {
        constructor(element, config) {
            super(element);
            this._popper = null;
            this._config = this._getConfig(config);
            this._menu = this._getMenuElement();
            this._inNavbar = this._detectNavbar();
            this._addEventListeners();
        }
        static get Default() {
            return Default$7;
        }
        static get DefaultType() {
            return DefaultType$7;
        }
        static get DATA_KEY() {
            return DATA_KEY$7;
        }
        toggle() {
            if (isDisabled(this._element)) {
                return;
            }
            const isActive = this._element.classList.contains(CLASS_NAME_SHOW$7);
            if (isActive) {
                this.hide();
                return;
            }
            this.show();
        }
        show() {
            if (isDisabled(this._element) || this._menu.classList.contains(CLASS_NAME_SHOW$7)) {
                return;
            }
            const parent = Dropdown.getParentFromElement(this._element);
            const relatedTarget = {
                relatedTarget: this._element
            };
            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, relatedTarget);
            if (showEvent.defaultPrevented) {
                return;
            }
            if (this._inNavbar) {
                Manipulator.setDataAttribute(this._menu, "popper", "none");
            } else {
                if (typeof Popper === "undefined") {
                    throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
                }
                let referenceElement = this._element;
                if (this._config.reference === "parent") {
                    referenceElement = parent;
                } else if (isElement$1(this._config.reference)) {
                    referenceElement = this._config.reference;
                    if (typeof this._config.reference.jquery !== "undefined") {
                        referenceElement = this._config.reference[0];
                    }
                } else if (typeof this._config.reference === "object") {
                    referenceElement = this._config.reference;
                }
                const popperConfig = this._getPopperConfig();
                const isDisplayStatic = popperConfig.modifiers.find(modifier => modifier.name === "applyStyles" && modifier.enabled === false);
                this._popper = createPopper(referenceElement, this._menu, popperConfig);
                if (isDisplayStatic) {
                    Manipulator.setDataAttribute(this._menu, "popper", "static");
                }
            }
            if ("ontouchstart" in document.documentElement && !parent.closest(SELECTOR_NAVBAR_NAV)) {
                [].concat(...document.body.children).forEach(elem => EventHandler.on(elem, "mouseover", noop));
            }
            this._element.focus();
            this._element.setAttribute("aria-expanded", true);
            this._menu.classList.toggle(CLASS_NAME_SHOW$7);
            this._element.classList.toggle(CLASS_NAME_SHOW$7);
            EventHandler.trigger(this._element, EVENT_SHOWN$4, relatedTarget);
        }
        hide() {
            if (isDisabled(this._element) || !this._menu.classList.contains(CLASS_NAME_SHOW$7)) {
                return;
            }
            const relatedTarget = {
                relatedTarget: this._element
            };
            this._completeHide(relatedTarget);
        }
        dispose() {
            this._menu = null;
            if (this._popper) {
                this._popper.destroy();
                this._popper = null;
            }
            super.dispose();
        }
        update() {
            this._inNavbar = this._detectNavbar();
            if (this._popper) {
                this._popper.update();
            }
        }
        _addEventListeners() {
            EventHandler.on(this._element, EVENT_CLICK, event => {
                event.preventDefault();
                this.toggle();
            });
        }
        _completeHide(relatedTarget) {
            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4, relatedTarget);
            if (hideEvent.defaultPrevented) {
                return;
            }
            if ("ontouchstart" in document.documentElement) {
                [].concat(...document.body.children).forEach(elem => EventHandler.off(elem, "mouseover", noop));
            }
            if (this._popper) {
                this._popper.destroy();
            }
            this._menu.classList.remove(CLASS_NAME_SHOW$7);
            this._element.classList.remove(CLASS_NAME_SHOW$7);
            this._element.setAttribute("aria-expanded", "false");
            Manipulator.removeDataAttribute(this._menu, "popper");
            EventHandler.trigger(this._element, EVENT_HIDDEN$4, relatedTarget);
        }
        _getConfig(config) {
            config = {
                ...this.constructor.Default,
                ...Manipulator.getDataAttributes(this._element),
                ...config
            };
            typeCheckConfig(NAME$8, config, this.constructor.DefaultType);
            if (typeof config.reference === "object" && !isElement$1(config.reference) && typeof config.reference.getBoundingClientRect !== "function") {
                throw new TypeError(`${NAME$8.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
            }
            return config;
        }
        _getMenuElement() {
            return SelectorEngine.next(this._element, SELECTOR_MENU)[0];
        }
        _getPlacement() {
            const parentDropdown = this._element.parentNode;
            if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
                return PLACEMENT_RIGHT;
            }
            if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
                return PLACEMENT_LEFT;
            }
            const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
            if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
                return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
            }
            return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
        }
        _detectNavbar() {
            return this._element.closest(`.${CLASS_NAME_NAVBAR}`) !== null;
        }
        _getOffset() {
            const {
                offset
            } = this._config;
            if (typeof offset === "string") {
                return offset.split(",").map(val => Number.parseInt(val, 10));
            }
            if (typeof offset === "function") {
                return popperData => offset(popperData, this._element);
            }
            return offset;
        }
        _getPopperConfig() {
            const defaultBsPopperConfig = {
                placement: this._getPlacement(),
                modifiers: [ {
                    name: "preventOverflow",
                    options: {
                        boundary: this._config.boundary
                    }
                }, {
                    name: "offset",
                    options: {
                        offset: this._getOffset()
                    }
                } ]
            };
            if (this._config.display === "static") {
                defaultBsPopperConfig.modifiers = [ {
                    name: "applyStyles",
                    enabled: false
                } ];
            }
            return {
                ...defaultBsPopperConfig,
                ...typeof this._config.popperConfig === "function" ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig
            };
        }
        _selectMenuItem(event) {
            const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(isVisible);
            if (!items.length) {
                return;
            }
            let index = items.indexOf(event.target);
            if (event.key === ARROW_UP_KEY && index > 0) {
                index--;
            }
            if (event.key === ARROW_DOWN_KEY && index < items.length - 1) {
                index++;
            }
            index = index === -1 ? 0 : index;
            items[index].focus();
        }
        static dropdownInterface(element, config) {
            let data = Data.get(element, DATA_KEY$7);
            const _config = typeof config === "object" ? config : null;
            if (!data) {
                data = new Dropdown(element, _config);
            }
            if (typeof config === "string") {
                if (typeof data[config] === "undefined") {
                    throw new TypeError(`No method named "${config}"`);
                }
                data[config]();
            }
        }
        static jQueryInterface(config) {
            return this.each(function() {
                Dropdown.dropdownInterface(this, config);
            });
        }
        static clearMenus(event) {
            if (event) {
                if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY) {
                    return;
                }
                if (/input|select|option|textarea|form/i.test(event.target.tagName)) {
                    return;
                }
            }
            const toggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE$3);
            for (let i = 0, len = toggles.length; i < len; i++) {
                const context = Data.get(toggles[i], DATA_KEY$7);
                if (!context || context._config.autoClose === false) {
                    continue;
                }
                if (!context._element.classList.contains(CLASS_NAME_SHOW$7)) {
                    continue;
                }
                const relatedTarget = {
                    relatedTarget: context._element
                };
                if (event) {
                    const composedPath = event.composedPath();
                    const isMenuTarget = composedPath.includes(context._menu);
                    if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
                        continue;
                    }
                    if (event.type === "keyup" && event.key === TAB_KEY && context._menu.contains(event.target)) {
                        continue;
                    }
                    if (event.type === "click") {
                        relatedTarget.clickEvent = event;
                    }
                }
                context._completeHide(relatedTarget);
            }
        }
        static getParentFromElement(element) {
            return getElementFromSelector(element) || element.parentNode;
        }
        static dataApiKeydownHandler(event) {
            if (/input|textarea/i.test(event.target.tagName) ? event.key === SPACE_KEY || event.key !== ESCAPE_KEY$2 && (event.key !== ARROW_DOWN_KEY && event.key !== ARROW_UP_KEY || event.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(event.key)) {
                return;
            }
            const isActive = this.classList.contains(CLASS_NAME_SHOW$7);
            if (!isActive && event.key === ESCAPE_KEY$2) {
                return;
            }
            event.preventDefault();
            event.stopPropagation();
            if (isDisabled(this)) {
                return;
            }
            const getToggleButton = () => this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0];
            if (event.key === ESCAPE_KEY$2) {
                getToggleButton().focus();
                Dropdown.clearMenus();
                return;
            }
            if (!isActive && (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY)) {
                getToggleButton().click();
                return;
            }
            if (!isActive || event.key === SPACE_KEY) {
                Dropdown.clearMenus();
                return;
            }
            Dropdown.getInstance(getToggleButton())._selectMenuItem(event);
        }
    }
    EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
    EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
    EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
    EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
    EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
        event.preventDefault();
        Dropdown.dropdownInterface(this);
    });
    defineJQueryPlugin(NAME$8, Dropdown);
    const SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
    const SELECTOR_STICKY_CONTENT = ".sticky-top";
    const getWidth = () => {
        const documentWidth = document.documentElement.clientWidth;
        return Math.abs(window.innerWidth - documentWidth);
    };
    const hide = (width = getWidth()) => {
        _disableOverFlow();
        _setElementAttributes("body", "paddingRight", calculatedValue => calculatedValue + width);
        _setElementAttributes(SELECTOR_FIXED_CONTENT, "paddingRight", calculatedValue => calculatedValue + width);
        _setElementAttributes(SELECTOR_STICKY_CONTENT, "marginRight", calculatedValue => calculatedValue - width);
    };
    const _disableOverFlow = () => {
        const actualValue = document.body.style.overflow;
        if (actualValue) {
            Manipulator.setDataAttribute(document.body, "overflow", actualValue);
        }
        document.body.style.overflow = "hidden";
    };
    const _setElementAttributes = (selector, styleProp, callback) => {
        const scrollbarWidth = getWidth();
        SelectorEngine.find(selector).forEach(element => {
            if (element !== document.body && window.innerWidth > element.clientWidth + scrollbarWidth) {
                return;
            }
            const actualValue = element.style[styleProp];
            const calculatedValue = window.getComputedStyle(element)[styleProp];
            Manipulator.setDataAttribute(element, styleProp, actualValue);
            element.style[styleProp] = `${callback(Number.parseFloat(calculatedValue))}px`;
        });
    };
    const reset = () => {
        _resetElementAttributes("body", "overflow");
        _resetElementAttributes("body", "paddingRight");
        _resetElementAttributes(SELECTOR_FIXED_CONTENT, "paddingRight");
        _resetElementAttributes(SELECTOR_STICKY_CONTENT, "marginRight");
    };
    const _resetElementAttributes = (selector, styleProp) => {
        SelectorEngine.find(selector).forEach(element => {
            const value = Manipulator.getDataAttribute(element, styleProp);
            if (typeof value === "undefined") {
                element.style.removeProperty(styleProp);
            } else {
                Manipulator.removeDataAttribute(element, styleProp);
                element.style[styleProp] = value;
            }
        });
    };
    const Default$6 = {
        isVisible: true,
        isAnimated: false,
        rootElement: document.body,
        clickCallback: null
    };
    const DefaultType$6 = {
        isVisible: "boolean",
        isAnimated: "boolean",
        rootElement: "element",
        clickCallback: "(function|null)"
    };
    const NAME$7 = "backdrop";
    const CLASS_NAME_BACKDROP = "modal-backdrop";
    const CLASS_NAME_FADE$5 = "fade";
    const CLASS_NAME_SHOW$6 = "show";
    const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$7}`;
    class Backdrop {
        constructor(config) {
            this._config = this._getConfig(config);
            this._isAppended = false;
            this._element = null;
        }
        show(callback) {
            if (!this._config.isVisible) {
                execute(callback);
                return;
            }
            this._append();
            if (this._config.isAnimated) {
                reflow(this._getElement());
            }
            this._getElement().classList.add(CLASS_NAME_SHOW$6);
            this._emulateAnimation(() => {
                execute(callback);
            });
        }
        hide(callback) {
            if (!this._config.isVisible) {
                execute(callback);
                return;
            }
            this._getElement().classList.remove(CLASS_NAME_SHOW$6);
            this._emulateAnimation(() => {
                this.dispose();
                execute(callback);
            });
        }
        _getElement() {
            if (!this._element) {
                const backdrop = document.createElement("div");
                backdrop.className = CLASS_NAME_BACKDROP;
                if (this._config.isAnimated) {
                    backdrop.classList.add(CLASS_NAME_FADE$5);
                }
                this._element = backdrop;
            }
            return this._element;
        }
        _getConfig(config) {
            config = {
                ...Default$6,
                ...typeof config === "object" ? config : {}
            };
            typeCheckConfig(NAME$7, config, DefaultType$6);
            return config;
        }
        _append() {
            if (this._isAppended) {
                return;
            }
            this._config.rootElement.appendChild(this._getElement());
            EventHandler.on(this._getElement(), EVENT_MOUSEDOWN, () => {
                execute(this._config.clickCallback);
            });
            this._isAppended = true;
        }
        dispose() {
            if (!this._isAppended) {
                return;
            }
            EventHandler.off(this._element, EVENT_MOUSEDOWN);
            this._getElement().parentNode.removeChild(this._element);
            this._isAppended = false;
        }
        _emulateAnimation(callback) {
            if (!this._config.isAnimated) {
                execute(callback);
                return;
            }
            const backdropTransitionDuration = getTransitionDurationFromElement(this._getElement());
            EventHandler.one(this._getElement(), "transitionend", () => execute(callback));
            emulateTransitionEnd(this._getElement(), backdropTransitionDuration);
        }
    }
    const NAME$6 = "modal";
    const DATA_KEY$6 = "bs.modal";
    const EVENT_KEY$6 = `.${DATA_KEY$6}`;
    const DATA_API_KEY$3 = ".data-api";
    const ESCAPE_KEY$1 = "Escape";
    const Default$5 = {
        backdrop: true,
        keyboard: true,
        focus: true
    };
    const DefaultType$5 = {
        backdrop: "(boolean|string)",
        keyboard: "boolean",
        focus: "boolean"
    };
    const EVENT_HIDE$3 = `hide${EVENT_KEY$6}`;
    const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$6}`;
    const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$6}`;
    const EVENT_SHOW$3 = `show${EVENT_KEY$6}`;
    const EVENT_SHOWN$3 = `shown${EVENT_KEY$6}`;
    const EVENT_FOCUSIN$1 = `focusin${EVENT_KEY$6}`;
    const EVENT_RESIZE = `resize${EVENT_KEY$6}`;
    const EVENT_CLICK_DISMISS$2 = `click.dismiss${EVENT_KEY$6}`;
    const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$6}`;
    const EVENT_MOUSEUP_DISMISS = `mouseup.dismiss${EVENT_KEY$6}`;
    const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$6}`;
    const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
    const CLASS_NAME_OPEN = "modal-open";
    const CLASS_NAME_FADE$4 = "fade";
    const CLASS_NAME_SHOW$5 = "show";
    const CLASS_NAME_STATIC = "modal-static";
    const SELECTOR_DIALOG = ".modal-dialog";
    const SELECTOR_MODAL_BODY = ".modal-body";
    const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
    const SELECTOR_DATA_DISMISS$2 = '[data-bs-dismiss="modal"]';
    class Modal extends BaseComponent {
        constructor(element, config) {
            super(element);
            this._config = this._getConfig(config);
            this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
            this._backdrop = this._initializeBackDrop();
            this._isShown = false;
            this._ignoreBackdropClick = false;
            this._isTransitioning = false;
        }
        static get Default() {
            return Default$5;
        }
        static get DATA_KEY() {
            return DATA_KEY$6;
        }
        toggle(relatedTarget) {
            return this._isShown ? this.hide() : this.show(relatedTarget);
        }
        show(relatedTarget) {
            if (this._isShown || this._isTransitioning) {
                return;
            }
            if (this._isAnimated()) {
                this._isTransitioning = true;
            }
            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
                relatedTarget: relatedTarget
            });
            if (this._isShown || showEvent.defaultPrevented) {
                return;
            }
            this._isShown = true;
            hide();
            document.body.classList.add(CLASS_NAME_OPEN);
            this._adjustDialog();
            this._setEscapeEvent();
            this._setResizeEvent();
            EventHandler.on(this._element, EVENT_CLICK_DISMISS$2, SELECTOR_DATA_DISMISS$2, event => this.hide(event));
            EventHandler.on(this._dialog, EVENT_MOUSEDOWN_DISMISS, () => {
                EventHandler.one(this._element, EVENT_MOUSEUP_DISMISS, event => {
                    if (event.target === this._element) {
                        this._ignoreBackdropClick = true;
                    }
                });
            });
            this._showBackdrop(() => this._showElement(relatedTarget));
        }
        hide(event) {
            if (event) {
                event.preventDefault();
            }
            if (!this._isShown || this._isTransitioning) {
                return;
            }
            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
            if (hideEvent.defaultPrevented) {
                return;
            }
            this._isShown = false;
            const isAnimated = this._isAnimated();
            if (isAnimated) {
                this._isTransitioning = true;
            }
            this._setEscapeEvent();
            this._setResizeEvent();
            EventHandler.off(document, EVENT_FOCUSIN$1);
            this._element.classList.remove(CLASS_NAME_SHOW$5);
            EventHandler.off(this._element, EVENT_CLICK_DISMISS$2);
            EventHandler.off(this._dialog, EVENT_MOUSEDOWN_DISMISS);
            if (isAnimated) {
                const transitionDuration = getTransitionDurationFromElement(this._element);
                EventHandler.one(this._element, "transitionend", event => this._hideModal(event));
                emulateTransitionEnd(this._element, transitionDuration);
            } else {
                this._hideModal();
            }
        }
        dispose() {
            [ window, this._dialog ].forEach(htmlElement => EventHandler.off(htmlElement, EVENT_KEY$6));
            super.dispose();
            EventHandler.off(document, EVENT_FOCUSIN$1);
            this._config = null;
            this._dialog = null;
            this._backdrop.dispose();
            this._backdrop = null;
            this._isShown = null;
            this._ignoreBackdropClick = null;
            this._isTransitioning = null;
        }
        handleUpdate() {
            this._adjustDialog();
        }
        _initializeBackDrop() {
            return new Backdrop({
                isVisible: Boolean(this._config.backdrop),
                isAnimated: this._isAnimated()
            });
        }
        _getConfig(config) {
            config = {
                ...Default$5,
                ...Manipulator.getDataAttributes(this._element),
                ...config
            };
            typeCheckConfig(NAME$6, config, DefaultType$5);
            return config;
        }
        _showElement(relatedTarget) {
            const isAnimated = this._isAnimated();
            const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
            if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
                document.body.appendChild(this._element);
            }
            this._element.style.display = "block";
            this._element.removeAttribute("aria-hidden");
            this._element.setAttribute("aria-modal", true);
            this._element.setAttribute("role", "dialog");
            this._element.scrollTop = 0;
            if (modalBody) {
                modalBody.scrollTop = 0;
            }
            if (isAnimated) {
                reflow(this._element);
            }
            this._element.classList.add(CLASS_NAME_SHOW$5);
            if (this._config.focus) {
                this._enforceFocus();
            }
            const transitionComplete = () => {
                if (this._config.focus) {
                    this._element.focus();
                }
                this._isTransitioning = false;
                EventHandler.trigger(this._element, EVENT_SHOWN$3, {
                    relatedTarget: relatedTarget
                });
            };
            if (isAnimated) {
                const transitionDuration = getTransitionDurationFromElement(this._dialog);
                EventHandler.one(this._dialog, "transitionend", transitionComplete);
                emulateTransitionEnd(this._dialog, transitionDuration);
            } else {
                transitionComplete();
            }
        }
        _enforceFocus() {
            EventHandler.off(document, EVENT_FOCUSIN$1);
            EventHandler.on(document, EVENT_FOCUSIN$1, event => {
                if (document !== event.target && this._element !== event.target && !this._element.contains(event.target)) {
                    this._element.focus();
                }
            });
        }
        _setEscapeEvent() {
            if (this._isShown) {
                EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {
                    if (this._config.keyboard && event.key === ESCAPE_KEY$1) {
                        event.preventDefault();
                        this.hide();
                    } else if (!this._config.keyboard && event.key === ESCAPE_KEY$1) {
                        this._triggerBackdropTransition();
                    }
                });
            } else {
                EventHandler.off(this._element, EVENT_KEYDOWN_DISMISS$1);
            }
        }
        _setResizeEvent() {
            if (this._isShown) {
                EventHandler.on(window, EVENT_RESIZE, () => this._adjustDialog());
            } else {
                EventHandler.off(window, EVENT_RESIZE);
            }
        }
        _hideModal() {
            this._element.style.display = "none";
            this._element.setAttribute("aria-hidden", true);
            this._element.removeAttribute("aria-modal");
            this._element.removeAttribute("role");
            this._isTransitioning = false;
            this._backdrop.hide(() => {
                document.body.classList.remove(CLASS_NAME_OPEN);
                this._resetAdjustments();
                reset();
                EventHandler.trigger(this._element, EVENT_HIDDEN$3);
            });
        }
        _showBackdrop(callback) {
            EventHandler.on(this._element, EVENT_CLICK_DISMISS$2, event => {
                if (this._ignoreBackdropClick) {
                    this._ignoreBackdropClick = false;
                    return;
                }
                if (event.target !== event.currentTarget) {
                    return;
                }
                if (this._config.backdrop === true) {
                    this.hide();
                } else if (this._config.backdrop === "static") {
                    this._triggerBackdropTransition();
                }
            });
            this._backdrop.show(callback);
        }
        _isAnimated() {
            return this._element.classList.contains(CLASS_NAME_FADE$4);
        }
        _triggerBackdropTransition() {
            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
            if (hideEvent.defaultPrevented) {
                return;
            }
            const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
            if (!isModalOverflowing) {
                this._element.style.overflowY = "hidden";
            }
            this._element.classList.add(CLASS_NAME_STATIC);
            const modalTransitionDuration = getTransitionDurationFromElement(this._dialog);
            EventHandler.off(this._element, "transitionend");
            EventHandler.one(this._element, "transitionend", () => {
                this._element.classList.remove(CLASS_NAME_STATIC);
                if (!isModalOverflowing) {
                    EventHandler.one(this._element, "transitionend", () => {
                        this._element.style.overflowY = "";
                    });
                    emulateTransitionEnd(this._element, modalTransitionDuration);
                }
            });
            emulateTransitionEnd(this._element, modalTransitionDuration);
            this._element.focus();
        }
        _adjustDialog() {
            const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
            const scrollbarWidth = getWidth();
            const isBodyOverflowing = scrollbarWidth > 0;
            if (!isBodyOverflowing && isModalOverflowing && !isRTL() || isBodyOverflowing && !isModalOverflowing && isRTL()) {
                this._element.style.paddingLeft = `${scrollbarWidth}px`;
            }
            if (isBodyOverflowing && !isModalOverflowing && !isRTL() || !isBodyOverflowing && isModalOverflowing && isRTL()) {
                this._element.style.paddingRight = `${scrollbarWidth}px`;
            }
        }
        _resetAdjustments() {
            this._element.style.paddingLeft = "";
            this._element.style.paddingRight = "";
        }
        static jQueryInterface(config, relatedTarget) {
            return this.each(function() {
                const data = Modal.getInstance(this) || new Modal(this, typeof config === "object" ? config : {});
                if (typeof config !== "string") {
                    return;
                }
                if (typeof data[config] === "undefined") {
                    throw new TypeError(`No method named "${config}"`);
                }
                data[config](relatedTarget);
            });
        }
    }
    EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
        const target = getElementFromSelector(this);
        if ([ "A", "AREA" ].includes(this.tagName)) {
            event.preventDefault();
        }
        EventHandler.one(target, EVENT_SHOW$3, showEvent => {
            if (showEvent.defaultPrevented) {
                return;
            }
            EventHandler.one(target, EVENT_HIDDEN$3, () => {
                if (isVisible(this)) {
                    this.focus();
                }
            });
        });
        const data = Modal.getInstance(target) || new Modal(target);
        data.toggle(this);
    });
    defineJQueryPlugin(NAME$6, Modal);
    const NAME$5 = "offcanvas";
    const DATA_KEY$5 = "bs.offcanvas";
    const EVENT_KEY$5 = `.${DATA_KEY$5}`;
    const DATA_API_KEY$2 = ".data-api";
    const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$5}${DATA_API_KEY$2}`;
    const ESCAPE_KEY = "Escape";
    const Default$4 = {
        backdrop: true,
        keyboard: true,
        scroll: false
    };
    const DefaultType$4 = {
        backdrop: "boolean",
        keyboard: "boolean",
        scroll: "boolean"
    };
    const CLASS_NAME_SHOW$4 = "show";
    const OPEN_SELECTOR = ".offcanvas.show";
    const EVENT_SHOW$2 = `show${EVENT_KEY$5}`;
    const EVENT_SHOWN$2 = `shown${EVENT_KEY$5}`;
    const EVENT_HIDE$2 = `hide${EVENT_KEY$5}`;
    const EVENT_HIDDEN$2 = `hidden${EVENT_KEY$5}`;
    const EVENT_FOCUSIN = `focusin${EVENT_KEY$5}`;
    const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$5}${DATA_API_KEY$2}`;
    const EVENT_CLICK_DISMISS$1 = `click.dismiss${EVENT_KEY$5}`;
    const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$5}`;
    const SELECTOR_DATA_DISMISS$1 = '[data-bs-dismiss="offcanvas"]';
    const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
    class Offcanvas extends BaseComponent {
        constructor(element, config) {
            super(element);
            this._config = this._getConfig(config);
            this._isShown = false;
            this._backdrop = this._initializeBackDrop();
            this._addEventListeners();
        }
        static get Default() {
            return Default$4;
        }
        static get DATA_KEY() {
            return DATA_KEY$5;
        }
        toggle(relatedTarget) {
            return this._isShown ? this.hide() : this.show(relatedTarget);
        }
        show(relatedTarget) {
            if (this._isShown) {
                return;
            }
            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$2, {
                relatedTarget: relatedTarget
            });
            if (showEvent.defaultPrevented) {
                return;
            }
            this._isShown = true;
            this._element.style.visibility = "visible";
            this._backdrop.show();
            if (!this._config.scroll) {
                hide();
                this._enforceFocusOnElement(this._element);
            }
            this._element.removeAttribute("aria-hidden");
            this._element.setAttribute("aria-modal", true);
            this._element.setAttribute("role", "dialog");
            this._element.classList.add(CLASS_NAME_SHOW$4);
            const completeCallBack = () => {
                EventHandler.trigger(this._element, EVENT_SHOWN$2, {
                    relatedTarget: relatedTarget
                });
            };
            const transitionDuration = getTransitionDurationFromElement(this._element);
            EventHandler.one(this._element, "transitionend", completeCallBack);
            emulateTransitionEnd(this._element, transitionDuration);
        }
        hide() {
            if (!this._isShown) {
                return;
            }
            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$2);
            if (hideEvent.defaultPrevented) {
                return;
            }
            EventHandler.off(document, EVENT_FOCUSIN);
            this._element.blur();
            this._isShown = false;
            this._element.classList.remove(CLASS_NAME_SHOW$4);
            this._backdrop.hide();
            const completeCallback = () => {
                this._element.setAttribute("aria-hidden", true);
                this._element.removeAttribute("aria-modal");
                this._element.removeAttribute("role");
                this._element.style.visibility = "hidden";
                if (!this._config.scroll) {
                    reset();
                }
                EventHandler.trigger(this._element, EVENT_HIDDEN$2);
            };
            const transitionDuration = getTransitionDurationFromElement(this._element);
            EventHandler.one(this._element, "transitionend", completeCallback);
            emulateTransitionEnd(this._element, transitionDuration);
        }
        dispose() {
            this._backdrop.dispose();
            super.dispose();
            EventHandler.off(document, EVENT_FOCUSIN);
            this._config = null;
            this._backdrop = null;
        }
        _getConfig(config) {
            config = {
                ...Default$4,
                ...Manipulator.getDataAttributes(this._element),
                ...typeof config === "object" ? config : {}
            };
            typeCheckConfig(NAME$5, config, DefaultType$4);
            return config;
        }
        _initializeBackDrop() {
            return new Backdrop({
                isVisible: this._config.backdrop,
                isAnimated: true,
                rootElement: this._element.parentNode,
                clickCallback: () => this.hide()
            });
        }
        _enforceFocusOnElement(element) {
            EventHandler.off(document, EVENT_FOCUSIN);
            EventHandler.on(document, EVENT_FOCUSIN, event => {
                if (document !== event.target && element !== event.target && !element.contains(event.target)) {
                    element.focus();
                }
            });
            element.focus();
        }
        _addEventListeners() {
            EventHandler.on(this._element, EVENT_CLICK_DISMISS$1, SELECTOR_DATA_DISMISS$1, () => this.hide());
            EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {
                if (this._config.keyboard && event.key === ESCAPE_KEY) {
                    this.hide();
                }
            });
        }
        static jQueryInterface(config) {
            return this.each(function() {
                const data = Data.get(this, DATA_KEY$5) || new Offcanvas(this, typeof config === "object" ? config : {});
                if (typeof config !== "string") {
                    return;
                }
                if (data[config] === undefined || config.startsWith("_") || config === "constructor") {
                    throw new TypeError(`No method named "${config}"`);
                }
                data[config](this);
            });
        }
    }
    EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
        const target = getElementFromSelector(this);
        if ([ "A", "AREA" ].includes(this.tagName)) {
            event.preventDefault();
        }
        if (isDisabled(this)) {
            return;
        }
        EventHandler.one(target, EVENT_HIDDEN$2, () => {
            if (isVisible(this)) {
                this.focus();
            }
        });
        const allReadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
        if (allReadyOpen && allReadyOpen !== target) {
            Offcanvas.getInstance(allReadyOpen).hide();
        }
        const data = Data.get(target, DATA_KEY$5) || new Offcanvas(target);
        data.toggle(this);
    });
    EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
        SelectorEngine.find(OPEN_SELECTOR).forEach(el => (Data.get(el, DATA_KEY$5) || new Offcanvas(el)).show());
    });
    defineJQueryPlugin(NAME$5, Offcanvas);
    const uriAttrs = new Set([ "background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href" ]);
    const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
    const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/i;
    const DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
    const allowedAttribute = (attr, allowedAttributeList) => {
        const attrName = attr.nodeName.toLowerCase();
        if (allowedAttributeList.includes(attrName)) {
            if (uriAttrs.has(attrName)) {
                return Boolean(SAFE_URL_PATTERN.test(attr.nodeValue) || DATA_URL_PATTERN.test(attr.nodeValue));
            }
            return true;
        }
        const regExp = allowedAttributeList.filter(attrRegex => attrRegex instanceof RegExp);
        for (let i = 0, len = regExp.length; i < len; i++) {
            if (regExp[i].test(attrName)) {
                return true;
            }
        }
        return false;
    };
    const DefaultAllowlist = {
        "*": [ "class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN ],
        a: [ "target", "href", "title", "rel" ],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: [ "src", "srcset", "alt", "title", "width", "height" ],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: []
    };
    function sanitizeHtml(unsafeHtml, allowList, sanitizeFn) {
        if (!unsafeHtml.length) {
            return unsafeHtml;
        }
        if (sanitizeFn && typeof sanitizeFn === "function") {
            return sanitizeFn(unsafeHtml);
        }
        const domParser = new window.DOMParser();
        const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
        const allowlistKeys = Object.keys(allowList);
        const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
        for (let i = 0, len = elements.length; i < len; i++) {
            const el = elements[i];
            const elName = el.nodeName.toLowerCase();
            if (!allowlistKeys.includes(elName)) {
                el.parentNode.removeChild(el);
                continue;
            }
            const attributeList = [].concat(...el.attributes);
            const allowedAttributes = [].concat(allowList["*"] || [], allowList[elName] || []);
            attributeList.forEach(attr => {
                if (!allowedAttribute(attr, allowedAttributes)) {
                    el.removeAttribute(attr.nodeName);
                }
            });
        }
        return createdDocument.body.innerHTML;
    }
    const NAME$4 = "tooltip";
    const DATA_KEY$4 = "bs.tooltip";
    const EVENT_KEY$4 = `.${DATA_KEY$4}`;
    const CLASS_PREFIX$1 = "bs-tooltip";
    const BSCLS_PREFIX_REGEX$1 = new RegExp(`(^|\\s)${CLASS_PREFIX$1}\\S+`, "g");
    const DISALLOWED_ATTRIBUTES = new Set([ "sanitize", "allowList", "sanitizeFn" ]);
    const DefaultType$3 = {
        animation: "boolean",
        template: "string",
        title: "(string|element|function)",
        trigger: "string",
        delay: "(number|object)",
        html: "boolean",
        selector: "(string|boolean)",
        placement: "(string|function)",
        offset: "(array|string|function)",
        container: "(string|element|boolean)",
        fallbackPlacements: "array",
        boundary: "(string|element)",
        customClass: "(string|function)",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        allowList: "object",
        popperConfig: "(null|object|function)"
    };
    const AttachmentMap = {
        AUTO: "auto",
        TOP: "top",
        RIGHT: isRTL() ? "left" : "right",
        BOTTOM: "bottom",
        LEFT: isRTL() ? "right" : "left"
    };
    const Default$3 = {
        animation: true,
        template: '<div class="tooltip" role="tooltip">' + '<div class="tooltip-arrow"></div>' + '<div class="tooltip-inner"></div>' + "</div>",
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: false,
        selector: false,
        placement: "top",
        offset: [ 0, 0 ],
        container: false,
        fallbackPlacements: [ "top", "right", "bottom", "left" ],
        boundary: "clippingParents",
        customClass: "",
        sanitize: true,
        sanitizeFn: null,
        allowList: DefaultAllowlist,
        popperConfig: null
    };
    const Event$2 = {
        HIDE: `hide${EVENT_KEY$4}`,
        HIDDEN: `hidden${EVENT_KEY$4}`,
        SHOW: `show${EVENT_KEY$4}`,
        SHOWN: `shown${EVENT_KEY$4}`,
        INSERTED: `inserted${EVENT_KEY$4}`,
        CLICK: `click${EVENT_KEY$4}`,
        FOCUSIN: `focusin${EVENT_KEY$4}`,
        FOCUSOUT: `focusout${EVENT_KEY$4}`,
        MOUSEENTER: `mouseenter${EVENT_KEY$4}`,
        MOUSELEAVE: `mouseleave${EVENT_KEY$4}`
    };
    const CLASS_NAME_FADE$3 = "fade";
    const CLASS_NAME_MODAL = "modal";
    const CLASS_NAME_SHOW$3 = "show";
    const HOVER_STATE_SHOW = "show";
    const HOVER_STATE_OUT = "out";
    const SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
    const TRIGGER_HOVER = "hover";
    const TRIGGER_FOCUS = "focus";
    const TRIGGER_CLICK = "click";
    const TRIGGER_MANUAL = "manual";
    class Tooltip extends BaseComponent {
        constructor(element, config) {
            if (typeof Popper === "undefined") {
                throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
            }
            super(element);
            this._isEnabled = true;
            this._timeout = 0;
            this._hoverState = "";
            this._activeTrigger = {};
            this._popper = null;
            this.config = this._getConfig(config);
            this.tip = null;
            this._setListeners();
        }
        static get Default() {
            return Default$3;
        }
        static get NAME() {
            return NAME$4;
        }
        static get DATA_KEY() {
            return DATA_KEY$4;
        }
        static get Event() {
            return Event$2;
        }
        static get EVENT_KEY() {
            return EVENT_KEY$4;
        }
        static get DefaultType() {
            return DefaultType$3;
        }
        enable() {
            this._isEnabled = true;
        }
        disable() {
            this._isEnabled = false;
        }
        toggleEnabled() {
            this._isEnabled = !this._isEnabled;
        }
        toggle(event) {
            if (!this._isEnabled) {
                return;
            }
            if (event) {
                const context = this._initializeOnDelegatedTarget(event);
                context._activeTrigger.click = !context._activeTrigger.click;
                if (context._isWithActiveTrigger()) {
                    context._enter(null, context);
                } else {
                    context._leave(null, context);
                }
            } else {
                if (this.getTipElement().classList.contains(CLASS_NAME_SHOW$3)) {
                    this._leave(null, this);
                    return;
                }
                this._enter(null, this);
            }
        }
        dispose() {
            clearTimeout(this._timeout);
            EventHandler.off(this._element.closest(`.${CLASS_NAME_MODAL}`), "hide.bs.modal", this._hideModalHandler);
            if (this.tip && this.tip.parentNode) {
                this.tip.parentNode.removeChild(this.tip);
            }
            this._isEnabled = null;
            this._timeout = null;
            this._hoverState = null;
            this._activeTrigger = null;
            if (this._popper) {
                this._popper.destroy();
            }
            this._popper = null;
            this.config = null;
            this.tip = null;
            super.dispose();
        }
        show() {
            if (this._element.style.display === "none") {
                throw new Error("Please use show on visible elements");
            }
            if (!(this.isWithContent() && this._isEnabled)) {
                return;
            }
            const showEvent = EventHandler.trigger(this._element, this.constructor.Event.SHOW);
            const shadowRoot = findShadowRoot(this._element);
            const isInTheDom = shadowRoot === null ? this._element.ownerDocument.documentElement.contains(this._element) : shadowRoot.contains(this._element);
            if (showEvent.defaultPrevented || !isInTheDom) {
                return;
            }
            const tip = this.getTipElement();
            const tipId = getUID(this.constructor.NAME);
            tip.setAttribute("id", tipId);
            this._element.setAttribute("aria-describedby", tipId);
            this.setContent();
            if (this.config.animation) {
                tip.classList.add(CLASS_NAME_FADE$3);
            }
            const placement = typeof this.config.placement === "function" ? this.config.placement.call(this, tip, this._element) : this.config.placement;
            const attachment = this._getAttachment(placement);
            this._addAttachmentClass(attachment);
            const container = this._getContainer();
            Data.set(tip, this.constructor.DATA_KEY, this);
            if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
                container.appendChild(tip);
                EventHandler.trigger(this._element, this.constructor.Event.INSERTED);
            }
            if (this._popper) {
                this._popper.update();
            } else {
                this._popper = createPopper(this._element, tip, this._getPopperConfig(attachment));
            }
            tip.classList.add(CLASS_NAME_SHOW$3);
            const customClass = typeof this.config.customClass === "function" ? this.config.customClass() : this.config.customClass;
            if (customClass) {
                tip.classList.add(...customClass.split(" "));
            }
            if ("ontouchstart" in document.documentElement) {
                [].concat(...document.body.children).forEach(element => {
                    EventHandler.on(element, "mouseover", noop);
                });
            }
            const complete = () => {
                const prevHoverState = this._hoverState;
                this._hoverState = null;
                EventHandler.trigger(this._element, this.constructor.Event.SHOWN);
                if (prevHoverState === HOVER_STATE_OUT) {
                    this._leave(null, this);
                }
            };
            if (this.tip.classList.contains(CLASS_NAME_FADE$3)) {
                const transitionDuration = getTransitionDurationFromElement(this.tip);
                EventHandler.one(this.tip, "transitionend", complete);
                emulateTransitionEnd(this.tip, transitionDuration);
            } else {
                complete();
            }
        }
        hide() {
            if (!this._popper) {
                return;
            }
            const tip = this.getTipElement();
            const complete = () => {
                if (this._isWithActiveTrigger()) {
                    return;
                }
                if (this._hoverState !== HOVER_STATE_SHOW && tip.parentNode) {
                    tip.parentNode.removeChild(tip);
                }
                this._cleanTipClass();
                this._element.removeAttribute("aria-describedby");
                EventHandler.trigger(this._element, this.constructor.Event.HIDDEN);
                if (this._popper) {
                    this._popper.destroy();
                    this._popper = null;
                }
            };
            const hideEvent = EventHandler.trigger(this._element, this.constructor.Event.HIDE);
            if (hideEvent.defaultPrevented) {
                return;
            }
            tip.classList.remove(CLASS_NAME_SHOW$3);
            if ("ontouchstart" in document.documentElement) {
                [].concat(...document.body.children).forEach(element => EventHandler.off(element, "mouseover", noop));
            }
            this._activeTrigger[TRIGGER_CLICK] = false;
            this._activeTrigger[TRIGGER_FOCUS] = false;
            this._activeTrigger[TRIGGER_HOVER] = false;
            if (this.tip.classList.contains(CLASS_NAME_FADE$3)) {
                const transitionDuration = getTransitionDurationFromElement(tip);
                EventHandler.one(tip, "transitionend", complete);
                emulateTransitionEnd(tip, transitionDuration);
            } else {
                complete();
            }
            this._hoverState = "";
        }
        update() {
            if (this._popper !== null) {
                this._popper.update();
            }
        }
        isWithContent() {
            return Boolean(this.getTitle());
        }
        getTipElement() {
            if (this.tip) {
                return this.tip;
            }
            const element = document.createElement("div");
            element.innerHTML = this.config.template;
            this.tip = element.children[0];
            return this.tip;
        }
        setContent() {
            const tip = this.getTipElement();
            this.setElementContent(SelectorEngine.findOne(SELECTOR_TOOLTIP_INNER, tip), this.getTitle());
            tip.classList.remove(CLASS_NAME_FADE$3, CLASS_NAME_SHOW$3);
        }
        setElementContent(element, content) {
            if (element === null) {
                return;
            }
            if (typeof content === "object" && isElement$1(content)) {
                if (content.jquery) {
                    content = content[0];
                }
                if (this.config.html) {
                    if (content.parentNode !== element) {
                        element.innerHTML = "";
                        element.appendChild(content);
                    }
                } else {
                    element.textContent = content.textContent;
                }
                return;
            }
            if (this.config.html) {
                if (this.config.sanitize) {
                    content = sanitizeHtml(content, this.config.allowList, this.config.sanitizeFn);
                }
                element.innerHTML = content;
            } else {
                element.textContent = content;
            }
        }
        getTitle() {
            let title = this._element.getAttribute("data-bs-original-title");
            if (!title) {
                title = typeof this.config.title === "function" ? this.config.title.call(this._element) : this.config.title;
            }
            return title;
        }
        updateAttachment(attachment) {
            if (attachment === "right") {
                return "end";
            }
            if (attachment === "left") {
                return "start";
            }
            return attachment;
        }
        _initializeOnDelegatedTarget(event, context) {
            const dataKey = this.constructor.DATA_KEY;
            context = context || Data.get(event.delegateTarget, dataKey);
            if (!context) {
                context = new this.constructor(event.delegateTarget, this._getDelegateConfig());
                Data.set(event.delegateTarget, dataKey, context);
            }
            return context;
        }
        _getOffset() {
            const {
                offset
            } = this.config;
            if (typeof offset === "string") {
                return offset.split(",").map(val => Number.parseInt(val, 10));
            }
            if (typeof offset === "function") {
                return popperData => offset(popperData, this._element);
            }
            return offset;
        }
        _getPopperConfig(attachment) {
            const defaultBsPopperConfig = {
                placement: attachment,
                modifiers: [ {
                    name: "flip",
                    options: {
                        fallbackPlacements: this.config.fallbackPlacements
                    }
                }, {
                    name: "offset",
                    options: {
                        offset: this._getOffset()
                    }
                }, {
                    name: "preventOverflow",
                    options: {
                        boundary: this.config.boundary
                    }
                }, {
                    name: "arrow",
                    options: {
                        element: `.${this.constructor.NAME}-arrow`
                    }
                }, {
                    name: "onChange",
                    enabled: true,
                    phase: "afterWrite",
                    fn: data => this._handlePopperPlacementChange(data)
                } ],
                onFirstUpdate: data => {
                    if (data.options.placement !== data.placement) {
                        this._handlePopperPlacementChange(data);
                    }
                }
            };
            return {
                ...defaultBsPopperConfig,
                ...typeof this.config.popperConfig === "function" ? this.config.popperConfig(defaultBsPopperConfig) : this.config.popperConfig
            };
        }
        _addAttachmentClass(attachment) {
            this.getTipElement().classList.add(`${CLASS_PREFIX$1}-${this.updateAttachment(attachment)}`);
        }
        _getContainer() {
            if (this.config.container === false) {
                return document.body;
            }
            if (isElement$1(this.config.container)) {
                return this.config.container;
            }
            return SelectorEngine.findOne(this.config.container);
        }
        _getAttachment(placement) {
            return AttachmentMap[placement.toUpperCase()];
        }
        _setListeners() {
            const triggers = this.config.trigger.split(" ");
            triggers.forEach(trigger => {
                if (trigger === "click") {
                    EventHandler.on(this._element, this.constructor.Event.CLICK, this.config.selector, event => this.toggle(event));
                } else if (trigger !== TRIGGER_MANUAL) {
                    const eventIn = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN;
                    const eventOut = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
                    EventHandler.on(this._element, eventIn, this.config.selector, event => this._enter(event));
                    EventHandler.on(this._element, eventOut, this.config.selector, event => this._leave(event));
                }
            });
            this._hideModalHandler = () => {
                if (this._element) {
                    this.hide();
                }
            };
            EventHandler.on(this._element.closest(`.${CLASS_NAME_MODAL}`), "hide.bs.modal", this._hideModalHandler);
            if (this.config.selector) {
                this.config = {
                    ...this.config,
                    trigger: "manual",
                    selector: ""
                };
            } else {
                this._fixTitle();
            }
        }
        _fixTitle() {
            const title = this._element.getAttribute("title");
            const originalTitleType = typeof this._element.getAttribute("data-bs-original-title");
            if (title || originalTitleType !== "string") {
                this._element.setAttribute("data-bs-original-title", title || "");
                if (title && !this._element.getAttribute("aria-label") && !this._element.textContent) {
                    this._element.setAttribute("aria-label", title);
                }
                this._element.setAttribute("title", "");
            }
        }
        _enter(event, context) {
            context = this._initializeOnDelegatedTarget(event, context);
            if (event) {
                context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
            }
            if (context.getTipElement().classList.contains(CLASS_NAME_SHOW$3) || context._hoverState === HOVER_STATE_SHOW) {
                context._hoverState = HOVER_STATE_SHOW;
                return;
            }
            clearTimeout(context._timeout);
            context._hoverState = HOVER_STATE_SHOW;
            if (!context.config.delay || !context.config.delay.show) {
                context.show();
                return;
            }
            context._timeout = setTimeout(() => {
                if (context._hoverState === HOVER_STATE_SHOW) {
                    context.show();
                }
            }, context.config.delay.show);
        }
        _leave(event, context) {
            context = this._initializeOnDelegatedTarget(event, context);
            if (event) {
                context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
            }
            if (context._isWithActiveTrigger()) {
                return;
            }
            clearTimeout(context._timeout);
            context._hoverState = HOVER_STATE_OUT;
            if (!context.config.delay || !context.config.delay.hide) {
                context.hide();
                return;
            }
            context._timeout = setTimeout(() => {
                if (context._hoverState === HOVER_STATE_OUT) {
                    context.hide();
                }
            }, context.config.delay.hide);
        }
        _isWithActiveTrigger() {
            for (const trigger in this._activeTrigger) {
                if (this._activeTrigger[trigger]) {
                    return true;
                }
            }
            return false;
        }
        _getConfig(config) {
            const dataAttributes = Manipulator.getDataAttributes(this._element);
            Object.keys(dataAttributes).forEach(dataAttr => {
                if (DISALLOWED_ATTRIBUTES.has(dataAttr)) {
                    delete dataAttributes[dataAttr];
                }
            });
            if (config && typeof config.container === "object" && config.container.jquery) {
                config.container = config.container[0];
            }
            config = {
                ...this.constructor.Default,
                ...dataAttributes,
                ...typeof config === "object" && config ? config : {}
            };
            if (typeof config.delay === "number") {
                config.delay = {
                    show: config.delay,
                    hide: config.delay
                };
            }
            if (typeof config.title === "number") {
                config.title = config.title.toString();
            }
            if (typeof config.content === "number") {
                config.content = config.content.toString();
            }
            typeCheckConfig(NAME$4, config, this.constructor.DefaultType);
            if (config.sanitize) {
                config.template = sanitizeHtml(config.template, config.allowList, config.sanitizeFn);
            }
            return config;
        }
        _getDelegateConfig() {
            const config = {};
            if (this.config) {
                for (const key in this.config) {
                    if (this.constructor.Default[key] !== this.config[key]) {
                        config[key] = this.config[key];
                    }
                }
            }
            return config;
        }
        _cleanTipClass() {
            const tip = this.getTipElement();
            const tabClass = tip.getAttribute("class").match(BSCLS_PREFIX_REGEX$1);
            if (tabClass !== null && tabClass.length > 0) {
                tabClass.map(token => token.trim()).forEach(tClass => tip.classList.remove(tClass));
            }
        }
        _handlePopperPlacementChange(popperData) {
            const {
                state
            } = popperData;
            if (!state) {
                return;
            }
            this.tip = state.elements.popper;
            this._cleanTipClass();
            this._addAttachmentClass(this._getAttachment(state.placement));
        }
        static jQueryInterface(config) {
            return this.each(function() {
                let data = Data.get(this, DATA_KEY$4);
                const _config = typeof config === "object" && config;
                if (!data && /dispose|hide/.test(config)) {
                    return;
                }
                if (!data) {
                    data = new Tooltip(this, _config);
                }
                if (typeof config === "string") {
                    if (typeof data[config] === "undefined") {
                        throw new TypeError(`No method named "${config}"`);
                    }
                    data[config]();
                }
            });
        }
    }
    defineJQueryPlugin(NAME$4, Tooltip);
    const NAME$3 = "popover";
    const DATA_KEY$3 = "bs.popover";
    const EVENT_KEY$3 = `.${DATA_KEY$3}`;
    const CLASS_PREFIX = "bs-popover";
    const BSCLS_PREFIX_REGEX = new RegExp(`(^|\\s)${CLASS_PREFIX}\\S+`, "g");
    const Default$2 = {
        ...Tooltip.Default,
        placement: "right",
        offset: [ 0, 8 ],
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip">' + '<div class="popover-arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div>' + "</div>"
    };
    const DefaultType$2 = {
        ...Tooltip.DefaultType,
        content: "(string|element|function)"
    };
    const Event$1 = {
        HIDE: `hide${EVENT_KEY$3}`,
        HIDDEN: `hidden${EVENT_KEY$3}`,
        SHOW: `show${EVENT_KEY$3}`,
        SHOWN: `shown${EVENT_KEY$3}`,
        INSERTED: `inserted${EVENT_KEY$3}`,
        CLICK: `click${EVENT_KEY$3}`,
        FOCUSIN: `focusin${EVENT_KEY$3}`,
        FOCUSOUT: `focusout${EVENT_KEY$3}`,
        MOUSEENTER: `mouseenter${EVENT_KEY$3}`,
        MOUSELEAVE: `mouseleave${EVENT_KEY$3}`
    };
    const CLASS_NAME_FADE$2 = "fade";
    const CLASS_NAME_SHOW$2 = "show";
    const SELECTOR_TITLE = ".popover-header";
    const SELECTOR_CONTENT = ".popover-body";
    class Popover extends Tooltip {
        static get Default() {
            return Default$2;
        }
        static get NAME() {
            return NAME$3;
        }
        static get DATA_KEY() {
            return DATA_KEY$3;
        }
        static get Event() {
            return Event$1;
        }
        static get EVENT_KEY() {
            return EVENT_KEY$3;
        }
        static get DefaultType() {
            return DefaultType$2;
        }
        isWithContent() {
            return this.getTitle() || this._getContent();
        }
        setContent() {
            const tip = this.getTipElement();
            this.setElementContent(SelectorEngine.findOne(SELECTOR_TITLE, tip), this.getTitle());
            let content = this._getContent();
            if (typeof content === "function") {
                content = content.call(this._element);
            }
            this.setElementContent(SelectorEngine.findOne(SELECTOR_CONTENT, tip), content);
            tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
        }
        _addAttachmentClass(attachment) {
            this.getTipElement().classList.add(`${CLASS_PREFIX}-${this.updateAttachment(attachment)}`);
        }
        _getContent() {
            return this._element.getAttribute("data-bs-content") || this.config.content;
        }
        _cleanTipClass() {
            const tip = this.getTipElement();
            const tabClass = tip.getAttribute("class").match(BSCLS_PREFIX_REGEX);
            if (tabClass !== null && tabClass.length > 0) {
                tabClass.map(token => token.trim()).forEach(tClass => tip.classList.remove(tClass));
            }
        }
        static jQueryInterface(config) {
            return this.each(function() {
                let data = Data.get(this, DATA_KEY$3);
                const _config = typeof config === "object" ? config : null;
                if (!data && /dispose|hide/.test(config)) {
                    return;
                }
                if (!data) {
                    data = new Popover(this, _config);
                    Data.set(this, DATA_KEY$3, data);
                }
                if (typeof config === "string") {
                    if (typeof data[config] === "undefined") {
                        throw new TypeError(`No method named "${config}"`);
                    }
                    data[config]();
                }
            });
        }
    }
    defineJQueryPlugin(NAME$3, Popover);
    const NAME$2 = "scrollspy";
    const DATA_KEY$2 = "bs.scrollspy";
    const EVENT_KEY$2 = `.${DATA_KEY$2}`;
    const DATA_API_KEY$1 = ".data-api";
    const Default$1 = {
        offset: 10,
        method: "auto",
        target: ""
    };
    const DefaultType$1 = {
        offset: "number",
        method: "string",
        target: "(string|element)"
    };
    const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
    const EVENT_SCROLL = `scroll${EVENT_KEY$2}`;
    const EVENT_LOAD_DATA_API = `load${EVENT_KEY$2}${DATA_API_KEY$1}`;
    const CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
    const CLASS_NAME_ACTIVE$1 = "active";
    const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
    const SELECTOR_NAV_LIST_GROUP$1 = ".nav, .list-group";
    const SELECTOR_NAV_LINKS = ".nav-link";
    const SELECTOR_NAV_ITEMS = ".nav-item";
    const SELECTOR_LIST_ITEMS = ".list-group-item";
    const SELECTOR_DROPDOWN$1 = ".dropdown";
    const SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
    const METHOD_OFFSET = "offset";
    const METHOD_POSITION = "position";
    class ScrollSpy extends BaseComponent {
        constructor(element, config) {
            super(element);
            this._scrollElement = this._element.tagName === "BODY" ? window : this._element;
            this._config = this._getConfig(config);
            this._selector = `${this._config.target} ${SELECTOR_NAV_LINKS}, ${this._config.target} ${SELECTOR_LIST_ITEMS}, ${this._config.target} .${CLASS_NAME_DROPDOWN_ITEM}`;
            this._offsets = [];
            this._targets = [];
            this._activeTarget = null;
            this._scrollHeight = 0;
            EventHandler.on(this._scrollElement, EVENT_SCROLL, () => this._process());
            this.refresh();
            this._process();
        }
        static get Default() {
            return Default$1;
        }
        static get DATA_KEY() {
            return DATA_KEY$2;
        }
        refresh() {
            const autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;
            const offsetMethod = this._config.method === "auto" ? autoMethod : this._config.method;
            const offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;
            this._offsets = [];
            this._targets = [];
            this._scrollHeight = this._getScrollHeight();
            const targets = SelectorEngine.find(this._selector);
            targets.map(element => {
                const targetSelector = getSelectorFromElement(element);
                const target = targetSelector ? SelectorEngine.findOne(targetSelector) : null;
                if (target) {
                    const targetBCR = target.getBoundingClientRect();
                    if (targetBCR.width || targetBCR.height) {
                        return [ Manipulator[offsetMethod](target).top + offsetBase, targetSelector ];
                    }
                }
                return null;
            }).filter(item => item).sort((a, b) => a[0] - b[0]).forEach(item => {
                this._offsets.push(item[0]);
                this._targets.push(item[1]);
            });
        }
        dispose() {
            super.dispose();
            EventHandler.off(this._scrollElement, EVENT_KEY$2);
            this._scrollElement = null;
            this._config = null;
            this._selector = null;
            this._offsets = null;
            this._targets = null;
            this._activeTarget = null;
            this._scrollHeight = null;
        }
        _getConfig(config) {
            config = {
                ...Default$1,
                ...Manipulator.getDataAttributes(this._element),
                ...typeof config === "object" && config ? config : {}
            };
            if (typeof config.target !== "string" && isElement$1(config.target)) {
                let {
                    id
                } = config.target;
                if (!id) {
                    id = getUID(NAME$2);
                    config.target.id = id;
                }
                config.target = `#${id}`;
            }
            typeCheckConfig(NAME$2, config, DefaultType$1);
            return config;
        }
        _getScrollTop() {
            return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
        }
        _getScrollHeight() {
            return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
        }
        _getOffsetHeight() {
            return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
        }
        _process() {
            const scrollTop = this._getScrollTop() + this._config.offset;
            const scrollHeight = this._getScrollHeight();
            const maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();
            if (this._scrollHeight !== scrollHeight) {
                this.refresh();
            }
            if (scrollTop >= maxScroll) {
                const target = this._targets[this._targets.length - 1];
                if (this._activeTarget !== target) {
                    this._activate(target);
                }
                return;
            }
            if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
                this._activeTarget = null;
                this._clear();
                return;
            }
            for (let i = this._offsets.length; i--; ) {
                const isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === "undefined" || scrollTop < this._offsets[i + 1]);
                if (isActiveTarget) {
                    this._activate(this._targets[i]);
                }
            }
        }
        _activate(target) {
            this._activeTarget = target;
            this._clear();
            const queries = this._selector.split(",").map(selector => `${selector}[data-bs-target="${target}"],${selector}[href="${target}"]`);
            const link = SelectorEngine.findOne(queries.join(","));
            if (link.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
                SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, link.closest(SELECTOR_DROPDOWN$1)).classList.add(CLASS_NAME_ACTIVE$1);
                link.classList.add(CLASS_NAME_ACTIVE$1);
            } else {
                link.classList.add(CLASS_NAME_ACTIVE$1);
                SelectorEngine.parents(link, SELECTOR_NAV_LIST_GROUP$1).forEach(listGroup => {
                    SelectorEngine.prev(listGroup, `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`).forEach(item => item.classList.add(CLASS_NAME_ACTIVE$1));
                    SelectorEngine.prev(listGroup, SELECTOR_NAV_ITEMS).forEach(navItem => {
                        SelectorEngine.children(navItem, SELECTOR_NAV_LINKS).forEach(item => item.classList.add(CLASS_NAME_ACTIVE$1));
                    });
                });
            }
            EventHandler.trigger(this._scrollElement, EVENT_ACTIVATE, {
                relatedTarget: target
            });
        }
        _clear() {
            SelectorEngine.find(this._selector).filter(node => node.classList.contains(CLASS_NAME_ACTIVE$1)).forEach(node => node.classList.remove(CLASS_NAME_ACTIVE$1));
        }
        static jQueryInterface(config) {
            return this.each(function() {
                const data = ScrollSpy.getInstance(this) || new ScrollSpy(this, typeof config === "object" ? config : {});
                if (typeof config !== "string") {
                    return;
                }
                if (typeof data[config] === "undefined") {
                    throw new TypeError(`No method named "${config}"`);
                }
                data[config]();
            });
        }
    }
    EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
        SelectorEngine.find(SELECTOR_DATA_SPY).forEach(spy => new ScrollSpy(spy));
    });
    defineJQueryPlugin(NAME$2, ScrollSpy);
    const NAME$1 = "tab";
    const DATA_KEY$1 = "bs.tab";
    const EVENT_KEY$1 = `.${DATA_KEY$1}`;
    const DATA_API_KEY = ".data-api";
    const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
    const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
    const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
    const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
    const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}${DATA_API_KEY}`;
    const CLASS_NAME_DROPDOWN_MENU = "dropdown-menu";
    const CLASS_NAME_ACTIVE = "active";
    const CLASS_NAME_FADE$1 = "fade";
    const CLASS_NAME_SHOW$1 = "show";
    const SELECTOR_DROPDOWN = ".dropdown";
    const SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
    const SELECTOR_ACTIVE = ".active";
    const SELECTOR_ACTIVE_UL = ":scope > li > .active";
    const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
    const SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
    const SELECTOR_DROPDOWN_ACTIVE_CHILD = ":scope > .dropdown-menu .active";
    class Tab extends BaseComponent {
        static get DATA_KEY() {
            return DATA_KEY$1;
        }
        show() {
            if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(CLASS_NAME_ACTIVE)) {
                return;
            }
            let previous;
            const target = getElementFromSelector(this._element);
            const listElement = this._element.closest(SELECTOR_NAV_LIST_GROUP);
            if (listElement) {
                const itemSelector = listElement.nodeName === "UL" || listElement.nodeName === "OL" ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;
                previous = SelectorEngine.find(itemSelector, listElement);
                previous = previous[previous.length - 1];
            }
            const hideEvent = previous ? EventHandler.trigger(previous, EVENT_HIDE$1, {
                relatedTarget: this._element
            }) : null;
            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$1, {
                relatedTarget: previous
            });
            if (showEvent.defaultPrevented || hideEvent !== null && hideEvent.defaultPrevented) {
                return;
            }
            this._activate(this._element, listElement);
            const complete = () => {
                EventHandler.trigger(previous, EVENT_HIDDEN$1, {
                    relatedTarget: this._element
                });
                EventHandler.trigger(this._element, EVENT_SHOWN$1, {
                    relatedTarget: previous
                });
            };
            if (target) {
                this._activate(target, target.parentNode, complete);
            } else {
                complete();
            }
        }
        _activate(element, container, callback) {
            const activeElements = container && (container.nodeName === "UL" || container.nodeName === "OL") ? SelectorEngine.find(SELECTOR_ACTIVE_UL, container) : SelectorEngine.children(container, SELECTOR_ACTIVE);
            const active = activeElements[0];
            const isTransitioning = callback && active && active.classList.contains(CLASS_NAME_FADE$1);
            const complete = () => this._transitionComplete(element, active, callback);
            if (active && isTransitioning) {
                const transitionDuration = getTransitionDurationFromElement(active);
                active.classList.remove(CLASS_NAME_SHOW$1);
                EventHandler.one(active, "transitionend", complete);
                emulateTransitionEnd(active, transitionDuration);
            } else {
                complete();
            }
        }
        _transitionComplete(element, active, callback) {
            if (active) {
                active.classList.remove(CLASS_NAME_ACTIVE);
                const dropdownChild = SelectorEngine.findOne(SELECTOR_DROPDOWN_ACTIVE_CHILD, active.parentNode);
                if (dropdownChild) {
                    dropdownChild.classList.remove(CLASS_NAME_ACTIVE);
                }
                if (active.getAttribute("role") === "tab") {
                    active.setAttribute("aria-selected", false);
                }
            }
            element.classList.add(CLASS_NAME_ACTIVE);
            if (element.getAttribute("role") === "tab") {
                element.setAttribute("aria-selected", true);
            }
            reflow(element);
            if (element.classList.contains(CLASS_NAME_FADE$1)) {
                element.classList.add(CLASS_NAME_SHOW$1);
            }
            let parent = element.parentNode;
            if (parent && parent.nodeName === "LI") {
                parent = parent.parentNode;
            }
            if (parent && parent.classList.contains(CLASS_NAME_DROPDOWN_MENU)) {
                const dropdownElement = element.closest(SELECTOR_DROPDOWN);
                if (dropdownElement) {
                    SelectorEngine.find(SELECTOR_DROPDOWN_TOGGLE, dropdownElement).forEach(dropdown => dropdown.classList.add(CLASS_NAME_ACTIVE));
                }
                element.setAttribute("aria-expanded", true);
            }
            if (callback) {
                callback();
            }
        }
        static jQueryInterface(config) {
            return this.each(function() {
                const data = Data.get(this, DATA_KEY$1) || new Tab(this);
                if (typeof config === "string") {
                    if (typeof data[config] === "undefined") {
                        throw new TypeError(`No method named "${config}"`);
                    }
                    data[config]();
                }
            });
        }
    }
    EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
        if ([ "A", "AREA" ].includes(this.tagName)) {
            event.preventDefault();
        }
        if (isDisabled(this)) {
            return;
        }
        const data = Data.get(this, DATA_KEY$1) || new Tab(this);
        data.show();
    });
    defineJQueryPlugin(NAME$1, Tab);
    const NAME = "toast";
    const DATA_KEY = "bs.toast";
    const EVENT_KEY = `.${DATA_KEY}`;
    const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY}`;
    const EVENT_HIDE = `hide${EVENT_KEY}`;
    const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
    const EVENT_SHOW = `show${EVENT_KEY}`;
    const EVENT_SHOWN = `shown${EVENT_KEY}`;
    const CLASS_NAME_FADE = "fade";
    const CLASS_NAME_HIDE = "hide";
    const CLASS_NAME_SHOW = "show";
    const CLASS_NAME_SHOWING = "showing";
    const DefaultType = {
        animation: "boolean",
        autohide: "boolean",
        delay: "number"
    };
    const Default = {
        animation: true,
        autohide: true,
        delay: 5e3
    };
    const SELECTOR_DATA_DISMISS = '[data-bs-dismiss="toast"]';
    class Toast extends BaseComponent {
        constructor(element, config) {
            super(element);
            this._config = this._getConfig(config);
            this._timeout = null;
            this._setListeners();
        }
        static get DefaultType() {
            return DefaultType;
        }
        static get Default() {
            return Default;
        }
        static get DATA_KEY() {
            return DATA_KEY;
        }
        show() {
            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
            if (showEvent.defaultPrevented) {
                return;
            }
            this._clearTimeout();
            if (this._config.animation) {
                this._element.classList.add(CLASS_NAME_FADE);
            }
            const complete = () => {
                this._element.classList.remove(CLASS_NAME_SHOWING);
                this._element.classList.add(CLASS_NAME_SHOW);
                EventHandler.trigger(this._element, EVENT_SHOWN);
                if (this._config.autohide) {
                    this._timeout = setTimeout(() => {
                        this.hide();
                    }, this._config.delay);
                }
            };
            this._element.classList.remove(CLASS_NAME_HIDE);
            reflow(this._element);
            this._element.classList.add(CLASS_NAME_SHOWING);
            if (this._config.animation) {
                const transitionDuration = getTransitionDurationFromElement(this._element);
                EventHandler.one(this._element, "transitionend", complete);
                emulateTransitionEnd(this._element, transitionDuration);
            } else {
                complete();
            }
        }
        hide() {
            if (!this._element.classList.contains(CLASS_NAME_SHOW)) {
                return;
            }
            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
            if (hideEvent.defaultPrevented) {
                return;
            }
            const complete = () => {
                this._element.classList.add(CLASS_NAME_HIDE);
                EventHandler.trigger(this._element, EVENT_HIDDEN);
            };
            this._element.classList.remove(CLASS_NAME_SHOW);
            if (this._config.animation) {
                const transitionDuration = getTransitionDurationFromElement(this._element);
                EventHandler.one(this._element, "transitionend", complete);
                emulateTransitionEnd(this._element, transitionDuration);
            } else {
                complete();
            }
        }
        dispose() {
            this._clearTimeout();
            if (this._element.classList.contains(CLASS_NAME_SHOW)) {
                this._element.classList.remove(CLASS_NAME_SHOW);
            }
            super.dispose();
            this._config = null;
        }
        _getConfig(config) {
            config = {
                ...Default,
                ...Manipulator.getDataAttributes(this._element),
                ...typeof config === "object" && config ? config : {}
            };
            typeCheckConfig(NAME, config, this.constructor.DefaultType);
            return config;
        }
        _setListeners() {
            EventHandler.on(this._element, EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, () => this.hide());
        }
        _clearTimeout() {
            clearTimeout(this._timeout);
            this._timeout = null;
        }
        static jQueryInterface(config) {
            return this.each(function() {
                let data = Data.get(this, DATA_KEY);
                const _config = typeof config === "object" && config;
                if (!data) {
                    data = new Toast(this, _config);
                }
                if (typeof config === "string") {
                    if (typeof data[config] === "undefined") {
                        throw new TypeError(`No method named "${config}"`);
                    }
                    data[config](this);
                }
            });
        }
    }
    defineJQueryPlugin(NAME, Toast);
    var index_umd = {
        Alert: Alert,
        Button: Button,
        Carousel: Carousel,
        Collapse: Collapse,
        Dropdown: Dropdown,
        Modal: Modal,
        Offcanvas: Offcanvas,
        Popover: Popover,
        ScrollSpy: ScrollSpy,
        Tab: Tab,
        Toast: Toast,
        Tooltip: Tooltip
    };
    return index_umd;
});

(function(root, factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof exports === "object") {
        module.exports = factory(require("jquery"));
    } else {
        root.bootbox = factory(root.jQuery);
    }
})(this, function init($, undefined) {
    "use strict";
    if (!Object.keys) {
        Object.keys = function() {
            var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !{
                toString: null
            }.propertyIsEnumerable("toString"), dontEnums = [ "toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor" ], dontEnumsLength = dontEnums.length;
            return function(obj) {
                if (typeof obj !== "function" && (typeof obj !== "object" || obj === null)) {
                    throw new TypeError("Object.keys called on non-object");
                }
                var result = [], prop, i;
                for (prop in obj) {
                    if (hasOwnProperty.call(obj, prop)) {
                        result.push(prop);
                    }
                }
                if (hasDontEnumBug) {
                    for (i = 0; i < dontEnumsLength; i++) {
                        if (hasOwnProperty.call(obj, dontEnums[i])) {
                            result.push(dontEnums[i]);
                        }
                    }
                }
                return result;
            };
        }();
    }
    var exports = {};
    var VERSION = "5.5.2";
    exports.VERSION = VERSION;
    var locales = {
        en: {
            OK: "OK",
            CANCEL: "Cancel",
            CONFIRM: "OK"
        }
    };
    var templates = {
        dialog: '<div class="bootbox modal" tabindex="-1" role="dialog" aria-hidden="true">' + '<div class="modal-dialog">' + '<div class="modal-content">' + '<div class="modal-body"><div class="bootbox-body"></div></div>' + "</div>" + "</div>" + "</div>",
        header: '<div class="modal-header">' + '<h5 class="modal-title"></h5>' + "</div>",
        footer: '<div class="modal-footer"></div>',
        closeButton: '<button type="button" class="bootbox-close-button btn-close" aria-hidden="true"></button>',
        form: '<form class="bootbox-form"></form>',
        button: '<button type="button" class="btn"></button>',
        option: "<option></option>",
        promptMessage: '<div class="bootbox-prompt-message"></div>',
        inputs: {
            text: '<input class="bootbox-input bootbox-input-text form-control" autocomplete="off" type="text" />',
            textarea: '<textarea class="bootbox-input bootbox-input-textarea form-control"></textarea>',
            email: '<input class="bootbox-input bootbox-input-email form-control" autocomplete="off" type="email" />',
            select: '<select class="bootbox-input bootbox-input-select form-control"></select>',
            checkbox: '<div class="form-check checkbox"><label class="form-check-label"><input class="form-check-input bootbox-input bootbox-input-checkbox" type="checkbox" /></label></div>',
            radio: '<div class="form-check radio"><label class="form-check-label"><input class="form-check-input bootbox-input bootbox-input-radio" type="radio" name="bootbox-radio" /></label></div>',
            date: '<input class="bootbox-input bootbox-input-date form-control" autocomplete="off" type="date" />',
            time: '<input class="bootbox-input bootbox-input-time form-control" autocomplete="off" type="time" />',
            number: '<input class="bootbox-input bootbox-input-number form-control" autocomplete="off" type="number" />',
            password: '<input class="bootbox-input bootbox-input-password form-control" autocomplete="off" type="password" />',
            range: '<input class="bootbox-input bootbox-input-range form-control-range" autocomplete="off" type="range" />'
        }
    };
    var defaults = {
        locale: "en",
        backdrop: "static",
        animate: true,
        className: null,
        closeButton: true,
        show: true,
        container: "body",
        value: "",
        inputType: "text",
        swapButtonOrder: false,
        centerVertical: false,
        multiple: false,
        scrollable: false,
        reusable: false
    };
    exports.locales = function(name) {
        return name ? locales[name] : locales;
    };
    exports.addLocale = function(name, values) {
        $.each([ "OK", "CANCEL", "CONFIRM" ], function(_, v) {
            if (!values[v]) {
                throw new Error('Please supply a translation for "' + v + '"');
            }
        });
        locales[name] = {
            OK: values.OK,
            CANCEL: values.CANCEL,
            CONFIRM: values.CONFIRM
        };
        return exports;
    };
    exports.removeLocale = function(name) {
        if (name !== "en") {
            delete locales[name];
        } else {
            throw new Error('"en" is used as the default and fallback locale and cannot be removed.');
        }
        return exports;
    };
    exports.setLocale = function(name) {
        return exports.setDefaults("locale", name);
    };
    exports.setDefaults = function() {
        var values = {};
        if (arguments.length === 2) {
            values[arguments[0]] = arguments[1];
        } else {
            values = arguments[0];
        }
        $.extend(defaults, values);
        return exports;
    };
    exports.hideAll = function() {
        $(".bootbox").modal("hide");
        return exports;
    };
    exports.init = function(_$) {
        return init(_$ || $);
    };
    exports.dialog = function(options) {
        if ($.fn.modal === undefined) {
            throw new Error('"$.fn.modal" is not defined; please double check you have included ' + "the Bootstrap JavaScript library. See https://getbootstrap.com/docs/4.4/getting-started/javascript/ " + "for more details.");
        }
        options = sanitize(options);
        if ($.fn.modal.Constructor.VERSION) {
            options.fullBootstrapVersion = $.fn.modal.Constructor.VERSION;
            var i = options.fullBootstrapVersion.indexOf(".");
            options.bootstrap = options.fullBootstrapVersion.substring(0, i);
        } else {
            options.bootstrap = "2";
            options.fullBootstrapVersion = "2.3.2";
            console.warn("Bootbox will *mostly* work with Bootstrap 2, but we do not officially support it. Please upgrade, if possible.");
        }
        var dialog = $(templates.dialog);
        var innerDialog = dialog.find(".modal-dialog");
        var body = dialog.find(".modal-body");
        var header = $(templates.header);
        var footer = $(templates.footer);
        var buttons = options.buttons;
        var callbacks = {
            onEscape: options.onEscape
        };
        body.find(".bootbox-body").html(options.message);
        if (getKeyLength(options.buttons) > 0) {
            each(buttons, function(key, b) {
                var button = $(templates.button);
                button.data("bb-handler", key);
                button.addClass(b.className);
                switch (key) {
                  case "ok":
                  case "confirm":
                    button.addClass("bootbox-accept");
                    break;

                  case "cancel":
                    button.addClass("bootbox-cancel");
                    break;
                }
                button.html(b.label);
                footer.append(button);
                callbacks[key] = b.callback;
            });
            body.after(footer);
        }
        if (options.animate === true) {
            dialog.addClass("fade");
        }
        if (options.className) {
            dialog.addClass(options.className);
        }
        if (options.size) {
            if (options.fullBootstrapVersion.substring(0, 3) < "3.1") {
                console.warn('"size" requires Bootstrap 3.1.0 or higher. You appear to be using ' + options.fullBootstrapVersion + ". Please upgrade to use this option.");
            }
            switch (options.size) {
              case "small":
              case "sm":
                innerDialog.addClass("modal-sm");
                break;

              case "large":
              case "lg":
                innerDialog.addClass("modal-lg");
                break;

              case "extra-large":
              case "xl":
                innerDialog.addClass("modal-xl");
                if (options.fullBootstrapVersion.substring(0, 3) < "4.2") {
                    console.warn('Using size "xl"/"extra-large" requires Bootstrap 4.2.0 or higher. You appear to be using ' + options.fullBootstrapVersion + ". Please upgrade to use this option.");
                }
                break;
            }
        }
        if (options.scrollable) {
            innerDialog.addClass("modal-dialog-scrollable");
            if (options.fullBootstrapVersion.substring(0, 3) < "4.3") {
                console.warn('Using "scrollable" requires Bootstrap 4.3.0 or higher. You appear to be using ' + options.fullBootstrapVersion + ". Please upgrade to use this option.");
            }
        }
        if (options.title) {
            body.before(header);
            dialog.find(".modal-title").html(options.title);
        }
        if (options.closeButton) {
            var closeButton = $(templates.closeButton);
            if (options.title) {
                if (options.bootstrap > 3) {
                    dialog.find(".modal-header").append(closeButton);
                } else {
                    dialog.find(".modal-header").prepend(closeButton);
                }
            } else {
                closeButton.prependTo(body);
            }
        }
        if (options.centerVertical) {
            innerDialog.addClass("modal-dialog-centered");
            if (options.fullBootstrapVersion < "4.0.0") {
                console.warn('"centerVertical" requires Bootstrap 4.0.0-beta.3 or higher. You appear to be using ' + options.fullBootstrapVersion + ". Please upgrade to use this option.");
            }
        }
        if (!options.reusable) {
            dialog.one("hide.bs.modal", {
                dialog: dialog
            }, unbindModal);
        }
        if (options.onHide) {
            if ($.isFunction(options.onHide)) {
                dialog.on("hide.bs.modal", options.onHide);
            } else {
                throw new Error('Argument supplied to "onHide" must be a function');
            }
        }
        if (!options.reusable) {
            dialog.one("hidden.bs.modal", {
                dialog: dialog
            }, destroyModal);
        }
        if (options.onHidden) {
            if ($.isFunction(options.onHidden)) {
                dialog.on("hidden.bs.modal", options.onHidden);
            } else {
                throw new Error('Argument supplied to "onHidden" must be a function');
            }
        }
        if (options.onShow) {
            if ($.isFunction(options.onShow)) {
                dialog.on("show.bs.modal", options.onShow);
            } else {
                throw new Error('Argument supplied to "onShow" must be a function');
            }
        }
        dialog.one("shown.bs.modal", {
            dialog: dialog
        }, focusPrimaryButton);
        if (options.onShown) {
            if ($.isFunction(options.onShown)) {
                dialog.on("shown.bs.modal", options.onShown);
            } else {
                throw new Error('Argument supplied to "onShown" must be a function');
            }
        }
        if (options.backdrop === true) {
            dialog.on("click.dismiss.bs.modal", function(e) {
                if (dialog.children(".modal-backdrop").length) {
                    e.currentTarget = dialog.children(".modal-backdrop").get(0);
                }
                if (e.target !== e.currentTarget) {
                    return;
                }
                dialog.trigger("escape.close.bb");
            });
        }
        dialog.on("escape.close.bb", function(e) {
            if (callbacks.onEscape) {
                processCallback(e, dialog, callbacks.onEscape);
            }
        });
        dialog.on("click", ".modal-footer button:not(.disabled)", function(e) {
            var callbackKey = $(this).data("bb-handler");
            if (callbackKey !== undefined) {
                processCallback(e, dialog, callbacks[callbackKey]);
            }
        });
        dialog.on("click", ".bootbox-close-button", function(e) {
            processCallback(e, dialog, callbacks.onEscape);
        });
        dialog.on("keyup", function(e) {
            if (e.which === 27) {
                dialog.trigger("escape.close.bb");
            }
        });
        $(options.container).append(dialog);
        dialog.modal({
            backdrop: options.backdrop,
            keyboard: false,
            show: false
        });
        if (options.show) {
            dialog.modal("show");
        }
        return dialog;
    };
    exports.alert = function() {
        var options;
        options = mergeDialogOptions("alert", [ "ok" ], [ "message", "callback" ], arguments);
        if (options.callback && !$.isFunction(options.callback)) {
            throw new Error('alert requires the "callback" property to be a function when provided');
        }
        options.buttons.ok.callback = options.onEscape = function() {
            if ($.isFunction(options.callback)) {
                return options.callback.call(this);
            }
            return true;
        };
        return exports.dialog(options);
    };
    exports.confirm = function() {
        var options;
        options = mergeDialogOptions("confirm", [ "cancel", "confirm" ], [ "message", "callback" ], arguments);
        if (!$.isFunction(options.callback)) {
            throw new Error("confirm requires a callback");
        }
        options.buttons.cancel.callback = options.onEscape = function() {
            return options.callback.call(this, false);
        };
        options.buttons.confirm.callback = function() {
            return options.callback.call(this, true);
        };
        return exports.dialog(options);
    };
    exports.prompt = function() {
        var options;
        var promptDialog;
        var form;
        var input;
        var shouldShow;
        var inputOptions;
        form = $(templates.form);
        options = mergeDialogOptions("prompt", [ "cancel", "confirm" ], [ "title", "callback" ], arguments);
        if (!options.value) {
            options.value = defaults.value;
        }
        if (!options.inputType) {
            options.inputType = defaults.inputType;
        }
        shouldShow = options.show === undefined ? defaults.show : options.show;
        options.show = false;
        options.buttons.cancel.callback = options.onEscape = function() {
            return options.callback.call(this, null);
        };
        options.buttons.confirm.callback = function() {
            var value;
            if (options.inputType === "checkbox") {
                value = input.find("input:checked").map(function() {
                    return $(this).val();
                }).get();
            } else if (options.inputType === "radio") {
                value = input.find("input:checked").val();
            } else {
                if (input[0].checkValidity && !input[0].checkValidity()) {
                    return false;
                } else {
                    if (options.inputType === "select" && options.multiple === true) {
                        value = input.find("option:selected").map(function() {
                            return $(this).val();
                        }).get();
                    } else {
                        value = input.val();
                    }
                }
            }
            return options.callback.call(this, value);
        };
        if (!options.title) {
            throw new Error("prompt requires a title");
        }
        if (!$.isFunction(options.callback)) {
            throw new Error("prompt requires a callback");
        }
        if (!templates.inputs[options.inputType]) {
            throw new Error("Invalid prompt type");
        }
        input = $(templates.inputs[options.inputType]);
        switch (options.inputType) {
          case "text":
          case "textarea":
          case "email":
          case "password":
            input.val(options.value);
            if (options.placeholder) {
                input.attr("placeholder", options.placeholder);
            }
            if (options.pattern) {
                input.attr("pattern", options.pattern);
            }
            if (options.maxlength) {
                input.attr("maxlength", options.maxlength);
            }
            if (options.required) {
                input.prop({
                    required: true
                });
            }
            if (options.rows && !isNaN(parseInt(options.rows))) {
                if (options.inputType === "textarea") {
                    input.attr({
                        rows: options.rows
                    });
                }
            }
            break;

          case "date":
          case "time":
          case "number":
          case "range":
            input.val(options.value);
            if (options.placeholder) {
                input.attr("placeholder", options.placeholder);
            }
            if (options.pattern) {
                input.attr("pattern", options.pattern);
            }
            if (options.required) {
                input.prop({
                    required: true
                });
            }
            if (options.inputType !== "date") {
                if (options.step) {
                    if (options.step === "any" || !isNaN(options.step) && parseFloat(options.step) > 0) {
                        input.attr("step", options.step);
                    } else {
                        throw new Error('"step" must be a valid positive number or the value "any". See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-step for more information.');
                    }
                }
            }
            if (minAndMaxAreValid(options.inputType, options.min, options.max)) {
                if (options.min !== undefined) {
                    input.attr("min", options.min);
                }
                if (options.max !== undefined) {
                    input.attr("max", options.max);
                }
            }
            break;

          case "select":
            var groups = {};
            inputOptions = options.inputOptions || [];
            if (!$.isArray(inputOptions)) {
                throw new Error("Please pass an array of input options");
            }
            if (!inputOptions.length) {
                throw new Error('prompt with "inputType" set to "select" requires at least one option');
            }
            if (options.placeholder) {
                input.attr("placeholder", options.placeholder);
            }
            if (options.required) {
                input.prop({
                    required: true
                });
            }
            if (options.multiple) {
                input.prop({
                    multiple: true
                });
            }
            each(inputOptions, function(_, option) {
                var elem = input;
                if (option.value === undefined || option.text === undefined) {
                    throw new Error('each option needs a "value" property and a "text" property');
                }
                if (option.group) {
                    if (!groups[option.group]) {
                        groups[option.group] = $("<optgroup />").attr("label", option.group);
                    }
                    elem = groups[option.group];
                }
                var o = $(templates.option);
                o.attr("value", option.value).text(option.text);
                elem.append(o);
            });
            each(groups, function(_, group) {
                input.append(group);
            });
            input.val(options.value);
            break;

          case "checkbox":
            var checkboxValues = $.isArray(options.value) ? options.value : [ options.value ];
            inputOptions = options.inputOptions || [];
            if (!inputOptions.length) {
                throw new Error('prompt with "inputType" set to "checkbox" requires at least one option');
            }
            input = $('<div class="bootbox-checkbox-list"></div>');
            each(inputOptions, function(_, option) {
                if (option.value === undefined || option.text === undefined) {
                    throw new Error('each option needs a "value" property and a "text" property');
                }
                var checkbox = $(templates.inputs[options.inputType]);
                checkbox.find("input").attr("value", option.value);
                checkbox.find("label").append("\n" + option.text);
                each(checkboxValues, function(_, value) {
                    if (value === option.value) {
                        checkbox.find("input").prop("checked", true);
                    }
                });
                input.append(checkbox);
            });
            break;

          case "radio":
            if (options.value !== undefined && $.isArray(options.value)) {
                throw new Error('prompt with "inputType" set to "radio" requires a single, non-array value for "value"');
            }
            inputOptions = options.inputOptions || [];
            if (!inputOptions.length) {
                throw new Error('prompt with "inputType" set to "radio" requires at least one option');
            }
            input = $('<div class="bootbox-radiobutton-list"></div>');
            var checkFirstRadio = true;
            each(inputOptions, function(_, option) {
                if (option.value === undefined || option.text === undefined) {
                    throw new Error('each option needs a "value" property and a "text" property');
                }
                var radio = $(templates.inputs[options.inputType]);
                radio.find("input").attr("value", option.value);
                radio.find("label").append("\n" + option.text);
                if (options.value !== undefined) {
                    if (option.value === options.value) {
                        radio.find("input").prop("checked", true);
                        checkFirstRadio = false;
                    }
                }
                input.append(radio);
            });
            if (checkFirstRadio) {
                input.find('input[type="radio"]').first().prop("checked", true);
            }
            break;
        }
        form.append(input);
        form.on("submit", function(e) {
            e.preventDefault();
            e.stopPropagation();
            promptDialog.find(".bootbox-accept").trigger("click");
        });
        if ($.trim(options.message) !== "") {
            var message = $(templates.promptMessage).html(options.message);
            form.prepend(message);
            options.message = form;
        } else {
            options.message = form;
        }
        promptDialog = exports.dialog(options);
        promptDialog.off("shown.bs.modal", focusPrimaryButton);
        promptDialog.on("shown.bs.modal", function() {
            input.focus();
        });
        if (shouldShow === true) {
            promptDialog.modal("show");
        }
        return promptDialog;
    };
    function mapArguments(args, properties) {
        var argn = args.length;
        var options = {};
        if (argn < 1 || argn > 2) {
            throw new Error("Invalid argument length");
        }
        if (argn === 2 || typeof args[0] === "string") {
            options[properties[0]] = args[0];
            options[properties[1]] = args[1];
        } else {
            options = args[0];
        }
        return options;
    }
    function mergeArguments(defaults, args, properties) {
        return $.extend(true, {}, defaults, mapArguments(args, properties));
    }
    function mergeDialogOptions(className, labels, properties, args) {
        var locale;
        if (args && args[0]) {
            locale = args[0].locale || defaults.locale;
            var swapButtons = args[0].swapButtonOrder || defaults.swapButtonOrder;
            if (swapButtons) {
                labels = labels.reverse();
            }
        }
        var baseOptions = {
            className: "bootbox-" + className,
            buttons: createLabels(labels, locale)
        };
        return validateButtons(mergeArguments(baseOptions, args, properties), labels);
    }
    function validateButtons(options, buttons) {
        var allowedButtons = {};
        each(buttons, function(key, value) {
            allowedButtons[value] = true;
        });
        each(options.buttons, function(key) {
            if (allowedButtons[key] === undefined) {
                throw new Error('button key "' + key + '" is not allowed (options are ' + buttons.join(" ") + ")");
            }
        });
        return options;
    }
    function createLabels(labels, locale) {
        var buttons = {};
        for (var i = 0, j = labels.length; i < j; i++) {
            var argument = labels[i];
            var key = argument.toLowerCase();
            var value = argument.toUpperCase();
            buttons[key] = {
                label: getText(value, locale)
            };
        }
        return buttons;
    }
    function getText(key, locale) {
        var labels = locales[locale];
        return labels ? labels[key] : locales.en[key];
    }
    function sanitize(options) {
        var buttons;
        var total;
        if (typeof options !== "object") {
            throw new Error("Please supply an object of options");
        }
        if (!options.message) {
            throw new Error('"message" option must not be null or an empty string.');
        }
        options = $.extend({}, defaults, options);
        if (!options.backdrop) {
            options.backdrop = options.backdrop === false || options.backdrop === 0 ? false : "static";
        } else {
            options.backdrop = typeof options.backdrop === "string" && options.backdrop.toLowerCase() === "static" ? "static" : true;
        }
        if (!options.buttons) {
            options.buttons = {};
        }
        buttons = options.buttons;
        total = getKeyLength(buttons);
        each(buttons, function(key, button, index) {
            if ($.isFunction(button)) {
                button = buttons[key] = {
                    callback: button
                };
            }
            if ($.type(button) !== "object") {
                throw new Error('button with key "' + key + '" must be an object');
            }
            if (!button.label) {
                button.label = key;
            }
            if (!button.className) {
                var isPrimary = false;
                if (options.swapButtonOrder) {
                    isPrimary = index === 0;
                } else {
                    isPrimary = index === total - 1;
                }
                if (total <= 2 && isPrimary) {
                    button.className = "btn-primary";
                } else {
                    button.className = "btn-secondary btn-default";
                }
            }
        });
        return options;
    }
    function getKeyLength(obj) {
        return Object.keys(obj).length;
    }
    function each(collection, iterator) {
        var index = 0;
        $.each(collection, function(key, value) {
            iterator(key, value, index++);
        });
    }
    function focusPrimaryButton(e) {
        e.data.dialog.find(".bootbox-accept").first().trigger("focus");
    }
    function destroyModal(e) {
        if (e.target === e.data.dialog[0]) {
            e.data.dialog.remove();
        }
    }
    function unbindModal(e) {
        if (e.target === e.data.dialog[0]) {
            e.data.dialog.off("escape.close.bb");
            e.data.dialog.off("click");
        }
    }
    function processCallback(e, dialog, callback) {
        e.stopPropagation();
        e.preventDefault();
        var preserveDialog = $.isFunction(callback) && callback.call(dialog, e) === false;
        if (!preserveDialog) {
            dialog.modal("hide");
        }
    }
    function minAndMaxAreValid(type, min, max) {
        var result = false;
        var minValid = true;
        var maxValid = true;
        if (type === "date") {
            if (min !== undefined && !(minValid = dateIsValid(min))) {
                console.warn('Browsers which natively support the "date" input type expect date values to be of the form "YYYY-MM-DD" (see ISO-8601 https://www.iso.org/iso-8601-date-and-time-format.html). Bootbox does not enforce this rule, but your min value may not be enforced by this browser.');
            } else if (max !== undefined && !(maxValid = dateIsValid(max))) {
                console.warn('Browsers which natively support the "date" input type expect date values to be of the form "YYYY-MM-DD" (see ISO-8601 https://www.iso.org/iso-8601-date-and-time-format.html). Bootbox does not enforce this rule, but your max value may not be enforced by this browser.');
            }
        } else if (type === "time") {
            if (min !== undefined && !(minValid = timeIsValid(min))) {
                throw new Error('"min" is not a valid time. See https://www.w3.org/TR/2012/WD-html-markup-20120315/datatypes.html#form.data.time for more information.');
            } else if (max !== undefined && !(maxValid = timeIsValid(max))) {
                throw new Error('"max" is not a valid time. See https://www.w3.org/TR/2012/WD-html-markup-20120315/datatypes.html#form.data.time for more information.');
            }
        } else {
            if (min !== undefined && isNaN(min)) {
                minValid = false;
                throw new Error('"min" must be a valid number. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-min for more information.');
            }
            if (max !== undefined && isNaN(max)) {
                maxValid = false;
                throw new Error('"max" must be a valid number. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-max for more information.');
            }
        }
        if (minValid && maxValid) {
            if (max <= min) {
                throw new Error('"max" must be greater than "min". See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-max for more information.');
            } else {
                result = true;
            }
        }
        return result;
    }
    function timeIsValid(value) {
        return /([01][0-9]|2[0-3]):[0-5][0-9]?:[0-5][0-9]/.test(value);
    }
    function dateIsValid(value) {
        return /(\d{4})-(\d{2})-(\d{2})/.test(value);
    }
    return exports;
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    var defaults = {
        element: "body",
        position: null,
        type: "info",
        allow_dismiss: true,
        allow_duplicates: true,
        newest_on_top: false,
        showProgressbar: false,
        placement: {
            from: "top",
            align: "right"
        },
        offset: 20,
        spacing: 10,
        z_index: 9999999,
        delay: 5e3,
        timer: 1e3,
        url_target: "_blank",
        mouse_over: null,
        animate: {
            enter: "animated fadeInDown",
            exit: "animated fadeOutUp"
        },
        onShow: null,
        onShown: null,
        onClose: null,
        onClosed: null,
        onClick: null,
        icon_type: "class",
        template: [ '<div data-notify="container" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="false">', '<div class="toast-header">', '<span data-notify="icon" class="me-2 text-{0}"></span>', '<span class="me-auto fw-bold" data-notify="title">{1}</span>', '<button type="button" class="ms-2 mb-1 btn-close" data-bs-dismiss="toast" data-notify="dismiss" aria-label="Close">', "</button>", "</div>", '<div class="toast-body" data-notify="message">', "{2}", '<div class="progress" data-notify="progressbar">', '<div class="progress-bar progress-bar-{0}" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%;"></div>', "</div>", "</div>" ].join("")
    };
    String.format = function() {
        var args = arguments;
        var str = arguments[0];
        return str.replace(/(\{\{\d\}\}|\{\d\})/g, function(str) {
            if (str.substring(0, 2) === "{{") return str;
            var num = parseInt(str.match(/\d/)[0]);
            return args[num + 1];
        });
    };
    function isDuplicateNotification(notification) {
        var isDupe = false;
        $('[data-notify="container"]').each(function(i, el) {
            var $el = $(el);
            var title = $el.find('[data-notify="title"]').html().trim();
            var message = $el.find('[data-notify="message"]').html().trim();
            var isSameTitle = title === $("<div>" + notification.settings.content.title + "</div>").html().trim();
            var isSameMsg = message === $("<div>" + notification.settings.content.message + "</div>").html().trim();
            var isSameType = $el.hasClass("alert-" + notification.settings.type);
            if (isSameTitle && isSameMsg && isSameType) {
                isDupe = true;
            }
            return !isDupe;
        });
        return isDupe;
    }
    function Notify(element, content, options) {
        var contentObj = {
            content: {
                message: typeof content === "object" ? content.message : content,
                title: content.title ? content.title : "",
                icon: content.icon ? content.icon : "",
                url: content.url ? content.url : "#",
                target: content.target ? content.target : "-"
            }
        };
        options = $.extend(true, {}, contentObj, options);
        this.settings = $.extend(true, {}, defaults, options);
        this._defaults = defaults;
        if (this.settings.content.target === "-") {
            this.settings.content.target = this.settings.url_target;
        }
        this.animations = {
            start: "webkitAnimationStart oanimationstart MSAnimationStart animationstart",
            end: "webkitAnimationEnd oanimationend MSAnimationEnd animationend"
        };
        if (typeof this.settings.offset === "number") {
            this.settings.offset = {
                x: this.settings.offset,
                y: this.settings.offset
            };
        }
        if (this.settings.allow_duplicates || !this.settings.allow_duplicates && !isDuplicateNotification(this)) {
            this.init();
        }
    }
    $.extend(Notify.prototype, {
        init: function() {
            var self = this;
            this.buildNotify();
            if (this.settings.content.icon) {
                this.setIcon();
            }
            if (this.settings.content.url != "#") {
                this.styleURL();
            }
            this.placement();
            this.bind();
            this.notify = {
                $ele: this.$ele,
                update: function(command, update) {
                    var commands = {};
                    if (typeof command === "string") {
                        commands[command] = update;
                    } else {
                        commands = command;
                    }
                    for (var cmd in commands) {
                        switch (cmd) {
                          case "type":
                            this.$ele.removeClass("alert-" + self.settings.type);
                            this.$ele.find('[data-notify="progressbar"] > .progress-bar').removeClass("progress-bar-" + self.settings.type);
                            self.settings.type = commands[cmd];
                            this.$ele.addClass("alert-" + commands[cmd]).find('[data-notify="progressbar"] > .progress-bar').addClass("progress-bar-" + commands[cmd]);
                            break;

                          case "icon":
                            var $icon = this.$ele.find('[data-notify="icon"]');
                            if (self.settings.icon_type.toLowerCase() === "class") {
                                $icon.removeClass(self.settings.content.icon).addClass(commands[cmd]);
                            } else {
                                if (!$icon.is("img")) {
                                    $icon.find("img");
                                }
                                $icon.attr("src", commands[cmd]);
                            }
                            self.settings.content.icon = commands[command];
                            break;

                          case "progress":
                            var newDelay = self.settings.delay - self.settings.delay * (commands[cmd] / 100);
                            this.$ele.data("notify-delay", newDelay);
                            this.$ele.find('[data-notify="progressbar"] > div').attr("aria-valuenow", commands[cmd]).css("width", commands[cmd] + "%");
                            break;

                          case "url":
                            this.$ele.find('[data-notify="url"]').attr("href", commands[cmd]);
                            break;

                          case "target":
                            this.$ele.find('[data-notify="url"]').attr("target", commands[cmd]);
                            break;

                          default:
                            this.$ele.find('[data-notify="' + cmd + '"]').html(commands[cmd]);
                        }
                    }
                    var posX = this.$ele.outerHeight() + parseInt(self.settings.spacing) + parseInt(self.settings.offset.y);
                    self.reposition(posX);
                },
                close: function() {
                    self.close();
                }
            };
        },
        buildNotify: function() {
            var content = this.settings.content;
            this.$ele = $(String.format(this.settings.template, this.settings.type, content.title, content.message, content.url, content.target));
            this.$ele.attr("data-notify-position", this.settings.placement.from + "-" + this.settings.placement.align);
            if (!this.settings.allow_dismiss) {
                this.$ele.find('[data-notify="dismiss"]').css("display", "none");
            }
            if (this.settings.delay <= 0 && !this.settings.showProgressbar || !this.settings.showProgressbar) {
                this.$ele.find('[data-notify="progressbar"]').remove();
            }
        },
        setIcon: function() {
            if (this.settings.icon_type.toLowerCase() === "class") {
                this.$ele.find('[data-notify="icon"]').addClass(this.settings.content.icon);
            } else {
                if (this.$ele.find('[data-notify="icon"]').is("img")) {
                    this.$ele.find('[data-notify="icon"]').attr("src", this.settings.content.icon);
                } else {
                    this.$ele.find('[data-notify="icon"]').append('<img src="' + this.settings.content.icon + '" alt="Notify Icon" />');
                }
            }
        },
        styleDismiss: function() {
            this.$ele.find('[data-notify="dismiss"]').css({
                position: "absolute",
                right: "10px",
                top: "5px",
                zIndex: this.settings.z_index + 2
            });
        },
        styleURL: function() {
            this.$ele.find('[data-notify="url"]').css({
                backgroundImage: "url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)",
                height: "100%",
                left: 0,
                position: "absolute",
                top: 0,
                width: "100%",
                zIndex: this.settings.z_index + 1
            });
        },
        placement: function() {
            var self = this, offsetAmt = this.settings.offset.y, css = {
                display: "inline-block",
                margin: "0px auto",
                opacity: 100,
                "min-width": "300px",
                position: this.settings.position ? this.settings.position : this.settings.element === "body" ? "fixed" : "absolute",
                transition: "all .5s ease-in-out",
                zIndex: this.settings.z_index
            }, hasAnimation = false, settings = this.settings;
            $('[data-notify-position="' + this.settings.placement.from + "-" + this.settings.placement.align + '"]:not([data-closing="true"])').each(function() {
                offsetAmt = Math.max(offsetAmt, parseInt($(this).css(settings.placement.from)) + parseInt($(this).outerHeight()) + parseInt(settings.spacing));
            });
            if (this.settings.newest_on_top === true) {
                offsetAmt = this.settings.offset.y;
            }
            css[this.settings.placement.from] = offsetAmt + "px";
            switch (this.settings.placement.align) {
              case "left":
              case "right":
                css[this.settings.placement.align] = this.settings.offset.x + "px";
                break;

              case "center":
                css.left = 0;
                css.right = 0;
                break;
            }
            this.$ele.css(css).addClass(this.settings.animate.enter);
            $.each(Array("webkit-", "moz-", "o-", "ms-", ""), function(index, prefix) {
                self.$ele[0].style[prefix + "AnimationIterationCount"] = 1;
            });
            $(this.settings.element).append(this.$ele);
            if (this.settings.newest_on_top === true) {
                offsetAmt = parseInt(offsetAmt) + parseInt(this.settings.spacing) + this.$ele.outerHeight();
                this.reposition(offsetAmt);
            }
            if ($.isFunction(self.settings.onShow)) {
                self.settings.onShow.call(this.$ele);
            }
            this.$ele.one(this.animations.start, function() {
                hasAnimation = true;
            }).one(this.animations.end, function() {
                self.$ele.removeClass(self.settings.animate.enter);
                if ($.isFunction(self.settings.onShown)) {
                    self.settings.onShown.call(this);
                }
            });
            setTimeout(function() {
                if (!hasAnimation) {
                    if ($.isFunction(self.settings.onShown)) {
                        self.settings.onShown.call(this);
                    }
                }
            }, 600);
        },
        bind: function() {
            var self = this;
            this.$ele.find('[data-notify="dismiss"]').on("click", function() {
                self.close();
            });
            if ($.isFunction(self.settings.onClick)) {
                this.$ele.on("click", function(event) {
                    if (event.target != self.$ele.find('[data-notify="dismiss"]')[0]) {
                        self.settings.onClick.call(this, event);
                    }
                });
            }
            this.$ele.mouseover(function() {
                $(this).data("data-hover", "true");
            }).mouseout(function() {
                $(this).data("data-hover", "false");
            });
            this.$ele.data("data-hover", "false");
            if (this.settings.delay > 0) {
                self.$ele.data("notify-delay", self.settings.delay);
                var timer = setInterval(function() {
                    var delay = parseInt(self.$ele.data("notify-delay")) - self.settings.timer;
                    if (self.$ele.data("data-hover") === "false" && self.settings.mouse_over === "pause" || self.settings.mouse_over != "pause") {
                        var percent = (self.settings.delay - delay) / self.settings.delay * 100;
                        self.$ele.data("notify-delay", delay);
                        self.$ele.find('[data-notify="progressbar"] > div').attr("aria-valuenow", percent).css("width", percent + "%");
                    }
                    if (delay <= -self.settings.timer) {
                        clearInterval(timer);
                        self.close();
                    }
                }, self.settings.timer);
            }
        },
        close: function() {
            var self = this, posX = parseInt(this.$ele.css(this.settings.placement.from)), hasAnimation = false;
            this.$ele.attr("data-closing", "true").addClass(this.settings.animate.exit);
            self.reposition(posX);
            if ($.isFunction(self.settings.onClose)) {
                self.settings.onClose.call(this.$ele);
            }
            this.$ele.one(this.animations.start, function() {
                hasAnimation = true;
            }).one(this.animations.end, function() {
                $(this).remove();
                if ($.isFunction(self.settings.onClosed)) {
                    self.settings.onClosed.call(this);
                }
            });
            setTimeout(function() {
                if (!hasAnimation) {
                    self.$ele.remove();
                    if ($.isFunction(self.settings.onClosed)) {
                        self.settings.onClosed.call(this);
                    }
                }
            }, 600);
        },
        reposition: function(posX) {
            var self = this, notifies = '[data-notify-position="' + this.settings.placement.from + "-" + this.settings.placement.align + '"]:not([data-closing="true"])', $elements = this.$ele.nextAll(notifies);
            if (this.settings.newest_on_top === true) {
                $elements = this.$ele.prevAll(notifies);
            }
            $elements.each(function() {
                $(this).css(self.settings.placement.from, posX);
                posX = parseInt(posX) + parseInt(self.settings.spacing) + $(this).outerHeight();
            });
        }
    });
    $.notify = function(content, options) {
        var plugin = new Notify(this, content, options);
        return plugin.notify;
    };
    $.notifyDefaults = function(options) {
        defaults = $.extend(true, {}, defaults, options);
        return defaults;
    };
    $.notifyClose = function(selector) {
        if (typeof selector === "undefined" || selector === "all") {
            $("[data-notify]").find('[data-notify="dismiss"]').trigger("click");
        } else if (selector === "success" || selector === "info" || selector === "warning" || selector === "danger") {
            $(".alert-" + selector + "[data-notify]").find('[data-notify="dismiss"]').trigger("click");
        } else if (selector) {
            $(selector + "[data-notify]").find('[data-notify="dismiss"]').trigger("click");
        } else {
            $('[data-notify-position="' + selector + '"]').find('[data-notify="dismiss"]').trigger("click");
        }
    };
    $.notifyCloseExcept = function(selector) {
        if (selector === "success" || selector === "info" || selector === "warning" || selector === "danger") {
            $("[data-notify]").not(".alert-" + selector).find('[data-notify="dismiss"]').trigger("click");
        } else {
            $("[data-notify]").not(selector).find('[data-notify="dismiss"]').trigger("click");
        }
    };
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof module === "object" && module.exports) {
        module.exports = function(root, jQuery) {
            if (jQuery === undefined) {
                if (typeof window !== "undefined") {
                    jQuery = require("jquery");
                } else {
                    jQuery = require("jquery")(root);
                }
            }
            factory(jQuery);
            return jQuery;
        };
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    var _currentSpinnerId = 0;
    $.fn.TouchSpin = function(options) {
        var defaults = {
            min: 0,
            max: 100,
            initval: "",
            replacementval: "",
            firstclickvalueifempty: null,
            step: 1,
            decimals: 0,
            stepinterval: 100,
            forcestepdivisibility: "round",
            stepintervaldelay: 500,
            verticalbuttons: false,
            verticalup: "+",
            verticaldown: "-",
            verticalupclass: "",
            verticaldownclass: "",
            prefix: "",
            postfix: "",
            prefix_extraclass: "",
            postfix_extraclass: "",
            booster: true,
            boostat: 10,
            maxboostedstep: false,
            mousewheel: true,
            buttondown_class: "btn btn-secondary",
            buttonup_class: "btn btn-secondary",
            buttondown_txt: "-",
            buttonup_txt: "+",
            callback_before_calculation: function(value) {
                return value;
            },
            callback_after_calculation: function(value) {
                return value;
            }
        };
        var attributeMap = {
            min: "min",
            max: "max",
            initval: "init-val",
            replacementval: "replacement-val",
            firstclickvalueifempty: "first-click-value-if-empty",
            step: "step",
            decimals: "decimals",
            stepinterval: "step-interval",
            verticalbuttons: "vertical-buttons",
            verticalupclass: "vertical-up-class",
            verticaldownclass: "vertical-down-class",
            forcestepdivisibility: "force-step-divisibility",
            stepintervaldelay: "step-interval-delay",
            prefix: "prefix",
            postfix: "postfix",
            prefix_extraclass: "prefix-extra-class",
            postfix_extraclass: "postfix-extra-class",
            booster: "booster",
            boostat: "boostat",
            maxboostedstep: "max-boosted-step",
            mousewheel: "mouse-wheel",
            buttondown_class: "button-down-class",
            buttonup_class: "button-up-class",
            buttondown_txt: "button-down-txt",
            buttonup_txt: "button-up-txt"
        };
        return this.each(function() {
            var settings, originalinput = $(this), originalinput_data = originalinput.data(), _detached_prefix, _detached_postfix, container, elements, value, downSpinTimer, upSpinTimer, downDelayTimeout, upDelayTimeout, spincount = 0, spinning = false;
            init();
            function init() {
                if (originalinput.data("alreadyinitialized")) {
                    return;
                }
                originalinput.data("alreadyinitialized", true);
                _currentSpinnerId += 1;
                originalinput.data("spinnerid", _currentSpinnerId);
                if (!originalinput.is("input")) {
                    console.log("Must be an input.");
                    return;
                }
                _initSettings();
                _setInitval();
                _checkValue();
                _buildHtml();
                _initElements();
                _hideEmptyPrefixPostfix();
                _bindEvents();
                _bindEventsInterface();
            }
            function _setInitval() {
                if (settings.initval !== "" && originalinput.val() === "") {
                    originalinput.val(settings.initval);
                }
            }
            function changeSettings(newsettings) {
                _updateSettings(newsettings);
                _checkValue();
                var value = elements.input.val();
                if (value !== "") {
                    value = Number(settings.callback_before_calculation(elements.input.val()));
                    elements.input.val(settings.callback_after_calculation(Number(value).toFixed(settings.decimals)));
                }
            }
            function _initSettings() {
                settings = $.extend({}, defaults, originalinput_data, _parseAttributes(), options);
            }
            function _parseAttributes() {
                var data = {};
                $.each(attributeMap, function(key, value) {
                    var attrName = "bts-" + value + "";
                    if (originalinput.is("[data-" + attrName + "]")) {
                        data[key] = originalinput.data(attrName);
                    }
                });
                return data;
            }
            function _destroy() {
                var $parent = originalinput.parent();
                stopSpin();
                originalinput.off(".touchspin");
                if ($parent.hasClass("bootstrap-touchspin-injected")) {
                    originalinput.siblings().remove();
                    originalinput.unwrap();
                } else {
                    $(".bootstrap-touchspin-injected", $parent).remove();
                    $parent.removeClass("bootstrap-touchspin");
                }
                originalinput.data("alreadyinitialized", false);
            }
            function _updateSettings(newsettings) {
                settings = $.extend({}, settings, newsettings);
                if (newsettings.postfix) {
                    var $postfix = originalinput.parent().find(".bootstrap-touchspin-postfix");
                    if ($postfix.length === 0) {
                        _detached_postfix.insertAfter(originalinput);
                    }
                    originalinput.parent().find(".bootstrap-touchspin-postfix .input-group-text").text(newsettings.postfix);
                }
                if (newsettings.prefix) {
                    var $prefix = originalinput.parent().find(".bootstrap-touchspin-prefix");
                    if ($prefix.length === 0) {
                        _detached_prefix.insertBefore(originalinput);
                    }
                    originalinput.parent().find(".bootstrap-touchspin-prefix .input-group-text").text(newsettings.prefix);
                }
                _hideEmptyPrefixPostfix();
            }
            function _buildHtml() {
                var initval = originalinput.val(), parentelement = originalinput.parent();
                if (initval !== "") {
                    initval = settings.callback_after_calculation(Number(initval).toFixed(settings.decimals));
                }
                originalinput.data("initvalue", initval).val(initval);
                originalinput.addClass("form-control");
                if (parentelement.hasClass("input-group")) {
                    _advanceInputGroup(parentelement);
                } else {
                    _buildInputGroup();
                }
            }
            function _advanceInputGroup(parentelement) {
                parentelement.addClass("bootstrap-touchspin");
                var prev = originalinput.prev(), next = originalinput.next();
                var downhtml, uphtml, prefixhtml = '<span class="input-group-text">' + settings.prefix + "</span>", postfixhtml = '<span class="input-group-text">' + settings.postfix + "</span>";
                if (prev.hasClass("input-group-btn") || prev.hasClass("input-group-prepend")) {
                    downhtml = '<button class="' + settings.buttondown_class + ' bootstrap-touchspin-down bootstrap-touchspin-injected" type="button">' + settings.buttondown_txt + "</button>";
                    prev.append(downhtml);
                } else {
                    downhtml = '<button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + "</button>";
                    $(downhtml).insertBefore(originalinput);
                }
                if (next.hasClass("input-group-btn") || next.hasClass("input-group-append")) {
                    uphtml = '<button class="' + settings.buttonup_class + ' bootstrap-touchspin-up bootstrap-touchspin-injected" type="button">' + settings.buttonup_txt + "</button>";
                    next.prepend(uphtml);
                } else {
                    uphtml = '<button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + "</button>";
                    $(uphtml).insertAfter(originalinput);
                }
                container = parentelement;
            }
            function _buildInputGroup() {
                var html;
                var inputGroupSize = "";
                if (originalinput.hasClass("input-sm")) {
                    inputGroupSize = "input-group-sm";
                }
                if (originalinput.hasClass("input-lg")) {
                    inputGroupSize = "input-group-lg";
                }
                if (settings.verticalbuttons) {
                    html = '<div class="input-group ' + inputGroupSize + ' bootstrap-touchspin bootstrap-touchspin-injected"><span class="input-group-text">' + settings.prefix + '</span><span class="input-group-text">' + settings.postfix + '</span><span class="input-group-btn-vertical"><button class="' + settings.buttondown_class + " bootstrap-touchspin-up " + settings.verticalupclass + '" type="button">' + settings.verticalup + '</button><button class="' + settings.buttonup_class + " bootstrap-touchspin-down " + settings.verticaldownclass + '" type="button">' + settings.verticaldown + "</button></span></div>";
                } else {
                    html = '<div class="input-group bootstrap-touchspin bootstrap-touchspin-injected"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button><span class="input-group-addon bootstrap-touchspin-prefix input-group-prepend"><span class="input-group-text">' + settings.prefix + '</span></span><span class="input-group-addon bootstrap-touchspin-postfix input-group-append"><span class="input-group-text">' + settings.postfix + '</span></span><button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + "</button></div>";
                }
                container = $(html).insertBefore(originalinput);
                $(".bootstrap-touchspin-prefix", container).after(originalinput);
                if (originalinput.hasClass("input-sm")) {
                    container.addClass("input-group-sm");
                } else if (originalinput.hasClass("input-lg")) {
                    container.addClass("input-group-lg");
                }
            }
            function _initElements() {
                elements = {
                    down: $(".bootstrap-touchspin-down", container),
                    up: $(".bootstrap-touchspin-up", container),
                    input: $("input", container),
                    prefix: $(".bootstrap-touchspin-prefix", container).addClass(settings.prefix_extraclass),
                    postfix: $(".bootstrap-touchspin-postfix", container).addClass(settings.postfix_extraclass)
                };
            }
            function _hideEmptyPrefixPostfix() {
                if (settings.prefix === "") {
                    _detached_prefix = elements.prefix.detach();
                }
                if (settings.postfix === "") {
                    _detached_postfix = elements.postfix.detach();
                }
            }
            function _bindEvents() {
                originalinput.on("keydown.touchspin", function(ev) {
                    var code = ev.keyCode || ev.which;
                    if (code === 38) {
                        if (spinning !== "up") {
                            upOnce();
                            startUpSpin();
                        }
                        ev.preventDefault();
                    } else if (code === 40) {
                        if (spinning !== "down") {
                            downOnce();
                            startDownSpin();
                        }
                        ev.preventDefault();
                    }
                });
                originalinput.on("keyup.touchspin", function(ev) {
                    var code = ev.keyCode || ev.which;
                    if (code === 38) {
                        stopSpin();
                    } else if (code === 40) {
                        stopSpin();
                    }
                });
                originalinput.on("blur.touchspin", function() {
                    _checkValue();
                    originalinput.val(settings.callback_after_calculation(originalinput.val()));
                });
                elements.down.on("keydown", function(ev) {
                    var code = ev.keyCode || ev.which;
                    if (code === 32 || code === 13) {
                        if (spinning !== "down") {
                            downOnce();
                            startDownSpin();
                        }
                        ev.preventDefault();
                    }
                });
                elements.down.on("keyup.touchspin", function(ev) {
                    var code = ev.keyCode || ev.which;
                    if (code === 32 || code === 13) {
                        stopSpin();
                    }
                });
                elements.up.on("keydown.touchspin", function(ev) {
                    var code = ev.keyCode || ev.which;
                    if (code === 32 || code === 13) {
                        if (spinning !== "up") {
                            upOnce();
                            startUpSpin();
                        }
                        ev.preventDefault();
                    }
                });
                elements.up.on("keyup.touchspin", function(ev) {
                    var code = ev.keyCode || ev.which;
                    if (code === 32 || code === 13) {
                        stopSpin();
                    }
                });
                elements.down.on("mousedown.touchspin", function(ev) {
                    elements.down.off("touchstart.touchspin");
                    if (originalinput.is(":disabled")) {
                        return;
                    }
                    downOnce();
                    startDownSpin();
                    ev.preventDefault();
                    ev.stopPropagation();
                });
                elements.down.on("touchstart.touchspin", function(ev) {
                    elements.down.off("mousedown.touchspin");
                    if (originalinput.is(":disabled")) {
                        return;
                    }
                    downOnce();
                    startDownSpin();
                    ev.preventDefault();
                    ev.stopPropagation();
                });
                elements.up.on("mousedown.touchspin", function(ev) {
                    elements.up.off("touchstart.touchspin");
                    if (originalinput.is(":disabled")) {
                        return;
                    }
                    upOnce();
                    startUpSpin();
                    ev.preventDefault();
                    ev.stopPropagation();
                });
                elements.up.on("touchstart.touchspin", function(ev) {
                    elements.up.off("mousedown.touchspin");
                    if (originalinput.is(":disabled")) {
                        return;
                    }
                    upOnce();
                    startUpSpin();
                    ev.preventDefault();
                    ev.stopPropagation();
                });
                elements.up.on("mouseup.touchspin mouseout.touchspin touchleave.touchspin touchend.touchspin touchcancel.touchspin", function(ev) {
                    if (!spinning) {
                        return;
                    }
                    ev.stopPropagation();
                    stopSpin();
                });
                elements.down.on("mouseup.touchspin mouseout.touchspin touchleave.touchspin touchend.touchspin touchcancel.touchspin", function(ev) {
                    if (!spinning) {
                        return;
                    }
                    ev.stopPropagation();
                    stopSpin();
                });
                elements.down.on("mousemove.touchspin touchmove.touchspin", function(ev) {
                    if (!spinning) {
                        return;
                    }
                    ev.stopPropagation();
                    ev.preventDefault();
                });
                elements.up.on("mousemove.touchspin touchmove.touchspin", function(ev) {
                    if (!spinning) {
                        return;
                    }
                    ev.stopPropagation();
                    ev.preventDefault();
                });
                originalinput.on("mousewheel.touchspin DOMMouseScroll.touchspin", function(ev) {
                    if (!settings.mousewheel || !originalinput.is(":focus")) {
                        return;
                    }
                    var delta = ev.originalEvent.wheelDelta || -ev.originalEvent.deltaY || -ev.originalEvent.detail;
                    ev.stopPropagation();
                    ev.preventDefault();
                    if (delta < 0) {
                        downOnce();
                    } else {
                        upOnce();
                    }
                });
            }
            function _bindEventsInterface() {
                originalinput.on("touchspin.destroy", function() {
                    _destroy();
                });
                originalinput.on("touchspin.uponce", function() {
                    stopSpin();
                    upOnce();
                });
                originalinput.on("touchspin.downonce", function() {
                    stopSpin();
                    downOnce();
                });
                originalinput.on("touchspin.startupspin", function() {
                    startUpSpin();
                });
                originalinput.on("touchspin.startdownspin", function() {
                    startDownSpin();
                });
                originalinput.on("touchspin.stopspin", function() {
                    stopSpin();
                });
                originalinput.on("touchspin.updatesettings", function(e, newsettings) {
                    changeSettings(newsettings);
                });
            }
            function _forcestepdivisibility(value) {
                switch (settings.forcestepdivisibility) {
                  case "round":
                    return (Math.round(value / settings.step) * settings.step).toFixed(settings.decimals);

                  case "floor":
                    return (Math.floor(value / settings.step) * settings.step).toFixed(settings.decimals);

                  case "ceil":
                    return (Math.ceil(value / settings.step) * settings.step).toFixed(settings.decimals);

                  default:
                    return value.toFixed(settings.decimals);
                }
            }
            function _checkValue() {
                var val, parsedval, returnval;
                val = settings.callback_before_calculation(originalinput.val());
                if (val === "") {
                    if (settings.replacementval !== "") {
                        originalinput.val(settings.replacementval);
                        originalinput.trigger("change");
                    }
                    return;
                }
                if (settings.decimals > 0 && val === ".") {
                    return;
                }
                parsedval = parseFloat(val);
                if (isNaN(parsedval)) {
                    if (settings.replacementval !== "") {
                        parsedval = settings.replacementval;
                    } else {
                        parsedval = 0;
                    }
                }
                returnval = parsedval;
                if (parsedval.toString() !== val) {
                    returnval = parsedval;
                }
                if (settings.min !== null && parsedval < settings.min) {
                    returnval = settings.min;
                }
                if (settings.max !== null && parsedval > settings.max) {
                    returnval = settings.max;
                }
                returnval = _forcestepdivisibility(returnval);
                if (Number(val).toString() !== returnval.toString()) {
                    originalinput.val(returnval);
                    originalinput.trigger("change");
                }
            }
            function _getBoostedStep() {
                if (!settings.booster) {
                    return settings.step;
                } else {
                    var boosted = Math.pow(2, Math.floor(spincount / settings.boostat)) * settings.step;
                    if (settings.maxboostedstep) {
                        if (boosted > settings.maxboostedstep) {
                            boosted = settings.maxboostedstep;
                            value = Math.round(value / boosted) * boosted;
                        }
                    }
                    return Math.max(settings.step, boosted);
                }
            }
            function valueIfIsNaN() {
                if (typeof settings.firstclickvalueifempty === "number") {
                    return settings.firstclickvalueifempty;
                } else {
                    return (settings.min + settings.max) / 2;
                }
            }
            function upOnce() {
                _checkValue();
                value = parseFloat(settings.callback_before_calculation(elements.input.val()));
                var initvalue = value;
                var boostedstep;
                if (isNaN(value)) {
                    value = valueIfIsNaN();
                } else {
                    boostedstep = _getBoostedStep();
                    value = value + boostedstep;
                }
                if (settings.max !== null && value > settings.max) {
                    value = settings.max;
                    originalinput.trigger("touchspin.on.max");
                    stopSpin();
                }
                elements.input.val(settings.callback_after_calculation(Number(value).toFixed(settings.decimals)));
                if (initvalue !== value) {
                    originalinput.trigger("change");
                }
            }
            function downOnce() {
                _checkValue();
                value = parseFloat(settings.callback_before_calculation(elements.input.val()));
                var initvalue = value;
                var boostedstep;
                if (isNaN(value)) {
                    value = valueIfIsNaN();
                } else {
                    boostedstep = _getBoostedStep();
                    value = value - boostedstep;
                }
                if (settings.min !== null && value < settings.min) {
                    value = settings.min;
                    originalinput.trigger("touchspin.on.min");
                    stopSpin();
                }
                elements.input.val(settings.callback_after_calculation(Number(value).toFixed(settings.decimals)));
                if (initvalue !== value) {
                    originalinput.trigger("change");
                }
            }
            function startDownSpin() {
                stopSpin();
                spincount = 0;
                spinning = "down";
                originalinput.trigger("touchspin.on.startspin");
                originalinput.trigger("touchspin.on.startdownspin");
                downDelayTimeout = setTimeout(function() {
                    downSpinTimer = setInterval(function() {
                        spincount++;
                        downOnce();
                    }, settings.stepinterval);
                }, settings.stepintervaldelay);
            }
            function startUpSpin() {
                stopSpin();
                spincount = 0;
                spinning = "up";
                originalinput.trigger("touchspin.on.startspin");
                originalinput.trigger("touchspin.on.startupspin");
                upDelayTimeout = setTimeout(function() {
                    upSpinTimer = setInterval(function() {
                        spincount++;
                        upOnce();
                    }, settings.stepinterval);
                }, settings.stepintervaldelay);
            }
            function stopSpin() {
                clearTimeout(downDelayTimeout);
                clearTimeout(upDelayTimeout);
                clearInterval(downSpinTimer);
                clearInterval(upSpinTimer);
                switch (spinning) {
                  case "up":
                    originalinput.trigger("touchspin.on.stopupspin");
                    originalinput.trigger("touchspin.on.stopspin");
                    break;

                  case "down":
                    originalinput.trigger("touchspin.on.stopdownspin");
                    originalinput.trigger("touchspin.on.stopspin");
                    break;
                }
                spincount = 0;
                spinning = false;
            }
        });
    };
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof module === "object" && module.exports) {
        module.exports = function(root, jQuery) {
            if (jQuery === undefined) {
                if (typeof window !== "undefined") {
                    jQuery = require("jquery");
                } else {
                    jQuery = require("jquery")(root);
                }
            }
            factory(jQuery);
            return jQuery;
        };
    } else {
        factory(jQuery);
    }
})(function(jQuery) {
    var S2 = function() {
        if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
            var S2 = jQuery.fn.select2.amd;
        }
        var S2;
        (function() {
            if (!S2 || !S2.requirejs) {
                if (!S2) {
                    S2 = {};
                } else {
                    require = S2;
                }
                var requirejs, require, define;
                (function(undef) {
                    var main, req, makeMap, handlers, defined = {}, waiting = {}, config = {}, defining = {}, hasOwn = Object.prototype.hasOwnProperty, aps = [].slice, jsSuffixRegExp = /\.js$/;
                    function hasProp(obj, prop) {
                        return hasOwn.call(obj, prop);
                    }
                    function normalize(name, baseName) {
                        var nameParts, nameSegment, mapValue, foundMap, lastIndex, foundI, foundStarMap, starI, i, j, part, normalizedBaseParts, baseParts = baseName && baseName.split("/"), map = config.map, starMap = map && map["*"] || {};
                        if (name) {
                            name = name.split("/");
                            lastIndex = name.length - 1;
                            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, "");
                            }
                            if (name[0].charAt(0) === "." && baseParts) {
                                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                                name = normalizedBaseParts.concat(name);
                            }
                            for (i = 0; i < name.length; i++) {
                                part = name[i];
                                if (part === ".") {
                                    name.splice(i, 1);
                                    i -= 1;
                                } else if (part === "..") {
                                    if (i === 0 || i === 1 && name[2] === ".." || name[i - 1] === "..") {
                                        continue;
                                    } else if (i > 0) {
                                        name.splice(i - 1, 2);
                                        i -= 2;
                                    }
                                }
                            }
                            name = name.join("/");
                        }
                        if ((baseParts || starMap) && map) {
                            nameParts = name.split("/");
                            for (i = nameParts.length; i > 0; i -= 1) {
                                nameSegment = nameParts.slice(0, i).join("/");
                                if (baseParts) {
                                    for (j = baseParts.length; j > 0; j -= 1) {
                                        mapValue = map[baseParts.slice(0, j).join("/")];
                                        if (mapValue) {
                                            mapValue = mapValue[nameSegment];
                                            if (mapValue) {
                                                foundMap = mapValue;
                                                foundI = i;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (foundMap) {
                                    break;
                                }
                                if (!foundStarMap && starMap && starMap[nameSegment]) {
                                    foundStarMap = starMap[nameSegment];
                                    starI = i;
                                }
                            }
                            if (!foundMap && foundStarMap) {
                                foundMap = foundStarMap;
                                foundI = starI;
                            }
                            if (foundMap) {
                                nameParts.splice(0, foundI, foundMap);
                                name = nameParts.join("/");
                            }
                        }
                        return name;
                    }
                    function makeRequire(relName, forceSync) {
                        return function() {
                            var args = aps.call(arguments, 0);
                            if (typeof args[0] !== "string" && args.length === 1) {
                                args.push(null);
                            }
                            return req.apply(undef, args.concat([ relName, forceSync ]));
                        };
                    }
                    function makeNormalize(relName) {
                        return function(name) {
                            return normalize(name, relName);
                        };
                    }
                    function makeLoad(depName) {
                        return function(value) {
                            defined[depName] = value;
                        };
                    }
                    function callDep(name) {
                        if (hasProp(waiting, name)) {
                            var args = waiting[name];
                            delete waiting[name];
                            defining[name] = true;
                            main.apply(undef, args);
                        }
                        if (!hasProp(defined, name) && !hasProp(defining, name)) {
                            throw new Error("No " + name);
                        }
                        return defined[name];
                    }
                    function splitPrefix(name) {
                        var prefix, index = name ? name.indexOf("!") : -1;
                        if (index > -1) {
                            prefix = name.substring(0, index);
                            name = name.substring(index + 1, name.length);
                        }
                        return [ prefix, name ];
                    }
                    function makeRelParts(relName) {
                        return relName ? splitPrefix(relName) : [];
                    }
                    makeMap = function(name, relParts) {
                        var plugin, parts = splitPrefix(name), prefix = parts[0], relResourceName = relParts[1];
                        name = parts[1];
                        if (prefix) {
                            prefix = normalize(prefix, relResourceName);
                            plugin = callDep(prefix);
                        }
                        if (prefix) {
                            if (plugin && plugin.normalize) {
                                name = plugin.normalize(name, makeNormalize(relResourceName));
                            } else {
                                name = normalize(name, relResourceName);
                            }
                        } else {
                            name = normalize(name, relResourceName);
                            parts = splitPrefix(name);
                            prefix = parts[0];
                            name = parts[1];
                            if (prefix) {
                                plugin = callDep(prefix);
                            }
                        }
                        return {
                            f: prefix ? prefix + "!" + name : name,
                            n: name,
                            pr: prefix,
                            p: plugin
                        };
                    };
                    function makeConfig(name) {
                        return function() {
                            return config && config.config && config.config[name] || {};
                        };
                    }
                    handlers = {
                        require: function(name) {
                            return makeRequire(name);
                        },
                        exports: function(name) {
                            var e = defined[name];
                            if (typeof e !== "undefined") {
                                return e;
                            } else {
                                return defined[name] = {};
                            }
                        },
                        module: function(name) {
                            return {
                                id: name,
                                uri: "",
                                exports: defined[name],
                                config: makeConfig(name)
                            };
                        }
                    };
                    main = function(name, deps, callback, relName) {
                        var cjsModule, depName, ret, map, i, relParts, args = [], callbackType = typeof callback, usingExports;
                        relName = relName || name;
                        relParts = makeRelParts(relName);
                        if (callbackType === "undefined" || callbackType === "function") {
                            deps = !deps.length && callback.length ? [ "require", "exports", "module" ] : deps;
                            for (i = 0; i < deps.length; i += 1) {
                                map = makeMap(deps[i], relParts);
                                depName = map.f;
                                if (depName === "require") {
                                    args[i] = handlers.require(name);
                                } else if (depName === "exports") {
                                    args[i] = handlers.exports(name);
                                    usingExports = true;
                                } else if (depName === "module") {
                                    cjsModule = args[i] = handlers.module(name);
                                } else if (hasProp(defined, depName) || hasProp(waiting, depName) || hasProp(defining, depName)) {
                                    args[i] = callDep(depName);
                                } else if (map.p) {
                                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                                    args[i] = defined[depName];
                                } else {
                                    throw new Error(name + " missing " + depName);
                                }
                            }
                            ret = callback ? callback.apply(defined[name], args) : undefined;
                            if (name) {
                                if (cjsModule && cjsModule.exports !== undef && cjsModule.exports !== defined[name]) {
                                    defined[name] = cjsModule.exports;
                                } else if (ret !== undef || !usingExports) {
                                    defined[name] = ret;
                                }
                            }
                        } else if (name) {
                            defined[name] = callback;
                        }
                    };
                    requirejs = require = req = function(deps, callback, relName, forceSync, alt) {
                        if (typeof deps === "string") {
                            if (handlers[deps]) {
                                return handlers[deps](callback);
                            }
                            return callDep(makeMap(deps, makeRelParts(callback)).f);
                        } else if (!deps.splice) {
                            config = deps;
                            if (config.deps) {
                                req(config.deps, config.callback);
                            }
                            if (!callback) {
                                return;
                            }
                            if (callback.splice) {
                                deps = callback;
                                callback = relName;
                                relName = null;
                            } else {
                                deps = undef;
                            }
                        }
                        callback = callback || function() {};
                        if (typeof relName === "function") {
                            relName = forceSync;
                            forceSync = alt;
                        }
                        if (forceSync) {
                            main(undef, deps, callback, relName);
                        } else {
                            setTimeout(function() {
                                main(undef, deps, callback, relName);
                            }, 4);
                        }
                        return req;
                    };
                    req.config = function(cfg) {
                        return req(cfg);
                    };
                    requirejs._defined = defined;
                    define = function(name, deps, callback) {
                        if (typeof name !== "string") {
                            throw new Error("See almond README: incorrect module build, no module name");
                        }
                        if (!deps.splice) {
                            callback = deps;
                            deps = [];
                        }
                        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
                            waiting[name] = [ name, deps, callback ];
                        }
                    };
                    define.amd = {
                        jQuery: true
                    };
                })();
                S2.requirejs = requirejs;
                S2.require = require;
                S2.define = define;
            }
        })();
        S2.define("almond", function() {});
        S2.define("jquery", [], function() {
            var _$ = jQuery || $;
            if (_$ == null && console && console.error) {
                console.error("Select2: An instance of jQuery or a jQuery-compatible library was not " + "found. Make sure that you are including jQuery before Select2 on your " + "web page.");
            }
            return _$;
        });
        S2.define("select2/utils", [ "jquery" ], function($) {
            var Utils = {};
            Utils.Extend = function(ChildClass, SuperClass) {
                var __hasProp = {}.hasOwnProperty;
                function BaseConstructor() {
                    this.constructor = ChildClass;
                }
                for (var key in SuperClass) {
                    if (__hasProp.call(SuperClass, key)) {
                        ChildClass[key] = SuperClass[key];
                    }
                }
                BaseConstructor.prototype = SuperClass.prototype;
                ChildClass.prototype = new BaseConstructor();
                ChildClass.__super__ = SuperClass.prototype;
                return ChildClass;
            };
            function getMethods(theClass) {
                var proto = theClass.prototype;
                var methods = [];
                for (var methodName in proto) {
                    var m = proto[methodName];
                    if (typeof m !== "function") {
                        continue;
                    }
                    if (methodName === "constructor") {
                        continue;
                    }
                    methods.push(methodName);
                }
                return methods;
            }
            Utils.Decorate = function(SuperClass, DecoratorClass) {
                var decoratedMethods = getMethods(DecoratorClass);
                var superMethods = getMethods(SuperClass);
                function DecoratedClass() {
                    var unshift = Array.prototype.unshift;
                    var argCount = DecoratorClass.prototype.constructor.length;
                    var calledConstructor = SuperClass.prototype.constructor;
                    if (argCount > 0) {
                        unshift.call(arguments, SuperClass.prototype.constructor);
                        calledConstructor = DecoratorClass.prototype.constructor;
                    }
                    calledConstructor.apply(this, arguments);
                }
                DecoratorClass.displayName = SuperClass.displayName;
                function ctr() {
                    this.constructor = DecoratedClass;
                }
                DecoratedClass.prototype = new ctr();
                for (var m = 0; m < superMethods.length; m++) {
                    var superMethod = superMethods[m];
                    DecoratedClass.prototype[superMethod] = SuperClass.prototype[superMethod];
                }
                var calledMethod = function(methodName) {
                    var originalMethod = function() {};
                    if (methodName in DecoratedClass.prototype) {
                        originalMethod = DecoratedClass.prototype[methodName];
                    }
                    var decoratedMethod = DecoratorClass.prototype[methodName];
                    return function() {
                        var unshift = Array.prototype.unshift;
                        unshift.call(arguments, originalMethod);
                        return decoratedMethod.apply(this, arguments);
                    };
                };
                for (var d = 0; d < decoratedMethods.length; d++) {
                    var decoratedMethod = decoratedMethods[d];
                    DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
                }
                return DecoratedClass;
            };
            var Observable = function() {
                this.listeners = {};
            };
            Observable.prototype.on = function(event, callback) {
                this.listeners = this.listeners || {};
                if (event in this.listeners) {
                    this.listeners[event].push(callback);
                } else {
                    this.listeners[event] = [ callback ];
                }
            };
            Observable.prototype.trigger = function(event) {
                var slice = Array.prototype.slice;
                var params = slice.call(arguments, 1);
                this.listeners = this.listeners || {};
                if (params == null) {
                    params = [];
                }
                if (params.length === 0) {
                    params.push({});
                }
                params[0]._type = event;
                if (event in this.listeners) {
                    this.invoke(this.listeners[event], slice.call(arguments, 1));
                }
                if ("*" in this.listeners) {
                    this.invoke(this.listeners["*"], arguments);
                }
            };
            Observable.prototype.invoke = function(listeners, params) {
                for (var i = 0, len = listeners.length; i < len; i++) {
                    listeners[i].apply(this, params);
                }
            };
            Utils.Observable = Observable;
            Utils.generateChars = function(length) {
                var chars = "";
                for (var i = 0; i < length; i++) {
                    var randomChar = Math.floor(Math.random() * 36);
                    chars += randomChar.toString(36);
                }
                return chars;
            };
            Utils.bind = function(func, context) {
                return function() {
                    func.apply(context, arguments);
                };
            };
            Utils._convertData = function(data) {
                for (var originalKey in data) {
                    var keys = originalKey.split("-");
                    var dataLevel = data;
                    if (keys.length === 1) {
                        continue;
                    }
                    for (var k = 0; k < keys.length; k++) {
                        var key = keys[k];
                        key = key.substring(0, 1).toLowerCase() + key.substring(1);
                        if (!(key in dataLevel)) {
                            dataLevel[key] = {};
                        }
                        if (k == keys.length - 1) {
                            dataLevel[key] = data[originalKey];
                        }
                        dataLevel = dataLevel[key];
                    }
                    delete data[originalKey];
                }
                return data;
            };
            Utils.hasScroll = function(index, el) {
                var $el = $(el);
                var overflowX = el.style.overflowX;
                var overflowY = el.style.overflowY;
                if (overflowX === overflowY && (overflowY === "hidden" || overflowY === "visible")) {
                    return false;
                }
                if (overflowX === "scroll" || overflowY === "scroll") {
                    return true;
                }
                return $el.innerHeight() < el.scrollHeight || $el.innerWidth() < el.scrollWidth;
            };
            Utils.escapeMarkup = function(markup) {
                var replaceMap = {
                    "\\": "&#92;",
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#39;",
                    "/": "&#47;"
                };
                if (typeof markup !== "string") {
                    return markup;
                }
                return String(markup).replace(/[&<>"'\/\\]/g, function(match) {
                    return replaceMap[match];
                });
            };
            Utils.__cache = {};
            var id = 0;
            Utils.GetUniqueElementId = function(element) {
                var select2Id = element.getAttribute("data-select2-id");
                if (select2Id != null) {
                    return select2Id;
                }
                if (element.id) {
                    select2Id = "select2-data-" + element.id;
                } else {
                    select2Id = "select2-data-" + (++id).toString() + "-" + Utils.generateChars(4);
                }
                element.setAttribute("data-select2-id", select2Id);
                return select2Id;
            };
            Utils.StoreData = function(element, name, value) {
                var id = Utils.GetUniqueElementId(element);
                if (!Utils.__cache[id]) {
                    Utils.__cache[id] = {};
                }
                Utils.__cache[id][name] = value;
            };
            Utils.GetData = function(element, name) {
                var id = Utils.GetUniqueElementId(element);
                if (name) {
                    if (Utils.__cache[id]) {
                        if (Utils.__cache[id][name] != null) {
                            return Utils.__cache[id][name];
                        }
                        return $(element).data(name);
                    }
                    return $(element).data(name);
                } else {
                    return Utils.__cache[id];
                }
            };
            Utils.RemoveData = function(element) {
                var id = Utils.GetUniqueElementId(element);
                if (Utils.__cache[id] != null) {
                    delete Utils.__cache[id];
                }
                element.removeAttribute("data-select2-id");
            };
            Utils.copyNonInternalCssClasses = function(dest, src) {
                var classes;
                var destinationClasses = dest.getAttribute("class").trim().split(/\s+/);
                destinationClasses = destinationClasses.filter(function(clazz) {
                    return clazz.indexOf("select2-") === 0;
                });
                var sourceClasses = src.getAttribute("class").trim().split(/\s+/);
                sourceClasses = sourceClasses.filter(function(clazz) {
                    return clazz.indexOf("select2-") !== 0;
                });
                var replacements = destinationClasses.concat(sourceClasses);
                dest.setAttribute("class", replacements.join(" "));
            };
            return Utils;
        });
        S2.define("select2/results", [ "jquery", "./utils" ], function($, Utils) {
            function Results($element, options, dataAdapter) {
                this.$element = $element;
                this.data = dataAdapter;
                this.options = options;
                Results.__super__.constructor.call(this);
            }
            Utils.Extend(Results, Utils.Observable);
            Results.prototype.render = function() {
                var $results = $('<ul class="select2-results__options" role="listbox"></ul>');
                if (this.options.get("multiple")) {
                    $results.attr("aria-multiselectable", "true");
                }
                this.$results = $results;
                return $results;
            };
            Results.prototype.clear = function() {
                this.$results.empty();
            };
            Results.prototype.displayMessage = function(params) {
                var escapeMarkup = this.options.get("escapeMarkup");
                this.clear();
                this.hideLoading();
                var $message = $('<li role="alert" aria-live="assertive"' + ' class="select2-results__option"></li>');
                var message = this.options.get("translations").get(params.message);
                $message.append(escapeMarkup(message(params.args)));
                $message[0].className += " select2-results__message";
                this.$results.append($message);
            };
            Results.prototype.hideMessages = function() {
                this.$results.find(".select2-results__message").remove();
            };
            Results.prototype.append = function(data) {
                this.hideLoading();
                var $options = [];
                if (data.results == null || data.results.length === 0) {
                    if (this.$results.children().length === 0) {
                        this.trigger("results:message", {
                            message: "noResults"
                        });
                    }
                    return;
                }
                data.results = this.sort(data.results);
                for (var d = 0; d < data.results.length; d++) {
                    var item = data.results[d];
                    var $option = this.option(item);
                    $options.push($option);
                }
                this.$results.append($options);
            };
            Results.prototype.position = function($results, $dropdown) {
                var $resultsContainer = $dropdown.find(".select2-results");
                $resultsContainer.append($results);
            };
            Results.prototype.sort = function(data) {
                var sorter = this.options.get("sorter");
                return sorter(data);
            };
            Results.prototype.highlightFirstItem = function() {
                var $options = this.$results.find(".select2-results__option--selectable");
                var $selected = $options.filter(".select2-results__option--selected");
                if ($selected.length > 0) {
                    $selected.first().trigger("mouseenter");
                } else {
                    $options.first().trigger("mouseenter");
                }
                this.ensureHighlightVisible();
            };
            Results.prototype.setClasses = function() {
                var self = this;
                this.data.current(function(selected) {
                    var selectedIds = selected.map(function(s) {
                        return s.id.toString();
                    });
                    var $options = self.$results.find(".select2-results__option--selectable");
                    $options.each(function() {
                        var $option = $(this);
                        var item = Utils.GetData(this, "data");
                        var id = "" + item.id;
                        if (item.element != null && item.element.selected || item.element == null && selectedIds.indexOf(id) > -1) {
                            this.classList.add("select2-results__option--selected");
                            $option.attr("aria-selected", "true");
                        } else {
                            this.classList.remove("select2-results__option--selected");
                            $option.attr("aria-selected", "false");
                        }
                    });
                });
            };
            Results.prototype.showLoading = function(params) {
                this.hideLoading();
                var loadingMore = this.options.get("translations").get("searching");
                var loading = {
                    disabled: true,
                    loading: true,
                    text: loadingMore(params)
                };
                var $loading = this.option(loading);
                $loading.className += " loading-results";
                this.$results.prepend($loading);
            };
            Results.prototype.hideLoading = function() {
                this.$results.find(".loading-results").remove();
            };
            Results.prototype.option = function(data) {
                var option = document.createElement("li");
                option.classList.add("select2-results__option");
                option.classList.add("select2-results__option--selectable");
                var attrs = {
                    role: "option"
                };
                var matches = window.Element.prototype.matches || window.Element.prototype.msMatchesSelector || window.Element.prototype.webkitMatchesSelector;
                if (data.element != null && matches.call(data.element, ":disabled") || data.element == null && data.disabled) {
                    attrs["aria-disabled"] = "true";
                    option.classList.remove("select2-results__option--selectable");
                    option.classList.add("select2-results__option--disabled");
                }
                if (data.id == null) {
                    option.classList.remove("select2-results__option--selectable");
                }
                if (data._resultId != null) {
                    option.id = data._resultId;
                }
                if (data.title) {
                    option.title = data.title;
                }
                if (data.children) {
                    attrs.role = "group";
                    attrs["aria-label"] = data.text;
                    option.classList.remove("select2-results__option--selectable");
                    option.classList.add("select2-results__option--group");
                }
                for (var attr in attrs) {
                    var val = attrs[attr];
                    option.setAttribute(attr, val);
                }
                if (data.children) {
                    var $option = $(option);
                    var label = document.createElement("strong");
                    label.className = "select2-results__group";
                    this.template(data, label);
                    var $children = [];
                    for (var c = 0; c < data.children.length; c++) {
                        var child = data.children[c];
                        var $child = this.option(child);
                        $children.push($child);
                    }
                    var $childrenContainer = $("<ul></ul>", {
                        class: "select2-results__options select2-results__options--nested",
                        role: "none"
                    });
                    $childrenContainer.append($children);
                    $option.append(label);
                    $option.append($childrenContainer);
                } else {
                    this.template(data, option);
                }
                Utils.StoreData(option, "data", data);
                return option;
            };
            Results.prototype.bind = function(container, $container) {
                var self = this;
                var id = container.id + "-results";
                this.$results.attr("id", id);
                container.on("results:all", function(params) {
                    self.clear();
                    self.append(params.data);
                    if (container.isOpen()) {
                        self.setClasses();
                        self.highlightFirstItem();
                    }
                });
                container.on("results:append", function(params) {
                    self.append(params.data);
                    if (container.isOpen()) {
                        self.setClasses();
                    }
                });
                container.on("query", function(params) {
                    self.hideMessages();
                    self.showLoading(params);
                });
                container.on("select", function() {
                    if (!container.isOpen()) {
                        return;
                    }
                    self.setClasses();
                    if (self.options.get("scrollAfterSelect")) {
                        self.highlightFirstItem();
                    }
                });
                container.on("unselect", function() {
                    if (!container.isOpen()) {
                        return;
                    }
                    self.setClasses();
                    if (self.options.get("scrollAfterSelect")) {
                        self.highlightFirstItem();
                    }
                });
                container.on("open", function() {
                    self.$results.attr("aria-expanded", "true");
                    self.$results.attr("aria-hidden", "false");
                    self.setClasses();
                    self.ensureHighlightVisible();
                });
                container.on("close", function() {
                    self.$results.attr("aria-expanded", "false");
                    self.$results.attr("aria-hidden", "true");
                    self.$results.removeAttr("aria-activedescendant");
                });
                container.on("results:toggle", function() {
                    var $highlighted = self.getHighlightedResults();
                    if ($highlighted.length === 0) {
                        return;
                    }
                    $highlighted.trigger("mouseup");
                });
                container.on("results:select", function() {
                    var $highlighted = self.getHighlightedResults();
                    if ($highlighted.length === 0) {
                        return;
                    }
                    var data = Utils.GetData($highlighted[0], "data");
                    if ($highlighted.hasClass("select2-results__option--selected")) {
                        self.trigger("close", {});
                    } else {
                        self.trigger("select", {
                            data: data
                        });
                    }
                });
                container.on("results:previous", function() {
                    var $highlighted = self.getHighlightedResults();
                    var $options = self.$results.find(".select2-results__option--selectable");
                    var currentIndex = $options.index($highlighted);
                    if (currentIndex <= 0) {
                        return;
                    }
                    var nextIndex = currentIndex - 1;
                    if ($highlighted.length === 0) {
                        nextIndex = 0;
                    }
                    var $next = $options.eq(nextIndex);
                    $next.trigger("mouseenter");
                    var currentOffset = self.$results.offset().top;
                    var nextTop = $next.offset().top;
                    var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);
                    if (nextIndex === 0) {
                        self.$results.scrollTop(0);
                    } else if (nextTop - currentOffset < 0) {
                        self.$results.scrollTop(nextOffset);
                    }
                });
                container.on("results:next", function() {
                    var $highlighted = self.getHighlightedResults();
                    var $options = self.$results.find(".select2-results__option--selectable");
                    var currentIndex = $options.index($highlighted);
                    var nextIndex = currentIndex + 1;
                    if (nextIndex >= $options.length) {
                        return;
                    }
                    var $next = $options.eq(nextIndex);
                    $next.trigger("mouseenter");
                    var currentOffset = self.$results.offset().top + self.$results.outerHeight(false);
                    var nextBottom = $next.offset().top + $next.outerHeight(false);
                    var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;
                    if (nextIndex === 0) {
                        self.$results.scrollTop(0);
                    } else if (nextBottom > currentOffset) {
                        self.$results.scrollTop(nextOffset);
                    }
                });
                container.on("results:focus", function(params) {
                    params.element[0].classList.add("select2-results__option--highlighted");
                    params.element[0].setAttribute("aria-selected", "true");
                });
                container.on("results:message", function(params) {
                    self.displayMessage(params);
                });
                if ($.fn.mousewheel) {
                    this.$results.on("mousewheel", function(e) {
                        var top = self.$results.scrollTop();
                        var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;
                        var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
                        var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();
                        if (isAtTop) {
                            self.$results.scrollTop(0);
                            e.preventDefault();
                            e.stopPropagation();
                        } else if (isAtBottom) {
                            self.$results.scrollTop(self.$results.get(0).scrollHeight - self.$results.height());
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    });
                }
                this.$results.on("mouseup", ".select2-results__option--selectable", function(evt) {
                    var $this = $(this);
                    var data = Utils.GetData(this, "data");
                    if ($this.hasClass("select2-results__option--selected")) {
                        if (self.options.get("multiple")) {
                            self.trigger("unselect", {
                                originalEvent: evt,
                                data: data
                            });
                        } else {
                            self.trigger("close", {});
                        }
                        return;
                    }
                    self.trigger("select", {
                        originalEvent: evt,
                        data: data
                    });
                });
                this.$results.on("mouseenter", ".select2-results__option--selectable", function(evt) {
                    var data = Utils.GetData(this, "data");
                    self.getHighlightedResults().removeClass("select2-results__option--highlighted").attr("aria-selected", "false");
                    self.trigger("results:focus", {
                        data: data,
                        element: $(this)
                    });
                });
            };
            Results.prototype.getHighlightedResults = function() {
                var $highlighted = this.$results.find(".select2-results__option--highlighted");
                return $highlighted;
            };
            Results.prototype.destroy = function() {
                this.$results.remove();
            };
            Results.prototype.ensureHighlightVisible = function() {
                var $highlighted = this.getHighlightedResults();
                if ($highlighted.length === 0) {
                    return;
                }
                var $options = this.$results.find(".select2-results__option--selectable");
                var currentIndex = $options.index($highlighted);
                var currentOffset = this.$results.offset().top;
                var nextTop = $highlighted.offset().top;
                var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);
                var offsetDelta = nextTop - currentOffset;
                nextOffset -= $highlighted.outerHeight(false) * 2;
                if (currentIndex <= 2) {
                    this.$results.scrollTop(0);
                } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
                    this.$results.scrollTop(nextOffset);
                }
            };
            Results.prototype.template = function(result, container) {
                var template = this.options.get("templateResult");
                var escapeMarkup = this.options.get("escapeMarkup");
                var content = template(result, container);
                if (content == null) {
                    container.style.display = "none";
                } else if (typeof content === "string") {
                    container.innerHTML = escapeMarkup(content);
                } else {
                    $(container).append(content);
                }
            };
            return Results;
        });
        S2.define("select2/keys", [], function() {
            var KEYS = {
                BACKSPACE: 8,
                TAB: 9,
                ENTER: 13,
                SHIFT: 16,
                CTRL: 17,
                ALT: 18,
                ESC: 27,
                SPACE: 32,
                PAGE_UP: 33,
                PAGE_DOWN: 34,
                END: 35,
                HOME: 36,
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                DOWN: 40,
                DELETE: 46
            };
            return KEYS;
        });
        S2.define("select2/selection/base", [ "jquery", "../utils", "../keys" ], function($, Utils, KEYS) {
            function BaseSelection($element, options) {
                this.$element = $element;
                this.options = options;
                BaseSelection.__super__.constructor.call(this);
            }
            Utils.Extend(BaseSelection, Utils.Observable);
            BaseSelection.prototype.render = function() {
                var $selection = $('<span class="select2-selection" role="combobox" ' + ' aria-haspopup="true" aria-expanded="false">' + "</span>");
                this._tabindex = 0;
                if (Utils.GetData(this.$element[0], "old-tabindex") != null) {
                    this._tabindex = Utils.GetData(this.$element[0], "old-tabindex");
                } else if (this.$element.attr("tabindex") != null) {
                    this._tabindex = this.$element.attr("tabindex");
                }
                $selection.attr("title", this.$element.attr("title"));
                $selection.attr("tabindex", this._tabindex);
                $selection.attr("aria-disabled", "false");
                this.$selection = $selection;
                return $selection;
            };
            BaseSelection.prototype.bind = function(container, $container) {
                var self = this;
                var resultsId = container.id + "-results";
                this.container = container;
                this.$selection.on("focus", function(evt) {
                    self.trigger("focus", evt);
                });
                this.$selection.on("blur", function(evt) {
                    self._handleBlur(evt);
                });
                this.$selection.on("keydown", function(evt) {
                    self.trigger("keypress", evt);
                    if (evt.which === KEYS.SPACE) {
                        evt.preventDefault();
                    }
                });
                container.on("results:focus", function(params) {
                    self.$selection.attr("aria-activedescendant", params.data._resultId);
                });
                container.on("selection:update", function(params) {
                    self.update(params.data);
                });
                container.on("open", function() {
                    self.$selection.attr("aria-expanded", "true");
                    self.$selection.attr("aria-owns", resultsId);
                    self._attachCloseHandler(container);
                });
                container.on("close", function() {
                    self.$selection.attr("aria-expanded", "false");
                    self.$selection.removeAttr("aria-activedescendant");
                    self.$selection.removeAttr("aria-owns");
                    self.$selection.trigger("focus");
                    self._detachCloseHandler(container);
                });
                container.on("enable", function() {
                    self.$selection.attr("tabindex", self._tabindex);
                    self.$selection.attr("aria-disabled", "false");
                });
                container.on("disable", function() {
                    self.$selection.attr("tabindex", "-1");
                    self.$selection.attr("aria-disabled", "true");
                });
            };
            BaseSelection.prototype._handleBlur = function(evt) {
                var self = this;
                window.setTimeout(function() {
                    if (document.activeElement == self.$selection[0] || $.contains(self.$selection[0], document.activeElement)) {
                        return;
                    }
                    self.trigger("blur", evt);
                }, 1);
            };
            BaseSelection.prototype._attachCloseHandler = function(container) {
                $(document.body).on("mousedown.select2." + container.id, function(e) {
                    var $target = $(e.target);
                    var $select = $target.closest(".select2");
                    var $all = $(".select2.select2-container--open");
                    $all.each(function() {
                        if (this == $select[0]) {
                            return;
                        }
                        var $element = Utils.GetData(this, "element");
                        $element.select2("close");
                    });
                });
            };
            BaseSelection.prototype._detachCloseHandler = function(container) {
                $(document.body).off("mousedown.select2." + container.id);
            };
            BaseSelection.prototype.position = function($selection, $container) {
                var $selectionContainer = $container.find(".selection");
                $selectionContainer.append($selection);
            };
            BaseSelection.prototype.destroy = function() {
                this._detachCloseHandler(this.container);
            };
            BaseSelection.prototype.update = function(data) {
                throw new Error("The `update` method must be defined in child classes.");
            };
            BaseSelection.prototype.isEnabled = function() {
                return !this.isDisabled();
            };
            BaseSelection.prototype.isDisabled = function() {
                return this.options.get("disabled");
            };
            return BaseSelection;
        });
        S2.define("select2/selection/single", [ "jquery", "./base", "../utils", "../keys" ], function($, BaseSelection, Utils, KEYS) {
            function SingleSelection() {
                SingleSelection.__super__.constructor.apply(this, arguments);
            }
            Utils.Extend(SingleSelection, BaseSelection);
            SingleSelection.prototype.render = function() {
                var $selection = SingleSelection.__super__.render.call(this);
                $selection[0].classList.add("select2-selection--single");
                $selection.html('<span class="select2-selection__rendered"></span>' + '<span class="select2-selection__arrow" role="presentation">' + '<b role="presentation"></b>' + "</span>");
                return $selection;
            };
            SingleSelection.prototype.bind = function(container, $container) {
                var self = this;
                SingleSelection.__super__.bind.apply(this, arguments);
                var id = container.id + "-container";
                this.$selection.find(".select2-selection__rendered").attr("id", id).attr("role", "textbox").attr("aria-readonly", "true");
                this.$selection.attr("aria-labelledby", id);
                this.$selection.attr("aria-controls", id);
                this.$selection.on("mousedown", function(evt) {
                    if (evt.which !== 1) {
                        return;
                    }
                    self.trigger("toggle", {
                        originalEvent: evt
                    });
                });
                this.$selection.on("focus", function(evt) {});
                this.$selection.on("blur", function(evt) {});
                container.on("focus", function(evt) {
                    if (!container.isOpen()) {
                        self.$selection.trigger("focus");
                    }
                });
            };
            SingleSelection.prototype.clear = function() {
                var $rendered = this.$selection.find(".select2-selection__rendered");
                $rendered.empty();
                $rendered.removeAttr("title");
            };
            SingleSelection.prototype.display = function(data, container) {
                var template = this.options.get("templateSelection");
                var escapeMarkup = this.options.get("escapeMarkup");
                return escapeMarkup(template(data, container));
            };
            SingleSelection.prototype.selectionContainer = function() {
                return $("<span></span>");
            };
            SingleSelection.prototype.update = function(data) {
                if (data.length === 0) {
                    this.clear();
                    return;
                }
                var selection = data[0];
                var $rendered = this.$selection.find(".select2-selection__rendered");
                var formatted = this.display(selection, $rendered);
                $rendered.empty().append(formatted);
                var title = selection.title || selection.text;
                if (title) {
                    $rendered.attr("title", title);
                } else {
                    $rendered.removeAttr("title");
                }
            };
            return SingleSelection;
        });
        S2.define("select2/selection/multiple", [ "jquery", "./base", "../utils" ], function($, BaseSelection, Utils) {
            function MultipleSelection($element, options) {
                MultipleSelection.__super__.constructor.apply(this, arguments);
            }
            Utils.Extend(MultipleSelection, BaseSelection);
            MultipleSelection.prototype.render = function() {
                var $selection = MultipleSelection.__super__.render.call(this);
                $selection[0].classList.add("select2-selection--multiple");
                $selection.html('<ul class="select2-selection__rendered"></ul>');
                return $selection;
            };
            MultipleSelection.prototype.bind = function(container, $container) {
                var self = this;
                MultipleSelection.__super__.bind.apply(this, arguments);
                var id = container.id + "-container";
                this.$selection.find(".select2-selection__rendered").attr("id", id);
                this.$selection.on("click", function(evt) {
                    self.trigger("toggle", {
                        originalEvent: evt
                    });
                });
                this.$selection.on("click", ".select2-selection__choice__remove", function(evt) {
                    if (self.isDisabled()) {
                        return;
                    }
                    var $remove = $(this);
                    var $selection = $remove.parent();
                    var data = Utils.GetData($selection[0], "data");
                    self.trigger("unselect", {
                        originalEvent: evt,
                        data: data
                    });
                });
                this.$selection.on("keydown", ".select2-selection__choice__remove", function(evt) {
                    if (self.isDisabled()) {
                        return;
                    }
                    evt.stopPropagation();
                });
            };
            MultipleSelection.prototype.clear = function() {
                var $rendered = this.$selection.find(".select2-selection__rendered");
                $rendered.empty();
                $rendered.removeAttr("title");
            };
            MultipleSelection.prototype.display = function(data, container) {
                var template = this.options.get("templateSelection");
                var escapeMarkup = this.options.get("escapeMarkup");
                return escapeMarkup(template(data, container));
            };
            MultipleSelection.prototype.selectionContainer = function() {
                var $container = $('<li class="select2-selection__choice">' + '<button type="button" class="select2-selection__choice__remove" ' + 'tabindex="-1">' + '<span aria-hidden="true">&times;</span>' + "</button>" + '<span class="select2-selection__choice__display"></span>' + "</li>");
                return $container;
            };
            MultipleSelection.prototype.update = function(data) {
                this.clear();
                if (data.length === 0) {
                    return;
                }
                var $selections = [];
                var selectionIdPrefix = this.$selection.find(".select2-selection__rendered").attr("id") + "-choice-";
                for (var d = 0; d < data.length; d++) {
                    var selection = data[d];
                    var $selection = this.selectionContainer();
                    var formatted = this.display(selection, $selection);
                    var selectionId = selectionIdPrefix + Utils.generateChars(4) + "-";
                    if (selection.id) {
                        selectionId += selection.id;
                    } else {
                        selectionId += Utils.generateChars(4);
                    }
                    $selection.find(".select2-selection__choice__display").append(formatted).attr("id", selectionId);
                    var title = selection.title || selection.text;
                    if (title) {
                        $selection.attr("title", title);
                    }
                    var removeItem = this.options.get("translations").get("removeItem");
                    var $remove = $selection.find(".select2-selection__choice__remove");
                    $remove.attr("title", removeItem());
                    $remove.attr("aria-label", removeItem());
                    $remove.attr("aria-describedby", selectionId);
                    Utils.StoreData($selection[0], "data", selection);
                    $selections.push($selection);
                }
                var $rendered = this.$selection.find(".select2-selection__rendered");
                $rendered.append($selections);
            };
            return MultipleSelection;
        });
        S2.define("select2/selection/placeholder", [], function() {
            function Placeholder(decorated, $element, options) {
                this.placeholder = this.normalizePlaceholder(options.get("placeholder"));
                decorated.call(this, $element, options);
            }
            Placeholder.prototype.normalizePlaceholder = function(_, placeholder) {
                if (typeof placeholder === "string") {
                    placeholder = {
                        id: "",
                        text: placeholder
                    };
                }
                return placeholder;
            };
            Placeholder.prototype.createPlaceholder = function(decorated, placeholder) {
                var $placeholder = this.selectionContainer();
                $placeholder.html(this.display(placeholder));
                $placeholder[0].classList.add("select2-selection__placeholder");
                $placeholder[0].classList.remove("select2-selection__choice");
                var placeholderTitle = placeholder.title || placeholder.text || $placeholder.text();
                this.$selection.find(".select2-selection__rendered").attr("title", placeholderTitle);
                return $placeholder;
            };
            Placeholder.prototype.update = function(decorated, data) {
                var singlePlaceholder = data.length == 1 && data[0].id != this.placeholder.id;
                var multipleSelections = data.length > 1;
                if (multipleSelections || singlePlaceholder) {
                    return decorated.call(this, data);
                }
                this.clear();
                var $placeholder = this.createPlaceholder(this.placeholder);
                this.$selection.find(".select2-selection__rendered").append($placeholder);
            };
            return Placeholder;
        });
        S2.define("select2/selection/allowClear", [ "jquery", "../keys", "../utils" ], function($, KEYS, Utils) {
            function AllowClear() {}
            AllowClear.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container);
                if (this.placeholder == null) {
                    if (this.options.get("debug") && window.console && console.error) {
                        console.error("Select2: The `allowClear` option should be used in combination " + "with the `placeholder` option.");
                    }
                }
                this.$selection.on("mousedown", ".select2-selection__clear", function(evt) {
                    self._handleClear(evt);
                });
                container.on("keypress", function(evt) {
                    self._handleKeyboardClear(evt, container);
                });
            };
            AllowClear.prototype._handleClear = function(_, evt) {
                if (this.isDisabled()) {
                    return;
                }
                var $clear = this.$selection.find(".select2-selection__clear");
                if ($clear.length === 0) {
                    return;
                }
                evt.stopPropagation();
                var data = Utils.GetData($clear[0], "data");
                var previousVal = this.$element.val();
                this.$element.val(this.placeholder.id);
                var unselectData = {
                    data: data
                };
                this.trigger("clear", unselectData);
                if (unselectData.prevented) {
                    this.$element.val(previousVal);
                    return;
                }
                for (var d = 0; d < data.length; d++) {
                    unselectData = {
                        data: data[d]
                    };
                    this.trigger("unselect", unselectData);
                    if (unselectData.prevented) {
                        this.$element.val(previousVal);
                        return;
                    }
                }
                this.$element.trigger("input").trigger("change");
                this.trigger("toggle", {});
            };
            AllowClear.prototype._handleKeyboardClear = function(_, evt, container) {
                if (container.isOpen()) {
                    return;
                }
                if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
                    this._handleClear(evt);
                }
            };
            AllowClear.prototype.update = function(decorated, data) {
                decorated.call(this, data);
                this.$selection.find(".select2-selection__clear").remove();
                this.$selection[0].classList.remove("select2-selection--clearable");
                if (this.$selection.find(".select2-selection__placeholder").length > 0 || data.length === 0) {
                    return;
                }
                var selectionId = this.$selection.find(".select2-selection__rendered").attr("id");
                var removeAll = this.options.get("translations").get("removeAllItems");
                var $remove = $('<button type="button" class="select2-selection__clear" tabindex="-1">' + '<span aria-hidden="true">&times;</span>' + "</button>");
                $remove.attr("title", removeAll());
                $remove.attr("aria-label", removeAll());
                $remove.attr("aria-describedby", selectionId);
                Utils.StoreData($remove[0], "data", data);
                this.$selection.prepend($remove);
                this.$selection[0].classList.add("select2-selection--clearable");
            };
            return AllowClear;
        });
        S2.define("select2/selection/search", [ "jquery", "../utils", "../keys" ], function($, Utils, KEYS) {
            function Search(decorated, $element, options) {
                decorated.call(this, $element, options);
            }
            Search.prototype.render = function(decorated) {
                var searchLabel = this.options.get("translations").get("search");
                var $search = $('<span class="select2-search select2-search--inline">' + '<textarea class="select2-search__field"' + ' type="search" tabindex="-1"' + ' autocorrect="off" autocapitalize="none"' + ' spellcheck="false" role="searchbox" aria-autocomplete="list" >' + "</textarea>" + "</span>");
                this.$searchContainer = $search;
                this.$search = $search.find("textarea");
                this.$search.prop("autocomplete", this.options.get("autocomplete"));
                this.$search.attr("aria-label", searchLabel());
                var $rendered = decorated.call(this);
                this._transferTabIndex();
                $rendered.append(this.$searchContainer);
                return $rendered;
            };
            Search.prototype.bind = function(decorated, container, $container) {
                var self = this;
                var resultsId = container.id + "-results";
                var selectionId = container.id + "-container";
                decorated.call(this, container, $container);
                self.$search.attr("aria-describedby", selectionId);
                container.on("open", function() {
                    self.$search.attr("aria-controls", resultsId);
                    self.$search.trigger("focus");
                });
                container.on("close", function() {
                    self.$search.val("");
                    self.resizeSearch();
                    self.$search.removeAttr("aria-controls");
                    self.$search.removeAttr("aria-activedescendant");
                    self.$search.trigger("focus");
                });
                container.on("enable", function() {
                    self.$search.prop("disabled", false);
                    self._transferTabIndex();
                });
                container.on("disable", function() {
                    self.$search.prop("disabled", true);
                });
                container.on("focus", function(evt) {
                    self.$search.trigger("focus");
                });
                container.on("results:focus", function(params) {
                    if (params.data._resultId) {
                        self.$search.attr("aria-activedescendant", params.data._resultId);
                    } else {
                        self.$search.removeAttr("aria-activedescendant");
                    }
                });
                this.$selection.on("focusin", ".select2-search--inline", function(evt) {
                    self.trigger("focus", evt);
                });
                this.$selection.on("focusout", ".select2-search--inline", function(evt) {
                    self._handleBlur(evt);
                });
                this.$selection.on("keydown", ".select2-search--inline", function(evt) {
                    evt.stopPropagation();
                    self.trigger("keypress", evt);
                    self._keyUpPrevented = evt.isDefaultPrevented();
                    var key = evt.which;
                    if (key === KEYS.BACKSPACE && self.$search.val() === "") {
                        var $previousChoice = self.$selection.find(".select2-selection__choice").last();
                        if ($previousChoice.length > 0) {
                            var item = Utils.GetData($previousChoice[0], "data");
                            self.searchRemoveChoice(item);
                            evt.preventDefault();
                        }
                    }
                });
                this.$selection.on("click", ".select2-search--inline", function(evt) {
                    if (self.$search.val()) {
                        evt.stopPropagation();
                    }
                });
                var msie = document.documentMode;
                var disableInputEvents = msie && msie <= 11;
                this.$selection.on("input.searchcheck", ".select2-search--inline", function(evt) {
                    if (disableInputEvents) {
                        self.$selection.off("input.search input.searchcheck");
                        return;
                    }
                    self.$selection.off("keyup.search");
                });
                this.$selection.on("keyup.search input.search", ".select2-search--inline", function(evt) {
                    if (disableInputEvents && evt.type === "input") {
                        self.$selection.off("input.search input.searchcheck");
                        return;
                    }
                    var key = evt.which;
                    if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
                        return;
                    }
                    if (key == KEYS.TAB) {
                        return;
                    }
                    self.handleSearch(evt);
                });
            };
            Search.prototype._transferTabIndex = function(decorated) {
                this.$search.attr("tabindex", this.$selection.attr("tabindex"));
                this.$selection.attr("tabindex", "-1");
            };
            Search.prototype.createPlaceholder = function(decorated, placeholder) {
                this.$search.attr("placeholder", placeholder.text);
            };
            Search.prototype.update = function(decorated, data) {
                var searchHadFocus = this.$search[0] == document.activeElement;
                this.$search.attr("placeholder", "");
                decorated.call(this, data);
                this.resizeSearch();
                if (searchHadFocus) {
                    this.$search.trigger("focus");
                }
            };
            Search.prototype.handleSearch = function() {
                this.resizeSearch();
                if (!this._keyUpPrevented) {
                    var input = this.$search.val();
                    this.trigger("query", {
                        term: input
                    });
                }
                this._keyUpPrevented = false;
            };
            Search.prototype.searchRemoveChoice = function(decorated, item) {
                this.trigger("unselect", {
                    data: item
                });
                this.$search.val(item.text);
                this.handleSearch();
            };
            Search.prototype.resizeSearch = function() {
                this.$search.css("width", "25px");
                var width = "100%";
                if (this.$search.attr("placeholder") === "") {
                    var minimumWidth = this.$search.val().length + 1;
                    width = minimumWidth * .75 + "em";
                }
                this.$search.css("width", width);
            };
            return Search;
        });
        S2.define("select2/selection/selectionCss", [ "../utils" ], function(Utils) {
            function SelectionCSS() {}
            SelectionCSS.prototype.render = function(decorated) {
                var $selection = decorated.call(this);
                var selectionCssClass = this.options.get("selectionCssClass") || "";
                if (selectionCssClass.indexOf(":all:") !== -1) {
                    selectionCssClass = selectionCssClass.replace(":all:", "");
                    Utils.copyNonInternalCssClasses($selection[0], this.$element[0]);
                }
                $selection.addClass(selectionCssClass);
                return $selection;
            };
            return SelectionCSS;
        });
        S2.define("select2/selection/eventRelay", [ "jquery" ], function($) {
            function EventRelay() {}
            EventRelay.prototype.bind = function(decorated, container, $container) {
                var self = this;
                var relayEvents = [ "open", "opening", "close", "closing", "select", "selecting", "unselect", "unselecting", "clear", "clearing" ];
                var preventableEvents = [ "opening", "closing", "selecting", "unselecting", "clearing" ];
                decorated.call(this, container, $container);
                container.on("*", function(name, params) {
                    if (relayEvents.indexOf(name) === -1) {
                        return;
                    }
                    params = params || {};
                    var evt = $.Event("select2:" + name, {
                        params: params
                    });
                    self.$element.trigger(evt);
                    if (preventableEvents.indexOf(name) === -1) {
                        return;
                    }
                    params.prevented = evt.isDefaultPrevented();
                });
            };
            return EventRelay;
        });
        S2.define("select2/translation", [ "jquery", "require" ], function($, require) {
            function Translation(dict) {
                this.dict = dict || {};
            }
            Translation.prototype.all = function() {
                return this.dict;
            };
            Translation.prototype.get = function(key) {
                return this.dict[key];
            };
            Translation.prototype.extend = function(translation) {
                this.dict = $.extend({}, translation.all(), this.dict);
            };
            Translation._cache = {};
            Translation.loadPath = function(path) {
                if (!(path in Translation._cache)) {
                    var translations = require(path);
                    Translation._cache[path] = translations;
                }
                return new Translation(Translation._cache[path]);
            };
            return Translation;
        });
        S2.define("select2/diacritics", [], function() {
            var diacritics = {
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "AA",
                "": "AE",
                "": "AE",
                "": "AE",
                "": "AO",
                "": "AU",
                "": "AV",
                "": "AV",
                "": "AY",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "DZ",
                "": "DZ",
                "": "Dz",
                "": "Dz",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "LJ",
                "": "Lj",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "NJ",
                "": "Nj",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "OE",
                "": "OI",
                "": "OO",
                "": "OU",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "TZ",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "VY",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "aa",
                "": "ae",
                "": "ae",
                "": "ae",
                "": "ao",
                "": "au",
                "": "av",
                "": "av",
                "": "ay",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "dz",
                "": "dz",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "hv",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "lj",
                "": "m",
                "": "m",
                "": "m",
                "": "m",
                "": "m",
                "": "m",
                "": "m",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "nj",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "oe",
                "": "oi",
                "": "ou",
                "": "oo",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "tz",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "vy",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "'"
            };
            return diacritics;
        });
        S2.define("select2/data/base", [ "../utils" ], function(Utils) {
            function BaseAdapter($element, options) {
                BaseAdapter.__super__.constructor.call(this);
            }
            Utils.Extend(BaseAdapter, Utils.Observable);
            BaseAdapter.prototype.current = function(callback) {
                throw new Error("The `current` method must be defined in child classes.");
            };
            BaseAdapter.prototype.query = function(params, callback) {
                throw new Error("The `query` method must be defined in child classes.");
            };
            BaseAdapter.prototype.bind = function(container, $container) {};
            BaseAdapter.prototype.destroy = function() {};
            BaseAdapter.prototype.generateResultId = function(container, data) {
                var id = container.id + "-result-";
                id += Utils.generateChars(4);
                if (data.id != null) {
                    id += "-" + data.id.toString();
                } else {
                    id += "-" + Utils.generateChars(4);
                }
                return id;
            };
            return BaseAdapter;
        });
        S2.define("select2/data/select", [ "./base", "../utils", "jquery" ], function(BaseAdapter, Utils, $) {
            function SelectAdapter($element, options) {
                this.$element = $element;
                this.options = options;
                SelectAdapter.__super__.constructor.call(this);
            }
            Utils.Extend(SelectAdapter, BaseAdapter);
            SelectAdapter.prototype.current = function(callback) {
                var self = this;
                var data = Array.prototype.map.call(this.$element[0].querySelectorAll(":checked"), function(selectedElement) {
                    return self.item($(selectedElement));
                });
                callback(data);
            };
            SelectAdapter.prototype.select = function(data) {
                var self = this;
                data.selected = true;
                if (data.element != null && data.element.tagName.toLowerCase() === "option") {
                    data.element.selected = true;
                    this.$element.trigger("input").trigger("change");
                    return;
                }
                if (this.$element.prop("multiple")) {
                    this.current(function(currentData) {
                        var val = [];
                        data = [ data ];
                        data.push.apply(data, currentData);
                        for (var d = 0; d < data.length; d++) {
                            var id = data[d].id;
                            if (val.indexOf(id) === -1) {
                                val.push(id);
                            }
                        }
                        self.$element.val(val);
                        self.$element.trigger("input").trigger("change");
                    });
                } else {
                    var val = data.id;
                    this.$element.val(val);
                    this.$element.trigger("input").trigger("change");
                }
            };
            SelectAdapter.prototype.unselect = function(data) {
                var self = this;
                if (!this.$element.prop("multiple")) {
                    return;
                }
                data.selected = false;
                if (data.element != null && data.element.tagName.toLowerCase() === "option") {
                    data.element.selected = false;
                    this.$element.trigger("input").trigger("change");
                    return;
                }
                this.current(function(currentData) {
                    var val = [];
                    for (var d = 0; d < currentData.length; d++) {
                        var id = currentData[d].id;
                        if (id !== data.id && val.indexOf(id) === -1) {
                            val.push(id);
                        }
                    }
                    self.$element.val(val);
                    self.$element.trigger("input").trigger("change");
                });
            };
            SelectAdapter.prototype.bind = function(container, $container) {
                var self = this;
                this.container = container;
                container.on("select", function(params) {
                    self.select(params.data);
                });
                container.on("unselect", function(params) {
                    self.unselect(params.data);
                });
            };
            SelectAdapter.prototype.destroy = function() {
                this.$element.find("*").each(function() {
                    Utils.RemoveData(this);
                });
            };
            SelectAdapter.prototype.query = function(params, callback) {
                var data = [];
                var self = this;
                var $options = this.$element.children();
                $options.each(function() {
                    if (this.tagName.toLowerCase() !== "option" && this.tagName.toLowerCase() !== "optgroup") {
                        return;
                    }
                    var $option = $(this);
                    var option = self.item($option);
                    var matches = self.matches(params, option);
                    if (matches !== null) {
                        data.push(matches);
                    }
                });
                callback({
                    results: data
                });
            };
            SelectAdapter.prototype.addOptions = function($options) {
                this.$element.append($options);
            };
            SelectAdapter.prototype.option = function(data) {
                var option;
                if (data.children) {
                    option = document.createElement("optgroup");
                    option.label = data.text;
                } else {
                    option = document.createElement("option");
                    if (option.textContent !== undefined) {
                        option.textContent = data.text;
                    } else {
                        option.innerText = data.text;
                    }
                }
                if (data.id !== undefined) {
                    option.value = data.id;
                }
                if (data.disabled) {
                    option.disabled = true;
                }
                if (data.selected) {
                    option.selected = true;
                }
                if (data.title) {
                    option.title = data.title;
                }
                var normalizedData = this._normalizeItem(data);
                normalizedData.element = option;
                Utils.StoreData(option, "data", normalizedData);
                return $(option);
            };
            SelectAdapter.prototype.item = function($option) {
                var data = {};
                data = Utils.GetData($option[0], "data");
                if (data != null) {
                    return data;
                }
                var option = $option[0];
                if (option.tagName.toLowerCase() === "option") {
                    data = {
                        id: $option.val(),
                        text: $option.text(),
                        disabled: $option.prop("disabled"),
                        selected: $option.prop("selected"),
                        title: $option.prop("title")
                    };
                } else if (option.tagName.toLowerCase() === "optgroup") {
                    data = {
                        text: $option.prop("label"),
                        children: [],
                        title: $option.prop("title")
                    };
                    var $children = $option.children("option");
                    var children = [];
                    for (var c = 0; c < $children.length; c++) {
                        var $child = $($children[c]);
                        var child = this.item($child);
                        children.push(child);
                    }
                    data.children = children;
                }
                data = this._normalizeItem(data);
                data.element = $option[0];
                Utils.StoreData($option[0], "data", data);
                return data;
            };
            SelectAdapter.prototype._normalizeItem = function(item) {
                if (item !== Object(item)) {
                    item = {
                        id: item,
                        text: item
                    };
                }
                item = $.extend({}, {
                    text: ""
                }, item);
                var defaults = {
                    selected: false,
                    disabled: false
                };
                if (item.id != null) {
                    item.id = item.id.toString();
                }
                if (item.text != null) {
                    item.text = item.text.toString();
                }
                if (item._resultId == null && item.id && this.container != null) {
                    item._resultId = this.generateResultId(this.container, item);
                }
                return $.extend({}, defaults, item);
            };
            SelectAdapter.prototype.matches = function(params, data) {
                var matcher = this.options.get("matcher");
                return matcher(params, data);
            };
            return SelectAdapter;
        });
        S2.define("select2/data/array", [ "./select", "../utils", "jquery" ], function(SelectAdapter, Utils, $) {
            function ArrayAdapter($element, options) {
                this._dataToConvert = options.get("data") || [];
                ArrayAdapter.__super__.constructor.call(this, $element, options);
            }
            Utils.Extend(ArrayAdapter, SelectAdapter);
            ArrayAdapter.prototype.bind = function(container, $container) {
                ArrayAdapter.__super__.bind.call(this, container, $container);
                this.addOptions(this.convertToOptions(this._dataToConvert));
            };
            ArrayAdapter.prototype.select = function(data) {
                var $option = this.$element.find("option").filter(function(i, elm) {
                    return elm.value == data.id.toString();
                });
                if ($option.length === 0) {
                    $option = this.option(data);
                    this.addOptions($option);
                }
                ArrayAdapter.__super__.select.call(this, data);
            };
            ArrayAdapter.prototype.convertToOptions = function(data) {
                var self = this;
                var $existing = this.$element.find("option");
                var existingIds = $existing.map(function() {
                    return self.item($(this)).id;
                }).get();
                var $options = [];
                function onlyItem(item) {
                    return function() {
                        return $(this).val() == item.id;
                    };
                }
                for (var d = 0; d < data.length; d++) {
                    var item = this._normalizeItem(data[d]);
                    if (existingIds.indexOf(item.id) >= 0) {
                        var $existingOption = $existing.filter(onlyItem(item));
                        var existingData = this.item($existingOption);
                        var newData = $.extend(true, {}, item, existingData);
                        var $newOption = this.option(newData);
                        $existingOption.replaceWith($newOption);
                        continue;
                    }
                    var $option = this.option(item);
                    if (item.children) {
                        var $children = this.convertToOptions(item.children);
                        $option.append($children);
                    }
                    $options.push($option);
                }
                return $options;
            };
            return ArrayAdapter;
        });
        S2.define("select2/data/ajax", [ "./array", "../utils", "jquery" ], function(ArrayAdapter, Utils, $) {
            function AjaxAdapter($element, options) {
                this.ajaxOptions = this._applyDefaults(options.get("ajax"));
                if (this.ajaxOptions.processResults != null) {
                    this.processResults = this.ajaxOptions.processResults;
                }
                AjaxAdapter.__super__.constructor.call(this, $element, options);
            }
            Utils.Extend(AjaxAdapter, ArrayAdapter);
            AjaxAdapter.prototype._applyDefaults = function(options) {
                var defaults = {
                    data: function(params) {
                        return $.extend({}, params, {
                            q: params.term
                        });
                    },
                    transport: function(params, success, failure) {
                        var $request = $.ajax(params);
                        $request.then(success);
                        $request.fail(failure);
                        return $request;
                    }
                };
                return $.extend({}, defaults, options, true);
            };
            AjaxAdapter.prototype.processResults = function(results) {
                return results;
            };
            AjaxAdapter.prototype.query = function(params, callback) {
                var matches = [];
                var self = this;
                if (this._request != null) {
                    if (typeof this._request.abort === "function") {
                        this._request.abort();
                    }
                    this._request = null;
                }
                var options = $.extend({
                    type: "GET"
                }, this.ajaxOptions);
                if (typeof options.url === "function") {
                    options.url = options.url.call(this.$element, params);
                }
                if (typeof options.data === "function") {
                    options.data = options.data.call(this.$element, params);
                }
                function request() {
                    var $request = options.transport(options, function(data) {
                        var results = self.processResults(data, params);
                        if (self.options.get("debug") && window.console && console.error) {
                            if (!results || !results.results || !Array.isArray(results.results)) {
                                console.error("Select2: The AJAX results did not return an array in the " + "`results` key of the response.");
                            }
                        }
                        callback(results);
                    }, function() {
                        if ("status" in $request && ($request.status === 0 || $request.status === "0")) {
                            return;
                        }
                        self.trigger("results:message", {
                            message: "errorLoading"
                        });
                    });
                    self._request = $request;
                }
                if (this.ajaxOptions.delay && params.term != null) {
                    if (this._queryTimeout) {
                        window.clearTimeout(this._queryTimeout);
                    }
                    this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
                } else {
                    request();
                }
            };
            return AjaxAdapter;
        });
        S2.define("select2/data/tags", [ "jquery" ], function($) {
            function Tags(decorated, $element, options) {
                var tags = options.get("tags");
                var createTag = options.get("createTag");
                if (createTag !== undefined) {
                    this.createTag = createTag;
                }
                var insertTag = options.get("insertTag");
                if (insertTag !== undefined) {
                    this.insertTag = insertTag;
                }
                decorated.call(this, $element, options);
                if (Array.isArray(tags)) {
                    for (var t = 0; t < tags.length; t++) {
                        var tag = tags[t];
                        var item = this._normalizeItem(tag);
                        var $option = this.option(item);
                        this.$element.append($option);
                    }
                }
            }
            Tags.prototype.query = function(decorated, params, callback) {
                var self = this;
                this._removeOldTags();
                if (params.term == null || params.page != null) {
                    decorated.call(this, params, callback);
                    return;
                }
                function wrapper(obj, child) {
                    var data = obj.results;
                    for (var i = 0; i < data.length; i++) {
                        var option = data[i];
                        var checkChildren = option.children != null && !wrapper({
                            results: option.children
                        }, true);
                        var optionText = (option.text || "").toUpperCase();
                        var paramsTerm = (params.term || "").toUpperCase();
                        var checkText = optionText === paramsTerm;
                        if (checkText || checkChildren) {
                            if (child) {
                                return false;
                            }
                            obj.data = data;
                            callback(obj);
                            return;
                        }
                    }
                    if (child) {
                        return true;
                    }
                    var tag = self.createTag(params);
                    if (tag != null) {
                        var $option = self.option(tag);
                        $option.attr("data-select2-tag", "true");
                        self.addOptions([ $option ]);
                        self.insertTag(data, tag);
                    }
                    obj.results = data;
                    callback(obj);
                }
                decorated.call(this, params, wrapper);
            };
            Tags.prototype.createTag = function(decorated, params) {
                if (params.term == null) {
                    return null;
                }
                var term = params.term.trim();
                if (term === "") {
                    return null;
                }
                return {
                    id: term,
                    text: term
                };
            };
            Tags.prototype.insertTag = function(_, data, tag) {
                data.unshift(tag);
            };
            Tags.prototype._removeOldTags = function(_) {
                var $options = this.$element.find("option[data-select2-tag]");
                $options.each(function() {
                    if (this.selected) {
                        return;
                    }
                    $(this).remove();
                });
            };
            return Tags;
        });
        S2.define("select2/data/tokenizer", [ "jquery" ], function($) {
            function Tokenizer(decorated, $element, options) {
                var tokenizer = options.get("tokenizer");
                if (tokenizer !== undefined) {
                    this.tokenizer = tokenizer;
                }
                decorated.call(this, $element, options);
            }
            Tokenizer.prototype.bind = function(decorated, container, $container) {
                decorated.call(this, container, $container);
                this.$search = container.dropdown.$search || container.selection.$search || $container.find(".select2-search__field");
            };
            Tokenizer.prototype.query = function(decorated, params, callback) {
                var self = this;
                function createAndSelect(data) {
                    var item = self._normalizeItem(data);
                    var $existingOptions = self.$element.find("option").filter(function() {
                        return $(this).val() === item.id;
                    });
                    if (!$existingOptions.length) {
                        var $option = self.option(item);
                        $option.attr("data-select2-tag", true);
                        self._removeOldTags();
                        self.addOptions([ $option ]);
                    }
                    select(item);
                }
                function select(data) {
                    self.trigger("select", {
                        data: data
                    });
                }
                params.term = params.term || "";
                var tokenData = this.tokenizer(params, this.options, createAndSelect);
                if (tokenData.term !== params.term) {
                    if (this.$search.length) {
                        this.$search.val(tokenData.term);
                        this.$search.trigger("focus");
                    }
                    params.term = tokenData.term;
                }
                decorated.call(this, params, callback);
            };
            Tokenizer.prototype.tokenizer = function(_, params, options, callback) {
                var separators = options.get("tokenSeparators") || [];
                var term = params.term;
                var i = 0;
                var createTag = this.createTag || function(params) {
                    return {
                        id: params.term,
                        text: params.term
                    };
                };
                while (i < term.length) {
                    var termChar = term[i];
                    if (separators.indexOf(termChar) === -1) {
                        i++;
                        continue;
                    }
                    var part = term.substr(0, i);
                    var partParams = $.extend({}, params, {
                        term: part
                    });
                    var data = createTag(partParams);
                    if (data == null) {
                        i++;
                        continue;
                    }
                    callback(data);
                    term = term.substr(i + 1) || "";
                    i = 0;
                }
                return {
                    term: term
                };
            };
            return Tokenizer;
        });
        S2.define("select2/data/minimumInputLength", [], function() {
            function MinimumInputLength(decorated, $e, options) {
                this.minimumInputLength = options.get("minimumInputLength");
                decorated.call(this, $e, options);
            }
            MinimumInputLength.prototype.query = function(decorated, params, callback) {
                params.term = params.term || "";
                if (params.term.length < this.minimumInputLength) {
                    this.trigger("results:message", {
                        message: "inputTooShort",
                        args: {
                            minimum: this.minimumInputLength,
                            input: params.term,
                            params: params
                        }
                    });
                    return;
                }
                decorated.call(this, params, callback);
            };
            return MinimumInputLength;
        });
        S2.define("select2/data/maximumInputLength", [], function() {
            function MaximumInputLength(decorated, $e, options) {
                this.maximumInputLength = options.get("maximumInputLength");
                decorated.call(this, $e, options);
            }
            MaximumInputLength.prototype.query = function(decorated, params, callback) {
                params.term = params.term || "";
                if (this.maximumInputLength > 0 && params.term.length > this.maximumInputLength) {
                    this.trigger("results:message", {
                        message: "inputTooLong",
                        args: {
                            maximum: this.maximumInputLength,
                            input: params.term,
                            params: params
                        }
                    });
                    return;
                }
                decorated.call(this, params, callback);
            };
            return MaximumInputLength;
        });
        S2.define("select2/data/maximumSelectionLength", [], function() {
            function MaximumSelectionLength(decorated, $e, options) {
                this.maximumSelectionLength = options.get("maximumSelectionLength");
                decorated.call(this, $e, options);
            }
            MaximumSelectionLength.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container);
                container.on("select", function() {
                    self._checkIfMaximumSelected();
                });
            };
            MaximumSelectionLength.prototype.query = function(decorated, params, callback) {
                var self = this;
                this._checkIfMaximumSelected(function() {
                    decorated.call(self, params, callback);
                });
            };
            MaximumSelectionLength.prototype._checkIfMaximumSelected = function(_, successCallback) {
                var self = this;
                this.current(function(currentData) {
                    var count = currentData != null ? currentData.length : 0;
                    if (self.maximumSelectionLength > 0 && count >= self.maximumSelectionLength) {
                        self.trigger("results:message", {
                            message: "maximumSelected",
                            args: {
                                maximum: self.maximumSelectionLength
                            }
                        });
                        return;
                    }
                    if (successCallback) {
                        successCallback();
                    }
                });
            };
            return MaximumSelectionLength;
        });
        S2.define("select2/dropdown", [ "jquery", "./utils" ], function($, Utils) {
            function Dropdown($element, options) {
                this.$element = $element;
                this.options = options;
                Dropdown.__super__.constructor.call(this);
            }
            Utils.Extend(Dropdown, Utils.Observable);
            Dropdown.prototype.render = function() {
                var $dropdown = $('<span class="select2-dropdown">' + '<span class="select2-results"></span>' + "</span>");
                $dropdown.attr("dir", this.options.get("dir"));
                this.$dropdown = $dropdown;
                return $dropdown;
            };
            Dropdown.prototype.bind = function() {};
            Dropdown.prototype.position = function($dropdown, $container) {};
            Dropdown.prototype.destroy = function() {
                this.$dropdown.remove();
            };
            return Dropdown;
        });
        S2.define("select2/dropdown/search", [ "jquery" ], function($) {
            function Search() {}
            Search.prototype.render = function(decorated) {
                var $rendered = decorated.call(this);
                var searchLabel = this.options.get("translations").get("search");
                var $search = $('<span class="select2-search select2-search--dropdown">' + '<input class="select2-search__field" type="search" tabindex="-1"' + ' autocorrect="off" autocapitalize="none"' + ' spellcheck="false" role="searchbox" aria-autocomplete="list" />' + "</span>");
                this.$searchContainer = $search;
                this.$search = $search.find("input");
                this.$search.prop("autocomplete", this.options.get("autocomplete"));
                this.$search.attr("aria-label", searchLabel());
                $rendered.prepend($search);
                return $rendered;
            };
            Search.prototype.bind = function(decorated, container, $container) {
                var self = this;
                var resultsId = container.id + "-results";
                decorated.call(this, container, $container);
                this.$search.on("keydown", function(evt) {
                    self.trigger("keypress", evt);
                    self._keyUpPrevented = evt.isDefaultPrevented();
                });
                this.$search.on("input", function(evt) {
                    $(this).off("keyup");
                });
                this.$search.on("keyup input", function(evt) {
                    self.handleSearch(evt);
                });
                container.on("open", function() {
                    self.$search.attr("tabindex", 0);
                    self.$search.attr("aria-controls", resultsId);
                    self.$search.trigger("focus");
                    window.setTimeout(function() {
                        self.$search.trigger("focus");
                    }, 0);
                });
                container.on("close", function() {
                    self.$search.attr("tabindex", -1);
                    self.$search.removeAttr("aria-controls");
                    self.$search.removeAttr("aria-activedescendant");
                    self.$search.val("");
                    self.$search.trigger("blur");
                });
                container.on("focus", function() {
                    if (!container.isOpen()) {
                        self.$search.trigger("focus");
                    }
                });
                container.on("results:all", function(params) {
                    if (params.query.term == null || params.query.term === "") {
                        var showSearch = self.showSearch(params);
                        if (showSearch) {
                            self.$searchContainer[0].classList.remove("select2-search--hide");
                        } else {
                            self.$searchContainer[0].classList.add("select2-search--hide");
                        }
                    }
                });
                container.on("results:focus", function(params) {
                    if (params.data._resultId) {
                        self.$search.attr("aria-activedescendant", params.data._resultId);
                    } else {
                        self.$search.removeAttr("aria-activedescendant");
                    }
                });
            };
            Search.prototype.handleSearch = function(evt) {
                if (!this._keyUpPrevented) {
                    var input = this.$search.val();
                    this.trigger("query", {
                        term: input
                    });
                }
                this._keyUpPrevented = false;
            };
            Search.prototype.showSearch = function(_, params) {
                return true;
            };
            return Search;
        });
        S2.define("select2/dropdown/hidePlaceholder", [], function() {
            function HidePlaceholder(decorated, $element, options, dataAdapter) {
                this.placeholder = this.normalizePlaceholder(options.get("placeholder"));
                decorated.call(this, $element, options, dataAdapter);
            }
            HidePlaceholder.prototype.append = function(decorated, data) {
                data.results = this.removePlaceholder(data.results);
                decorated.call(this, data);
            };
            HidePlaceholder.prototype.normalizePlaceholder = function(_, placeholder) {
                if (typeof placeholder === "string") {
                    placeholder = {
                        id: "",
                        text: placeholder
                    };
                }
                return placeholder;
            };
            HidePlaceholder.prototype.removePlaceholder = function(_, data) {
                var modifiedData = data.slice(0);
                for (var d = data.length - 1; d >= 0; d--) {
                    var item = data[d];
                    if (this.placeholder.id === item.id) {
                        modifiedData.splice(d, 1);
                    }
                }
                return modifiedData;
            };
            return HidePlaceholder;
        });
        S2.define("select2/dropdown/infiniteScroll", [ "jquery" ], function($) {
            function InfiniteScroll(decorated, $element, options, dataAdapter) {
                this.lastParams = {};
                decorated.call(this, $element, options, dataAdapter);
                this.$loadingMore = this.createLoadingMore();
                this.loading = false;
            }
            InfiniteScroll.prototype.append = function(decorated, data) {
                this.$loadingMore.remove();
                this.loading = false;
                decorated.call(this, data);
                if (this.showLoadingMore(data)) {
                    this.$results.append(this.$loadingMore);
                    this.loadMoreIfNeeded();
                }
            };
            InfiniteScroll.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container);
                container.on("query", function(params) {
                    self.lastParams = params;
                    self.loading = true;
                });
                container.on("query:append", function(params) {
                    self.lastParams = params;
                    self.loading = true;
                });
                this.$results.on("scroll", this.loadMoreIfNeeded.bind(this));
            };
            InfiniteScroll.prototype.loadMoreIfNeeded = function() {
                var isLoadMoreVisible = $.contains(document.documentElement, this.$loadingMore[0]);
                if (this.loading || !isLoadMoreVisible) {
                    return;
                }
                var currentOffset = this.$results.offset().top + this.$results.outerHeight(false);
                var loadingMoreOffset = this.$loadingMore.offset().top + this.$loadingMore.outerHeight(false);
                if (currentOffset + 50 >= loadingMoreOffset) {
                    this.loadMore();
                }
            };
            InfiniteScroll.prototype.loadMore = function() {
                this.loading = true;
                var params = $.extend({}, {
                    page: 1
                }, this.lastParams);
                params.page++;
                this.trigger("query:append", params);
            };
            InfiniteScroll.prototype.showLoadingMore = function(_, data) {
                return data.pagination && data.pagination.more;
            };
            InfiniteScroll.prototype.createLoadingMore = function() {
                var $option = $("<li " + 'class="select2-results__option select2-results__option--load-more"' + 'role="option" aria-disabled="true"></li>');
                var message = this.options.get("translations").get("loadingMore");
                $option.html(message(this.lastParams));
                return $option;
            };
            return InfiniteScroll;
        });
        S2.define("select2/dropdown/attachBody", [ "jquery", "../utils" ], function($, Utils) {
            function AttachBody(decorated, $element, options) {
                this.$dropdownParent = $(options.get("dropdownParent") || document.body);
                decorated.call(this, $element, options);
            }
            AttachBody.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container);
                container.on("open", function() {
                    self._showDropdown();
                    self._attachPositioningHandler(container);
                    self._bindContainerResultHandlers(container);
                });
                container.on("close", function() {
                    self._hideDropdown();
                    self._detachPositioningHandler(container);
                });
                this.$dropdownContainer.on("mousedown", function(evt) {
                    evt.stopPropagation();
                });
            };
            AttachBody.prototype.destroy = function(decorated) {
                decorated.call(this);
                this.$dropdownContainer.remove();
            };
            AttachBody.prototype.position = function(decorated, $dropdown, $container) {
                $dropdown.attr("class", $container.attr("class"));
                $dropdown[0].classList.remove("select2");
                $dropdown[0].classList.add("select2-container--open");
                $dropdown.css({
                    position: "absolute",
                    top: -999999
                });
                this.$container = $container;
            };
            AttachBody.prototype.render = function(decorated) {
                var $container = $("<span></span>");
                var $dropdown = decorated.call(this);
                $container.append($dropdown);
                this.$dropdownContainer = $container;
                return $container;
            };
            AttachBody.prototype._hideDropdown = function(decorated) {
                this.$dropdownContainer.detach();
            };
            AttachBody.prototype._bindContainerResultHandlers = function(decorated, container) {
                if (this._containerResultsHandlersBound) {
                    return;
                }
                var self = this;
                container.on("results:all", function() {
                    self._positionDropdown();
                    self._resizeDropdown();
                });
                container.on("results:append", function() {
                    self._positionDropdown();
                    self._resizeDropdown();
                });
                container.on("results:message", function() {
                    self._positionDropdown();
                    self._resizeDropdown();
                });
                container.on("select", function() {
                    self._positionDropdown();
                    self._resizeDropdown();
                });
                container.on("unselect", function() {
                    self._positionDropdown();
                    self._resizeDropdown();
                });
                this._containerResultsHandlersBound = true;
            };
            AttachBody.prototype._attachPositioningHandler = function(decorated, container) {
                var self = this;
                var scrollEvent = "scroll.select2." + container.id;
                var resizeEvent = "resize.select2." + container.id;
                var orientationEvent = "orientationchange.select2." + container.id;
                var $watchers = this.$container.parents().filter(Utils.hasScroll);
                $watchers.each(function() {
                    Utils.StoreData(this, "select2-scroll-position", {
                        x: $(this).scrollLeft(),
                        y: $(this).scrollTop()
                    });
                });
                $watchers.on(scrollEvent, function(ev) {
                    var position = Utils.GetData(this, "select2-scroll-position");
                    $(this).scrollTop(position.y);
                });
                $(window).on(scrollEvent + " " + resizeEvent + " " + orientationEvent, function(e) {
                    self._positionDropdown();
                    self._resizeDropdown();
                });
            };
            AttachBody.prototype._detachPositioningHandler = function(decorated, container) {
                var scrollEvent = "scroll.select2." + container.id;
                var resizeEvent = "resize.select2." + container.id;
                var orientationEvent = "orientationchange.select2." + container.id;
                var $watchers = this.$container.parents().filter(Utils.hasScroll);
                $watchers.off(scrollEvent);
                $(window).off(scrollEvent + " " + resizeEvent + " " + orientationEvent);
            };
            AttachBody.prototype._positionDropdown = function() {
                var $window = $(window);
                var isCurrentlyAbove = this.$dropdown[0].classList.contains("select2-dropdown--above");
                var isCurrentlyBelow = this.$dropdown[0].classList.contains("select2-dropdown--below");
                var newDirection = null;
                var offset = this.$container.offset();
                offset.bottom = offset.top + this.$container.outerHeight(false);
                var container = {
                    height: this.$container.outerHeight(false)
                };
                container.top = offset.top;
                container.bottom = offset.top + container.height;
                var dropdown = {
                    height: this.$dropdown.outerHeight(false)
                };
                var viewport = {
                    top: $window.scrollTop(),
                    bottom: $window.scrollTop() + $window.height()
                };
                var enoughRoomAbove = viewport.top < offset.top - dropdown.height;
                var enoughRoomBelow = viewport.bottom > offset.bottom + dropdown.height;
                var css = {
                    left: offset.left,
                    top: container.bottom
                };
                var $offsetParent = this.$dropdownParent;
                if ($offsetParent.css("position") === "static") {
                    $offsetParent = $offsetParent.offsetParent();
                }
                var parentOffset = {
                    top: 0,
                    left: 0
                };
                if ($.contains(document.body, $offsetParent[0]) || $offsetParent[0].isConnected) {
                    parentOffset = $offsetParent.offset();
                }
                css.top -= parentOffset.top;
                css.left -= parentOffset.left;
                if (!isCurrentlyAbove && !isCurrentlyBelow) {
                    newDirection = "below";
                }
                if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
                    newDirection = "above";
                } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
                    newDirection = "below";
                }
                if (newDirection == "above" || isCurrentlyAbove && newDirection !== "below") {
                    css.top = container.top - parentOffset.top - dropdown.height;
                }
                if (newDirection != null) {
                    this.$dropdown[0].classList.remove("select2-dropdown--below");
                    this.$dropdown[0].classList.remove("select2-dropdown--above");
                    this.$dropdown[0].classList.add("select2-dropdown--" + newDirection);
                    this.$container[0].classList.remove("select2-container--below");
                    this.$container[0].classList.remove("select2-container--above");
                    this.$container[0].classList.add("select2-container--" + newDirection);
                }
                this.$dropdownContainer.css(css);
            };
            AttachBody.prototype._resizeDropdown = function() {
                var css = {
                    width: this.$container.outerWidth(false) + "px"
                };
                if (this.options.get("dropdownAutoWidth")) {
                    css.minWidth = css.width;
                    css.position = "relative";
                    css.width = "auto";
                }
                this.$dropdown.css(css);
            };
            AttachBody.prototype._showDropdown = function(decorated) {
                this.$dropdownContainer.appendTo(this.$dropdownParent);
                this._positionDropdown();
                this._resizeDropdown();
            };
            return AttachBody;
        });
        S2.define("select2/dropdown/minimumResultsForSearch", [], function() {
            function countResults(data) {
                var count = 0;
                for (var d = 0; d < data.length; d++) {
                    var item = data[d];
                    if (item.children) {
                        count += countResults(item.children);
                    } else {
                        count++;
                    }
                }
                return count;
            }
            function MinimumResultsForSearch(decorated, $element, options, dataAdapter) {
                this.minimumResultsForSearch = options.get("minimumResultsForSearch");
                if (this.minimumResultsForSearch < 0) {
                    this.minimumResultsForSearch = Infinity;
                }
                decorated.call(this, $element, options, dataAdapter);
            }
            MinimumResultsForSearch.prototype.showSearch = function(decorated, params) {
                if (countResults(params.data.results) < this.minimumResultsForSearch) {
                    return false;
                }
                return decorated.call(this, params);
            };
            return MinimumResultsForSearch;
        });
        S2.define("select2/dropdown/selectOnClose", [ "../utils" ], function(Utils) {
            function SelectOnClose() {}
            SelectOnClose.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container);
                container.on("close", function(params) {
                    self._handleSelectOnClose(params);
                });
            };
            SelectOnClose.prototype._handleSelectOnClose = function(_, params) {
                if (params && params.originalSelect2Event != null) {
                    var event = params.originalSelect2Event;
                    if (event._type === "select" || event._type === "unselect") {
                        return;
                    }
                }
                var $highlightedResults = this.getHighlightedResults();
                if ($highlightedResults.length < 1) {
                    return;
                }
                var data = Utils.GetData($highlightedResults[0], "data");
                if (data.element != null && data.element.selected || data.element == null && data.selected) {
                    return;
                }
                this.trigger("select", {
                    data: data
                });
            };
            return SelectOnClose;
        });
        S2.define("select2/dropdown/closeOnSelect", [], function() {
            function CloseOnSelect() {}
            CloseOnSelect.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container);
                container.on("select", function(evt) {
                    self._selectTriggered(evt);
                });
                container.on("unselect", function(evt) {
                    self._selectTriggered(evt);
                });
            };
            CloseOnSelect.prototype._selectTriggered = function(_, evt) {
                var originalEvent = evt.originalEvent;
                if (originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey)) {
                    return;
                }
                this.trigger("close", {
                    originalEvent: originalEvent,
                    originalSelect2Event: evt
                });
            };
            return CloseOnSelect;
        });
        S2.define("select2/dropdown/dropdownCss", [ "../utils" ], function(Utils) {
            function DropdownCSS() {}
            DropdownCSS.prototype.render = function(decorated) {
                var $dropdown = decorated.call(this);
                var dropdownCssClass = this.options.get("dropdownCssClass") || "";
                if (dropdownCssClass.indexOf(":all:") !== -1) {
                    dropdownCssClass = dropdownCssClass.replace(":all:", "");
                    Utils.copyNonInternalCssClasses($dropdown[0], this.$element[0]);
                }
                $dropdown.addClass(dropdownCssClass);
                return $dropdown;
            };
            return DropdownCSS;
        });
        S2.define("select2/dropdown/tagsSearchHighlight", [ "../utils" ], function(Utils) {
            function TagsSearchHighlight() {}
            TagsSearchHighlight.prototype.highlightFirstItem = function(decorated) {
                var $options = this.$results.find(".select2-results__option--selectable" + ":not(.select2-results__option--selected)");
                if ($options.length > 0) {
                    var $firstOption = $options.first();
                    var data = Utils.GetData($firstOption[0], "data");
                    var firstElement = data.element;
                    if (firstElement && firstElement.getAttribute) {
                        if (firstElement.getAttribute("data-select2-tag") === "true") {
                            $firstOption.trigger("mouseenter");
                            return;
                        }
                    }
                }
                decorated.call(this);
            };
            return TagsSearchHighlight;
        });
        S2.define("select2/i18n/en", [], function() {
            return {
                errorLoading: function() {
                    return "The results could not be loaded.";
                },
                inputTooLong: function(args) {
                    var overChars = args.input.length - args.maximum;
                    var message = "Please delete " + overChars + " character";
                    if (overChars != 1) {
                        message += "s";
                    }
                    return message;
                },
                inputTooShort: function(args) {
                    var remainingChars = args.minimum - args.input.length;
                    var message = "Please enter " + remainingChars + " or more characters";
                    return message;
                },
                loadingMore: function() {
                    return "Loading more results";
                },
                maximumSelected: function(args) {
                    var message = "You can only select " + args.maximum + " item";
                    if (args.maximum != 1) {
                        message += "s";
                    }
                    return message;
                },
                noResults: function() {
                    return "No results found";
                },
                searching: function() {
                    return "Searching";
                },
                removeAllItems: function() {
                    return "Remove all items";
                },
                removeItem: function() {
                    return "Remove item";
                },
                search: function() {
                    return "Search";
                }
            };
        });
        S2.define("select2/defaults", [ "jquery", "./results", "./selection/single", "./selection/multiple", "./selection/placeholder", "./selection/allowClear", "./selection/search", "./selection/selectionCss", "./selection/eventRelay", "./utils", "./translation", "./diacritics", "./data/select", "./data/array", "./data/ajax", "./data/tags", "./data/tokenizer", "./data/minimumInputLength", "./data/maximumInputLength", "./data/maximumSelectionLength", "./dropdown", "./dropdown/search", "./dropdown/hidePlaceholder", "./dropdown/infiniteScroll", "./dropdown/attachBody", "./dropdown/minimumResultsForSearch", "./dropdown/selectOnClose", "./dropdown/closeOnSelect", "./dropdown/dropdownCss", "./dropdown/tagsSearchHighlight", "./i18n/en" ], function($, ResultsList, SingleSelection, MultipleSelection, Placeholder, AllowClear, SelectionSearch, SelectionCSS, EventRelay, Utils, Translation, DIACRITICS, SelectData, ArrayData, AjaxData, Tags, Tokenizer, MinimumInputLength, MaximumInputLength, MaximumSelectionLength, Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll, AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect, DropdownCSS, TagsSearchHighlight, EnglishTranslation) {
            function Defaults() {
                this.reset();
            }
            Defaults.prototype.apply = function(options) {
                options = $.extend(true, {}, this.defaults, options);
                if (options.dataAdapter == null) {
                    if (options.ajax != null) {
                        options.dataAdapter = AjaxData;
                    } else if (options.data != null) {
                        options.dataAdapter = ArrayData;
                    } else {
                        options.dataAdapter = SelectData;
                    }
                    if (options.minimumInputLength > 0) {
                        options.dataAdapter = Utils.Decorate(options.dataAdapter, MinimumInputLength);
                    }
                    if (options.maximumInputLength > 0) {
                        options.dataAdapter = Utils.Decorate(options.dataAdapter, MaximumInputLength);
                    }
                    if (options.maximumSelectionLength > 0) {
                        options.dataAdapter = Utils.Decorate(options.dataAdapter, MaximumSelectionLength);
                    }
                    if (options.tags) {
                        options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
                    }
                    if (options.tokenSeparators != null || options.tokenizer != null) {
                        options.dataAdapter = Utils.Decorate(options.dataAdapter, Tokenizer);
                    }
                }
                if (options.resultsAdapter == null) {
                    options.resultsAdapter = ResultsList;
                    if (options.ajax != null) {
                        options.resultsAdapter = Utils.Decorate(options.resultsAdapter, InfiniteScroll);
                    }
                    if (options.placeholder != null) {
                        options.resultsAdapter = Utils.Decorate(options.resultsAdapter, HidePlaceholder);
                    }
                    if (options.selectOnClose) {
                        options.resultsAdapter = Utils.Decorate(options.resultsAdapter, SelectOnClose);
                    }
                    if (options.tags) {
                        options.resultsAdapter = Utils.Decorate(options.resultsAdapter, TagsSearchHighlight);
                    }
                }
                if (options.dropdownAdapter == null) {
                    if (options.multiple) {
                        options.dropdownAdapter = Dropdown;
                    } else {
                        var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);
                        options.dropdownAdapter = SearchableDropdown;
                    }
                    if (options.minimumResultsForSearch !== 0) {
                        options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, MinimumResultsForSearch);
                    }
                    if (options.closeOnSelect) {
                        options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, CloseOnSelect);
                    }
                    if (options.dropdownCssClass != null) {
                        options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, DropdownCSS);
                    }
                    options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, AttachBody);
                }
                if (options.selectionAdapter == null) {
                    if (options.multiple) {
                        options.selectionAdapter = MultipleSelection;
                    } else {
                        options.selectionAdapter = SingleSelection;
                    }
                    if (options.placeholder != null) {
                        options.selectionAdapter = Utils.Decorate(options.selectionAdapter, Placeholder);
                    }
                    if (options.allowClear) {
                        options.selectionAdapter = Utils.Decorate(options.selectionAdapter, AllowClear);
                    }
                    if (options.multiple) {
                        options.selectionAdapter = Utils.Decorate(options.selectionAdapter, SelectionSearch);
                    }
                    if (options.selectionCssClass != null) {
                        options.selectionAdapter = Utils.Decorate(options.selectionAdapter, SelectionCSS);
                    }
                    options.selectionAdapter = Utils.Decorate(options.selectionAdapter, EventRelay);
                }
                options.language = this._resolveLanguage(options.language);
                options.language.push("en");
                var uniqueLanguages = [];
                for (var l = 0; l < options.language.length; l++) {
                    var language = options.language[l];
                    if (uniqueLanguages.indexOf(language) === -1) {
                        uniqueLanguages.push(language);
                    }
                }
                options.language = uniqueLanguages;
                options.translations = this._processTranslations(options.language, options.debug);
                return options;
            };
            Defaults.prototype.reset = function() {
                function stripDiacritics(text) {
                    function match(a) {
                        return DIACRITICS[a] || a;
                    }
                    return text.replace(/[^\u0000-\u007E]/g, match);
                }
                function matcher(params, data) {
                    if (params.term == null || params.term.trim() === "") {
                        return data;
                    }
                    if (data.children && data.children.length > 0) {
                        var match = $.extend(true, {}, data);
                        for (var c = data.children.length - 1; c >= 0; c--) {
                            var child = data.children[c];
                            var matches = matcher(params, child);
                            if (matches == null) {
                                match.children.splice(c, 1);
                            }
                        }
                        if (match.children.length > 0) {
                            return match;
                        }
                        return matcher(params, match);
                    }
                    var original = stripDiacritics(data.text).toUpperCase();
                    var term = stripDiacritics(params.term).toUpperCase();
                    if (original.indexOf(term) > -1) {
                        return data;
                    }
                    return null;
                }
                this.defaults = {
                    amdLanguageBase: "./i18n/",
                    autocomplete: "off",
                    closeOnSelect: true,
                    debug: false,
                    dropdownAutoWidth: false,
                    escapeMarkup: Utils.escapeMarkup,
                    language: {},
                    matcher: matcher,
                    minimumInputLength: 0,
                    maximumInputLength: 0,
                    maximumSelectionLength: 0,
                    minimumResultsForSearch: 0,
                    selectOnClose: false,
                    scrollAfterSelect: false,
                    sorter: function(data) {
                        return data;
                    },
                    templateResult: function(result) {
                        return result.text;
                    },
                    templateSelection: function(selection) {
                        return selection.text;
                    },
                    theme: "default",
                    width: "resolve"
                };
            };
            Defaults.prototype.applyFromElement = function(options, $element) {
                var optionLanguage = options.language;
                var defaultLanguage = this.defaults.language;
                var elementLanguage = $element.prop("lang");
                var parentLanguage = $element.closest("[lang]").prop("lang");
                var languages = Array.prototype.concat.call(this._resolveLanguage(elementLanguage), this._resolveLanguage(optionLanguage), this._resolveLanguage(defaultLanguage), this._resolveLanguage(parentLanguage));
                options.language = languages;
                return options;
            };
            Defaults.prototype._resolveLanguage = function(language) {
                if (!language) {
                    return [];
                }
                if ($.isEmptyObject(language)) {
                    return [];
                }
                if ($.isPlainObject(language)) {
                    return [ language ];
                }
                var languages;
                if (!Array.isArray(language)) {
                    languages = [ language ];
                } else {
                    languages = language;
                }
                var resolvedLanguages = [];
                for (var l = 0; l < languages.length; l++) {
                    resolvedLanguages.push(languages[l]);
                    if (typeof languages[l] === "string" && languages[l].indexOf("-") > 0) {
                        var languageParts = languages[l].split("-");
                        var baseLanguage = languageParts[0];
                        resolvedLanguages.push(baseLanguage);
                    }
                }
                return resolvedLanguages;
            };
            Defaults.prototype._processTranslations = function(languages, debug) {
                var translations = new Translation();
                for (var l = 0; l < languages.length; l++) {
                    var languageData = new Translation();
                    var language = languages[l];
                    if (typeof language === "string") {
                        try {
                            languageData = Translation.loadPath(language);
                        } catch (e) {
                            try {
                                language = this.defaults.amdLanguageBase + language;
                                languageData = Translation.loadPath(language);
                            } catch (ex) {
                                if (debug && window.console && console.warn) {
                                    console.warn('Select2: The language file for "' + language + '" could ' + "not be automatically loaded. A fallback will be used instead.");
                                }
                            }
                        }
                    } else if ($.isPlainObject(language)) {
                        languageData = new Translation(language);
                    } else {
                        languageData = language;
                    }
                    translations.extend(languageData);
                }
                return translations;
            };
            Defaults.prototype.set = function(key, value) {
                var camelKey = $.camelCase(key);
                var data = {};
                data[camelKey] = value;
                var convertedData = Utils._convertData(data);
                $.extend(true, this.defaults, convertedData);
            };
            var defaults = new Defaults();
            return defaults;
        });
        S2.define("select2/options", [ "jquery", "./defaults", "./utils" ], function($, Defaults, Utils) {
            function Options(options, $element) {
                this.options = options;
                if ($element != null) {
                    this.fromElement($element);
                }
                if ($element != null) {
                    this.options = Defaults.applyFromElement(this.options, $element);
                }
                this.options = Defaults.apply(this.options);
            }
            Options.prototype.fromElement = function($e) {
                var excludedData = [ "select2" ];
                if (this.options.multiple == null) {
                    this.options.multiple = $e.prop("multiple");
                }
                if (this.options.disabled == null) {
                    this.options.disabled = $e.prop("disabled");
                }
                if (this.options.autocomplete == null && $e.prop("autocomplete")) {
                    this.options.autocomplete = $e.prop("autocomplete");
                }
                if (this.options.dir == null) {
                    if ($e.prop("dir")) {
                        this.options.dir = $e.prop("dir");
                    } else if ($e.closest("[dir]").prop("dir")) {
                        this.options.dir = $e.closest("[dir]").prop("dir");
                    } else {
                        this.options.dir = "ltr";
                    }
                }
                $e.prop("disabled", this.options.disabled);
                $e.prop("multiple", this.options.multiple);
                if (Utils.GetData($e[0], "select2Tags")) {
                    if (this.options.debug && window.console && console.warn) {
                        console.warn("Select2: The `data-select2-tags` attribute has been changed to " + 'use the `data-data` and `data-tags="true"` attributes and will be ' + "removed in future versions of Select2.");
                    }
                    Utils.StoreData($e[0], "data", Utils.GetData($e[0], "select2Tags"));
                    Utils.StoreData($e[0], "tags", true);
                }
                if (Utils.GetData($e[0], "ajaxUrl")) {
                    if (this.options.debug && window.console && console.warn) {
                        console.warn("Select2: The `data-ajax-url` attribute has been changed to " + "`data-ajax--url` and support for the old attribute will be removed" + " in future versions of Select2.");
                    }
                    $e.attr("ajax--url", Utils.GetData($e[0], "ajaxUrl"));
                    Utils.StoreData($e[0], "ajax-Url", Utils.GetData($e[0], "ajaxUrl"));
                }
                var dataset = {};
                function upperCaseLetter(_, letter) {
                    return letter.toUpperCase();
                }
                for (var attr = 0; attr < $e[0].attributes.length; attr++) {
                    var attributeName = $e[0].attributes[attr].name;
                    var prefix = "data-";
                    if (attributeName.substr(0, prefix.length) == prefix) {
                        var dataName = attributeName.substring(prefix.length);
                        var dataValue = Utils.GetData($e[0], dataName);
                        var camelDataName = dataName.replace(/-([a-z])/g, upperCaseLetter);
                        dataset[camelDataName] = dataValue;
                    }
                }
                if ($.fn.jquery && $.fn.jquery.substr(0, 2) == "1." && $e[0].dataset) {
                    dataset = $.extend(true, {}, $e[0].dataset, dataset);
                }
                var data = $.extend(true, {}, Utils.GetData($e[0]), dataset);
                data = Utils._convertData(data);
                for (var key in data) {
                    if (excludedData.indexOf(key) > -1) {
                        continue;
                    }
                    if ($.isPlainObject(this.options[key])) {
                        $.extend(this.options[key], data[key]);
                    } else {
                        this.options[key] = data[key];
                    }
                }
                return this;
            };
            Options.prototype.get = function(key) {
                return this.options[key];
            };
            Options.prototype.set = function(key, val) {
                this.options[key] = val;
            };
            return Options;
        });
        S2.define("select2/core", [ "jquery", "./options", "./utils", "./keys" ], function($, Options, Utils, KEYS) {
            var Select2 = function($element, options) {
                if (Utils.GetData($element[0], "select2") != null) {
                    Utils.GetData($element[0], "select2").destroy();
                }
                this.$element = $element;
                this.id = this._generateId($element);
                options = options || {};
                this.options = new Options(options, $element);
                Select2.__super__.constructor.call(this);
                var tabindex = $element.attr("tabindex") || 0;
                Utils.StoreData($element[0], "old-tabindex", tabindex);
                $element.attr("tabindex", "-1");
                var DataAdapter = this.options.get("dataAdapter");
                this.dataAdapter = new DataAdapter($element, this.options);
                var $container = this.render();
                this._placeContainer($container);
                var SelectionAdapter = this.options.get("selectionAdapter");
                this.selection = new SelectionAdapter($element, this.options);
                this.$selection = this.selection.render();
                this.selection.position(this.$selection, $container);
                var DropdownAdapter = this.options.get("dropdownAdapter");
                this.dropdown = new DropdownAdapter($element, this.options);
                this.$dropdown = this.dropdown.render();
                this.dropdown.position(this.$dropdown, $container);
                var ResultsAdapter = this.options.get("resultsAdapter");
                this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
                this.$results = this.results.render();
                this.results.position(this.$results, this.$dropdown);
                var self = this;
                this._bindAdapters();
                this._registerDomEvents();
                this._registerDataEvents();
                this._registerSelectionEvents();
                this._registerDropdownEvents();
                this._registerResultsEvents();
                this._registerEvents();
                this.dataAdapter.current(function(initialData) {
                    self.trigger("selection:update", {
                        data: initialData
                    });
                });
                $element[0].classList.add("select2-hidden-accessible");
                $element.attr("aria-hidden", "true");
                this._syncAttributes();
                Utils.StoreData($element[0], "select2", this);
                $element.data("select2", this);
            };
            Utils.Extend(Select2, Utils.Observable);
            Select2.prototype._generateId = function($element) {
                var id = "";
                if ($element.attr("id") != null) {
                    id = $element.attr("id");
                } else if ($element.attr("name") != null) {
                    id = $element.attr("name") + "-" + Utils.generateChars(2);
                } else {
                    id = Utils.generateChars(4);
                }
                id = id.replace(/(:|\.|\[|\]|,)/g, "");
                id = "select2-" + id;
                return id;
            };
            Select2.prototype._placeContainer = function($container) {
                $container.insertAfter(this.$element);
                var width = this._resolveWidth(this.$element, this.options.get("width"));
                if (width != null) {
                    $container.css("width", width);
                }
            };
            Select2.prototype._resolveWidth = function($element, method) {
                var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;
                if (method == "resolve") {
                    var styleWidth = this._resolveWidth($element, "style");
                    if (styleWidth != null) {
                        return styleWidth;
                    }
                    return this._resolveWidth($element, "element");
                }
                if (method == "element") {
                    var elementWidth = $element.outerWidth(false);
                    if (elementWidth <= 0) {
                        return "auto";
                    }
                    return elementWidth + "px";
                }
                if (method == "style") {
                    var style = $element.attr("style");
                    if (typeof style !== "string") {
                        return null;
                    }
                    var attrs = style.split(";");
                    for (var i = 0, l = attrs.length; i < l; i = i + 1) {
                        var attr = attrs[i].replace(/\s/g, "");
                        var matches = attr.match(WIDTH);
                        if (matches !== null && matches.length >= 1) {
                            return matches[1];
                        }
                    }
                    return null;
                }
                if (method == "computedstyle") {
                    var computedStyle = window.getComputedStyle($element[0]);
                    return computedStyle.width;
                }
                return method;
            };
            Select2.prototype._bindAdapters = function() {
                this.dataAdapter.bind(this, this.$container);
                this.selection.bind(this, this.$container);
                this.dropdown.bind(this, this.$container);
                this.results.bind(this, this.$container);
            };
            Select2.prototype._registerDomEvents = function() {
                var self = this;
                this.$element.on("change.select2", function() {
                    self.dataAdapter.current(function(data) {
                        self.trigger("selection:update", {
                            data: data
                        });
                    });
                });
                this.$element.on("focus.select2", function(evt) {
                    self.trigger("focus", evt);
                });
                this._syncA = Utils.bind(this._syncAttributes, this);
                this._syncS = Utils.bind(this._syncSubtree, this);
                this._observer = new window.MutationObserver(function(mutations) {
                    self._syncA();
                    self._syncS(mutations);
                });
                this._observer.observe(this.$element[0], {
                    attributes: true,
                    childList: true,
                    subtree: false
                });
            };
            Select2.prototype._registerDataEvents = function() {
                var self = this;
                this.dataAdapter.on("*", function(name, params) {
                    self.trigger(name, params);
                });
            };
            Select2.prototype._registerSelectionEvents = function() {
                var self = this;
                var nonRelayEvents = [ "toggle", "focus" ];
                this.selection.on("toggle", function() {
                    self.toggleDropdown();
                });
                this.selection.on("focus", function(params) {
                    self.focus(params);
                });
                this.selection.on("*", function(name, params) {
                    if (nonRelayEvents.indexOf(name) !== -1) {
                        return;
                    }
                    self.trigger(name, params);
                });
            };
            Select2.prototype._registerDropdownEvents = function() {
                var self = this;
                this.dropdown.on("*", function(name, params) {
                    self.trigger(name, params);
                });
            };
            Select2.prototype._registerResultsEvents = function() {
                var self = this;
                this.results.on("*", function(name, params) {
                    self.trigger(name, params);
                });
            };
            Select2.prototype._registerEvents = function() {
                var self = this;
                this.on("open", function() {
                    self.$container[0].classList.add("select2-container--open");
                });
                this.on("close", function() {
                    self.$container[0].classList.remove("select2-container--open");
                });
                this.on("enable", function() {
                    self.$container[0].classList.remove("select2-container--disabled");
                });
                this.on("disable", function() {
                    self.$container[0].classList.add("select2-container--disabled");
                });
                this.on("blur", function() {
                    self.$container[0].classList.remove("select2-container--focus");
                });
                this.on("query", function(params) {
                    if (!self.isOpen()) {
                        self.trigger("open", {});
                    }
                    this.dataAdapter.query(params, function(data) {
                        self.trigger("results:all", {
                            data: data,
                            query: params
                        });
                    });
                });
                this.on("query:append", function(params) {
                    this.dataAdapter.query(params, function(data) {
                        self.trigger("results:append", {
                            data: data,
                            query: params
                        });
                    });
                });
                this.on("keypress", function(evt) {
                    var key = evt.which;
                    if (self.isOpen()) {
                        if (key === KEYS.ESC || key === KEYS.UP && evt.altKey) {
                            self.close(evt);
                            evt.preventDefault();
                        } else if (key === KEYS.ENTER || key === KEYS.TAB) {
                            self.trigger("results:select", {});
                            evt.preventDefault();
                        } else if (key === KEYS.SPACE && evt.ctrlKey) {
                            self.trigger("results:toggle", {});
                            evt.preventDefault();
                        } else if (key === KEYS.UP) {
                            self.trigger("results:previous", {});
                            evt.preventDefault();
                        } else if (key === KEYS.DOWN) {
                            self.trigger("results:next", {});
                            evt.preventDefault();
                        }
                    } else {
                        if (key === KEYS.ENTER || key === KEYS.SPACE || key === KEYS.DOWN && evt.altKey) {
                            self.open();
                            evt.preventDefault();
                        }
                    }
                });
            };
            Select2.prototype._syncAttributes = function() {
                this.options.set("disabled", this.$element.prop("disabled"));
                if (this.isDisabled()) {
                    if (this.isOpen()) {
                        this.close();
                    }
                    this.trigger("disable", {});
                } else {
                    this.trigger("enable", {});
                }
            };
            Select2.prototype._isChangeMutation = function(mutations) {
                var self = this;
                if (mutations.addedNodes && mutations.addedNodes.length > 0) {
                    for (var n = 0; n < mutations.addedNodes.length; n++) {
                        var node = mutations.addedNodes[n];
                        if (node.selected) {
                            return true;
                        }
                    }
                } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
                    return true;
                } else if (Array.isArray(mutations)) {
                    return mutations.some(function(mutation) {
                        return self._isChangeMutation(mutation);
                    });
                }
                return false;
            };
            Select2.prototype._syncSubtree = function(mutations) {
                var changed = this._isChangeMutation(mutations);
                var self = this;
                if (changed) {
                    this.dataAdapter.current(function(currentData) {
                        self.trigger("selection:update", {
                            data: currentData
                        });
                    });
                }
            };
            Select2.prototype.trigger = function(name, args) {
                var actualTrigger = Select2.__super__.trigger;
                var preTriggerMap = {
                    open: "opening",
                    close: "closing",
                    select: "selecting",
                    unselect: "unselecting",
                    clear: "clearing"
                };
                if (args === undefined) {
                    args = {};
                }
                if (name in preTriggerMap) {
                    var preTriggerName = preTriggerMap[name];
                    var preTriggerArgs = {
                        prevented: false,
                        name: name,
                        args: args
                    };
                    actualTrigger.call(this, preTriggerName, preTriggerArgs);
                    if (preTriggerArgs.prevented) {
                        args.prevented = true;
                        return;
                    }
                }
                actualTrigger.call(this, name, args);
            };
            Select2.prototype.toggleDropdown = function() {
                if (this.isDisabled()) {
                    return;
                }
                if (this.isOpen()) {
                    this.close();
                } else {
                    this.open();
                }
            };
            Select2.prototype.open = function() {
                if (this.isOpen()) {
                    return;
                }
                if (this.isDisabled()) {
                    return;
                }
                this.trigger("query", {});
            };
            Select2.prototype.close = function(evt) {
                if (!this.isOpen()) {
                    return;
                }
                this.trigger("close", {
                    originalEvent: evt
                });
            };
            Select2.prototype.isEnabled = function() {
                return !this.isDisabled();
            };
            Select2.prototype.isDisabled = function() {
                return this.options.get("disabled");
            };
            Select2.prototype.isOpen = function() {
                return this.$container[0].classList.contains("select2-container--open");
            };
            Select2.prototype.hasFocus = function() {
                return this.$container[0].classList.contains("select2-container--focus");
            };
            Select2.prototype.focus = function(data) {
                if (this.hasFocus()) {
                    return;
                }
                this.$container[0].classList.add("select2-container--focus");
                this.trigger("focus", {});
            };
            Select2.prototype.enable = function(args) {
                if (this.options.get("debug") && window.console && console.warn) {
                    console.warn('Select2: The `select2("enable")` method has been deprecated and will' + ' be removed in later Select2 versions. Use $element.prop("disabled")' + " instead.");
                }
                if (args == null || args.length === 0) {
                    args = [ true ];
                }
                var disabled = !args[0];
                this.$element.prop("disabled", disabled);
            };
            Select2.prototype.data = function() {
                if (this.options.get("debug") && arguments.length > 0 && window.console && console.warn) {
                    console.warn('Select2: Data can no longer be set using `select2("data")`. You ' + "should consider setting the value instead using `$element.val()`.");
                }
                var data = [];
                this.dataAdapter.current(function(currentData) {
                    data = currentData;
                });
                return data;
            };
            Select2.prototype.val = function(args) {
                if (this.options.get("debug") && window.console && console.warn) {
                    console.warn('Select2: The `select2("val")` method has been deprecated and will be' + " removed in later Select2 versions. Use $element.val() instead.");
                }
                if (args == null || args.length === 0) {
                    return this.$element.val();
                }
                var newVal = args[0];
                if (Array.isArray(newVal)) {
                    newVal = newVal.map(function(obj) {
                        return obj.toString();
                    });
                }
                this.$element.val(newVal).trigger("input").trigger("change");
            };
            Select2.prototype.destroy = function() {
                Utils.RemoveData(this.$container[0]);
                this.$container.remove();
                this._observer.disconnect();
                this._observer = null;
                this._syncA = null;
                this._syncS = null;
                this.$element.off(".select2");
                this.$element.attr("tabindex", Utils.GetData(this.$element[0], "old-tabindex"));
                this.$element[0].classList.remove("select2-hidden-accessible");
                this.$element.attr("aria-hidden", "false");
                Utils.RemoveData(this.$element[0]);
                this.$element.removeData("select2");
                this.dataAdapter.destroy();
                this.selection.destroy();
                this.dropdown.destroy();
                this.results.destroy();
                this.dataAdapter = null;
                this.selection = null;
                this.dropdown = null;
                this.results = null;
            };
            Select2.prototype.render = function() {
                var $container = $('<span class="select2 select2-container">' + '<span class="selection"></span>' + '<span class="dropdown-wrapper" aria-hidden="true"></span>' + "</span>");
                $container.attr("dir", this.options.get("dir"));
                this.$container = $container;
                this.$container[0].classList.add("select2-container--" + this.options.get("theme"));
                Utils.StoreData($container[0], "element", this.$element);
                return $container;
            };
            return Select2;
        });
        S2.define("jquery-mousewheel", [ "jquery" ], function($) {
            return $;
        });
        S2.define("jquery.select2", [ "jquery", "jquery-mousewheel", "./select2/core", "./select2/defaults", "./select2/utils" ], function($, _, Select2, Defaults, Utils) {
            if ($.fn.select2 == null) {
                var thisMethods = [ "open", "close", "destroy" ];
                $.fn.select2 = function(options) {
                    options = options || {};
                    if (typeof options === "object") {
                        this.each(function() {
                            var instanceOptions = $.extend(true, {}, options);
                            var instance = new Select2($(this), instanceOptions);
                        });
                        return this;
                    } else if (typeof options === "string") {
                        var ret;
                        var args = Array.prototype.slice.call(arguments, 1);
                        this.each(function() {
                            var instance = Utils.GetData(this, "select2");
                            if (instance == null && window.console && console.error) {
                                console.error("The select2('" + options + "') method was called on an " + "element that is not using Select2.");
                            }
                            ret = instance[options].apply(instance, args);
                        });
                        if (thisMethods.indexOf(options) > -1) {
                            return this;
                        }
                        return ret;
                    } else {
                        throw new Error("Invalid arguments for Select2: " + options);
                    }
                };
            }
            if ($.fn.select2.defaults == null) {
                $.fn.select2.defaults = Defaults;
            }
            return Select2;
        });
        return {
            define: S2.define,
            require: S2.require
        };
    }();
    var select2 = S2.require("jquery.select2");
    jQuery.fn.select2.amd = S2;
    return select2;
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "./blueimp-helper" ], factory);
    } else {
        window.blueimp = window.blueimp || {};
        window.blueimp.Gallery = factory(window.blueimp.helper || window.jQuery);
    }
})(function($) {
    "use strict";
    function Gallery(list, options) {
        if (document.body.style.maxHeight === undefined) {
            return null;
        }
        if (!this || this.options !== Gallery.prototype.options) {
            return new Gallery(list, options);
        }
        if (!list || !list.length) {
            this.console.log("blueimp Gallery: No or empty list provided as first argument.", list);
            return;
        }
        this.list = list;
        this.num = list.length;
        this.initOptions(options);
        this.initialize();
    }
    $.extend(Gallery.prototype, {
        options: {
            container: "#blueimp-gallery",
            slidesContainer: "div",
            titleElement: "h3",
            displayClass: "blueimp-gallery-display",
            controlsClass: "blueimp-gallery-controls",
            singleClass: "blueimp-gallery-single",
            leftEdgeClass: "blueimp-gallery-left",
            rightEdgeClass: "blueimp-gallery-right",
            playingClass: "blueimp-gallery-playing",
            svgasimgClass: "blueimp-gallery-svgasimg",
            smilClass: "blueimp-gallery-smil",
            slideClass: "slide",
            slideActiveClass: "slide-active",
            slidePrevClass: "slide-prev",
            slideNextClass: "slide-next",
            slideLoadingClass: "slide-loading",
            slideErrorClass: "slide-error",
            slideContentClass: "slide-content",
            toggleClass: "toggle",
            prevClass: "prev",
            nextClass: "next",
            closeClass: "btn-close",
            playPauseClass: "play-pause",
            typeProperty: "type",
            titleProperty: "title",
            altTextProperty: "alt",
            urlProperty: "href",
            srcsetProperty: "srcset",
            sizesProperty: "sizes",
            sourcesProperty: "sources",
            displayTransition: true,
            clearSlides: true,
            toggleControlsOnEnter: true,
            toggleControlsOnSlideClick: true,
            toggleSlideshowOnSpace: true,
            enableKeyboardNavigation: true,
            closeOnEscape: true,
            closeOnSlideClick: true,
            closeOnSwipeUpOrDown: true,
            closeOnHashChange: true,
            emulateTouchEvents: true,
            stopTouchEventsPropagation: false,
            hidePageScrollbars: true,
            disableScroll: true,
            carousel: false,
            continuous: true,
            unloadElements: true,
            startSlideshow: false,
            slideshowInterval: 5e3,
            slideshowDirection: "ltr",
            index: 0,
            preloadRange: 2,
            transitionDuration: 300,
            slideshowTransitionDuration: 500,
            event: undefined,
            onopen: undefined,
            onopened: undefined,
            onslide: undefined,
            onslideend: undefined,
            onslidecomplete: undefined,
            onclose: undefined,
            onclosed: undefined
        },
        carouselOptions: {
            hidePageScrollbars: false,
            toggleControlsOnEnter: false,
            toggleSlideshowOnSpace: false,
            enableKeyboardNavigation: false,
            closeOnEscape: false,
            closeOnSlideClick: false,
            closeOnSwipeUpOrDown: false,
            closeOnHashChange: false,
            disableScroll: false,
            startSlideshow: true
        },
        console: window.console && typeof window.console.log === "function" ? window.console : {
            log: function() {}
        },
        support: function(element) {
            var support = {
                source: !!window.HTMLSourceElement,
                picture: !!window.HTMLPictureElement,
                svgasimg: document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1"),
                smil: !!document.createElementNS && /SVGAnimate/.test(document.createElementNS("http://www.w3.org/2000/svg", "animate").toString()),
                touch: window.ontouchstart !== undefined || window.DocumentTouch && document instanceof DocumentTouch
            };
            var transitions = {
                webkitTransition: {
                    end: "webkitTransitionEnd",
                    prefix: "-webkit-"
                },
                MozTransition: {
                    end: "transitionend",
                    prefix: "-moz-"
                },
                OTransition: {
                    end: "otransitionend",
                    prefix: "-o-"
                },
                transition: {
                    end: "transitionend",
                    prefix: ""
                }
            };
            var prop;
            for (prop in transitions) {
                if (Object.prototype.hasOwnProperty.call(transitions, prop) && element.style[prop] !== undefined) {
                    support.transition = transitions[prop];
                    support.transition.name = prop;
                    break;
                }
            }
            function elementTests() {
                var transition = support.transition;
                var prop;
                var translateZ;
                document.body.appendChild(element);
                if (transition) {
                    prop = transition.name.slice(0, -9) + "ransform";
                    if (element.style[prop] !== undefined) {
                        element.style[prop] = "translateZ(0)";
                        translateZ = window.getComputedStyle(element).getPropertyValue(transition.prefix + "transform");
                        support.transform = {
                            prefix: transition.prefix,
                            name: prop,
                            translate: true,
                            translateZ: !!translateZ && translateZ !== "none"
                        };
                    }
                }
                document.body.removeChild(element);
            }
            if (document.body) {
                elementTests();
            } else {
                $(document).on("DOMContentLoaded", elementTests);
            }
            return support;
        }(document.createElement("div")),
        requestAnimationFrame: window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame,
        cancelAnimationFrame: window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame,
        initialize: function() {
            this.initStartIndex();
            if (this.initWidget() === false) {
                return false;
            }
            this.initEventListeners();
            this.onslide(this.index);
            this.ontransitionend();
            if (this.options.startSlideshow) {
                this.play();
            }
        },
        slide: function(to, duration) {
            window.clearTimeout(this.timeout);
            var index = this.index;
            var direction;
            var naturalDirection;
            var diff;
            if (index === to || this.num === 1) {
                return;
            }
            if (!duration) {
                duration = this.options.transitionDuration;
            }
            if (this.support.transform) {
                if (!this.options.continuous) {
                    to = this.circle(to);
                }
                direction = Math.abs(index - to) / (index - to);
                if (this.options.continuous) {
                    naturalDirection = direction;
                    direction = -this.positions[this.circle(to)] / this.slideWidth;
                    if (direction !== naturalDirection) {
                        to = -direction * this.num + to;
                    }
                }
                diff = Math.abs(index - to) - 1;
                while (diff) {
                    diff -= 1;
                    this.move(this.circle((to > index ? to : index) - diff - 1), this.slideWidth * direction, 0);
                }
                to = this.circle(to);
                this.move(index, this.slideWidth * direction, duration);
                this.move(to, 0, duration);
                if (this.options.continuous) {
                    this.move(this.circle(to - direction), -(this.slideWidth * direction), 0);
                }
            } else {
                to = this.circle(to);
                this.animate(index * -this.slideWidth, to * -this.slideWidth, duration);
            }
            this.onslide(to);
        },
        getIndex: function() {
            return this.index;
        },
        getNumber: function() {
            return this.num;
        },
        prev: function() {
            if (this.options.continuous || this.index) {
                this.slide(this.index - 1);
            }
        },
        next: function() {
            if (this.options.continuous || this.index < this.num - 1) {
                this.slide(this.index + 1);
            }
        },
        play: function(time) {
            var that = this;
            var nextIndex = this.index + (this.options.slideshowDirection === "rtl" ? -1 : 1);
            window.clearTimeout(this.timeout);
            this.interval = time || this.options.slideshowInterval;
            if (this.elements[this.index] > 1) {
                this.timeout = this.setTimeout(!this.requestAnimationFrame && this.slide || function(to, duration) {
                    that.animationFrameId = that.requestAnimationFrame.call(window, function() {
                        that.slide(to, duration);
                    });
                }, [ nextIndex, this.options.slideshowTransitionDuration ], this.interval);
            }
            this.container.addClass(this.options.playingClass);
            this.slidesContainer[0].setAttribute("aria-live", "off");
            if (this.playPauseElement.length) {
                this.playPauseElement[0].setAttribute("aria-pressed", "true");
            }
        },
        pause: function() {
            window.clearTimeout(this.timeout);
            this.interval = null;
            if (this.cancelAnimationFrame) {
                this.cancelAnimationFrame.call(window, this.animationFrameId);
                this.animationFrameId = null;
            }
            this.container.removeClass(this.options.playingClass);
            this.slidesContainer[0].setAttribute("aria-live", "polite");
            if (this.playPauseElement.length) {
                this.playPauseElement[0].setAttribute("aria-pressed", "false");
            }
        },
        add: function(list) {
            var i;
            if (!list.concat) {
                list = Array.prototype.slice.call(list);
            }
            if (!this.list.concat) {
                this.list = Array.prototype.slice.call(this.list);
            }
            this.list = this.list.concat(list);
            this.num = this.list.length;
            if (this.num > 2 && this.options.continuous === null) {
                this.options.continuous = true;
                this.container.removeClass(this.options.leftEdgeClass);
            }
            this.container.removeClass(this.options.rightEdgeClass).removeClass(this.options.singleClass);
            for (i = this.num - list.length; i < this.num; i += 1) {
                this.addSlide(i);
                this.positionSlide(i);
            }
            this.positions.length = this.num;
            this.initSlides(true);
        },
        resetSlides: function() {
            this.slidesContainer.empty();
            this.unloadAllSlides();
            this.slides = [];
        },
        handleClose: function() {
            var options = this.options;
            this.destroyEventListeners();
            this.pause();
            this.container[0].style.display = "none";
            this.container.removeClass(options.displayClass).removeClass(options.singleClass).removeClass(options.leftEdgeClass).removeClass(options.rightEdgeClass);
            if (options.hidePageScrollbars) {
                document.body.style.overflow = this.bodyOverflowStyle;
            }
            if (this.options.clearSlides) {
                this.resetSlides();
            }
            if (this.options.onclosed) {
                this.options.onclosed.call(this);
            }
        },
        close: function() {
            var that = this;
            function closeHandler(event) {
                if (event.target === that.container[0]) {
                    that.container.off(that.support.transition.end, closeHandler);
                    that.handleClose();
                }
            }
            if (this.options.onclose) {
                this.options.onclose.call(this);
            }
            if (this.support.transition && this.options.displayTransition) {
                this.container.on(this.support.transition.end, closeHandler);
                this.container.removeClass(this.options.displayClass);
            } else {
                this.handleClose();
            }
        },
        circle: function(index) {
            return (this.num + index % this.num) % this.num;
        },
        move: function(index, dist, duration) {
            this.translateX(index, dist, duration);
            this.positions[index] = dist;
        },
        translate: function(index, x, y, duration) {
            if (!this.slides[index]) return;
            var style = this.slides[index].style;
            var transition = this.support.transition;
            var transform = this.support.transform;
            style[transition.name + "Duration"] = duration + "ms";
            style[transform.name] = "translate(" + x + "px, " + y + "px)" + (transform.translateZ ? " translateZ(0)" : "");
        },
        translateX: function(index, x, duration) {
            this.translate(index, x, 0, duration);
        },
        translateY: function(index, y, duration) {
            this.translate(index, 0, y, duration);
        },
        animate: function(from, to, duration) {
            if (!duration) {
                this.slidesContainer[0].style.left = to + "px";
                return;
            }
            var that = this;
            var start = new Date().getTime();
            var timer = window.setInterval(function() {
                var timeElap = new Date().getTime() - start;
                if (timeElap > duration) {
                    that.slidesContainer[0].style.left = to + "px";
                    that.ontransitionend();
                    window.clearInterval(timer);
                    return;
                }
                that.slidesContainer[0].style.left = (to - from) * (Math.floor(timeElap / duration * 100) / 100) + from + "px";
            }, 4);
        },
        preventDefault: function(event) {
            if (event.preventDefault) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        },
        stopPropagation: function(event) {
            if (event.stopPropagation) {
                event.stopPropagation();
            } else {
                event.cancelBubble = true;
            }
        },
        onresize: function() {
            this.initSlides(true);
        },
        onhashchange: function() {
            if (this.options.closeOnHashChange) {
                this.close();
            }
        },
        onmousedown: function(event) {
            if (event.which && event.which === 1 && event.target.nodeName !== "VIDEO" && event.target.nodeName !== "AUDIO") {
                event.preventDefault();
                (event.originalEvent || event).touches = [ {
                    pageX: event.pageX,
                    pageY: event.pageY
                } ];
                this.ontouchstart(event);
            }
        },
        onmousemove: function(event) {
            if (this.touchStart) {
                (event.originalEvent || event).touches = [ {
                    pageX: event.pageX,
                    pageY: event.pageY
                } ];
                this.ontouchmove(event);
            }
        },
        onmouseup: function(event) {
            if (this.touchStart) {
                this.ontouchend(event);
                delete this.touchStart;
            }
        },
        onmouseout: function(event) {
            if (this.touchStart) {
                var target = event.target;
                var related = event.relatedTarget;
                if (!related || related !== target && !$.contains(target, related)) {
                    this.onmouseup(event);
                }
            }
        },
        ontouchstart: function(event) {
            if (this.options.stopTouchEventsPropagation) {
                this.stopPropagation(event);
            }
            var touch = (event.originalEvent || event).touches[0];
            this.touchStart = {
                x: touch.pageX,
                y: touch.pageY,
                time: Date.now()
            };
            this.isScrolling = undefined;
            this.touchDelta = {};
        },
        ontouchmove: function(event) {
            if (this.options.stopTouchEventsPropagation) {
                this.stopPropagation(event);
            }
            var touches = (event.originalEvent || event).touches;
            var touch = touches[0];
            var scale = (event.originalEvent || event).scale;
            var index = this.index;
            var touchDeltaX;
            var indices;
            if (touches.length > 1 || scale && scale !== 1) {
                return;
            }
            if (this.options.disableScroll) {
                event.preventDefault();
            }
            this.touchDelta = {
                x: touch.pageX - this.touchStart.x,
                y: touch.pageY - this.touchStart.y
            };
            touchDeltaX = this.touchDelta.x;
            if (this.isScrolling === undefined) {
                this.isScrolling = this.isScrolling || Math.abs(touchDeltaX) < Math.abs(this.touchDelta.y);
            }
            if (!this.isScrolling) {
                event.preventDefault();
                window.clearTimeout(this.timeout);
                if (this.options.continuous) {
                    indices = [ this.circle(index + 1), index, this.circle(index - 1) ];
                } else {
                    this.touchDelta.x = touchDeltaX = touchDeltaX / (!index && touchDeltaX > 0 || index === this.num - 1 && touchDeltaX < 0 ? Math.abs(touchDeltaX) / this.slideWidth + 1 : 1);
                    indices = [ index ];
                    if (index) {
                        indices.push(index - 1);
                    }
                    if (index < this.num - 1) {
                        indices.unshift(index + 1);
                    }
                }
                while (indices.length) {
                    index = indices.pop();
                    this.translateX(index, touchDeltaX + this.positions[index], 0);
                }
            } else if (!this.options.carousel) {
                this.translateY(index, this.touchDelta.y + this.positions[index], 0);
            }
        },
        ontouchend: function(event) {
            if (this.options.stopTouchEventsPropagation) {
                this.stopPropagation(event);
            }
            var index = this.index;
            var absTouchDeltaX = Math.abs(this.touchDelta.x);
            var slideWidth = this.slideWidth;
            var duration = Math.ceil(this.options.transitionDuration * (1 - absTouchDeltaX / slideWidth) / 2);
            var isValidSlide = absTouchDeltaX > 20;
            var isPastBounds = !index && this.touchDelta.x > 0 || index === this.num - 1 && this.touchDelta.x < 0;
            var isValidClose = !isValidSlide && this.options.closeOnSwipeUpOrDown && Math.abs(this.touchDelta.y) > 20;
            var direction;
            var indexForward;
            var indexBackward;
            var distanceForward;
            var distanceBackward;
            if (this.options.continuous) {
                isPastBounds = false;
            }
            direction = this.touchDelta.x < 0 ? -1 : 1;
            if (!this.isScrolling) {
                if (isValidSlide && !isPastBounds) {
                    indexForward = index + direction;
                    indexBackward = index - direction;
                    distanceForward = slideWidth * direction;
                    distanceBackward = -slideWidth * direction;
                    if (this.options.continuous) {
                        this.move(this.circle(indexForward), distanceForward, 0);
                        this.move(this.circle(index - 2 * direction), distanceBackward, 0);
                    } else if (indexForward >= 0 && indexForward < this.num) {
                        this.move(indexForward, distanceForward, 0);
                    }
                    this.move(index, this.positions[index] + distanceForward, duration);
                    this.move(this.circle(indexBackward), this.positions[this.circle(indexBackward)] + distanceForward, duration);
                    index = this.circle(indexBackward);
                    this.onslide(index);
                } else {
                    if (this.options.continuous) {
                        this.move(this.circle(index - 1), -slideWidth, duration);
                        this.move(index, 0, duration);
                        this.move(this.circle(index + 1), slideWidth, duration);
                    } else {
                        if (index) {
                            this.move(index - 1, -slideWidth, duration);
                        }
                        this.move(index, 0, duration);
                        if (index < this.num - 1) {
                            this.move(index + 1, slideWidth, duration);
                        }
                    }
                }
            } else {
                if (isValidClose) {
                    this.close();
                } else {
                    this.translateY(index, 0, duration);
                }
            }
        },
        ontouchcancel: function(event) {
            if (this.touchStart) {
                this.ontouchend(event);
                delete this.touchStart;
            }
        },
        ontransitionend: function(event) {
            var slide = this.slides[this.index];
            if (!event || slide === event.target) {
                if (this.interval) {
                    this.play();
                }
                this.setTimeout(this.options.onslideend, [ this.index, slide ]);
            }
        },
        oncomplete: function(event) {
            var target = event.target || event.srcElement;
            var parent = target && target.parentNode;
            var index;
            if (!target || !parent) {
                return;
            }
            index = this.getNodeIndex(parent);
            $(parent).removeClass(this.options.slideLoadingClass);
            if (event.type === "error") {
                $(parent).addClass(this.options.slideErrorClass);
                this.elements[index] = 3;
            } else {
                this.elements[index] = 2;
            }
            if (target.clientHeight > this.container[0].clientHeight) {
                target.style.maxHeight = this.container[0].clientHeight;
            }
            if (this.interval && this.slides[this.index] === parent) {
                this.play();
            }
            this.setTimeout(this.options.onslidecomplete, [ index, parent ]);
        },
        onload: function(event) {
            this.oncomplete(event);
        },
        onerror: function(event) {
            this.oncomplete(event);
        },
        onkeydown: function(event) {
            switch (event.which || event.keyCode) {
              case 13:
                if (this.options.toggleControlsOnEnter) {
                    this.preventDefault(event);
                    this.toggleControls();
                }
                break;

              case 27:
                if (this.options.closeOnEscape) {
                    this.close();
                    event.stopImmediatePropagation();
                }
                break;

              case 32:
                if (this.options.toggleSlideshowOnSpace) {
                    this.preventDefault(event);
                    this.toggleSlideshow();
                }
                break;

              case 37:
                if (this.options.enableKeyboardNavigation) {
                    this.preventDefault(event);
                    this.prev();
                }
                break;

              case 39:
                if (this.options.enableKeyboardNavigation) {
                    this.preventDefault(event);
                    this.next();
                }
                break;
            }
        },
        handleClick: function(event) {
            var options = this.options;
            var target = event.target || event.srcElement;
            var parent = target.parentNode;
            function isTarget(className) {
                return $(target).hasClass(className) || $(parent).hasClass(className);
            }
            if (isTarget(options.toggleClass)) {
                this.preventDefault(event);
                this.toggleControls();
            } else if (isTarget(options.prevClass)) {
                this.preventDefault(event);
                this.prev();
            } else if (isTarget(options.nextClass)) {
                this.preventDefault(event);
                this.next();
            } else if (isTarget(options.closeClass)) {
                this.preventDefault(event);
                this.close();
            } else if (isTarget(options.playPauseClass)) {
                this.preventDefault(event);
                this.toggleSlideshow();
            } else if (parent === this.slidesContainer[0]) {
                if (options.closeOnSlideClick) {
                    this.preventDefault(event);
                    this.close();
                } else if (options.toggleControlsOnSlideClick) {
                    this.preventDefault(event);
                    this.toggleControls();
                }
            } else if (parent.parentNode && parent.parentNode === this.slidesContainer[0]) {
                if (options.toggleControlsOnSlideClick) {
                    this.preventDefault(event);
                    this.toggleControls();
                }
            }
        },
        onclick: function(event) {
            if (this.options.emulateTouchEvents && this.touchDelta && (Math.abs(this.touchDelta.x) > 20 || Math.abs(this.touchDelta.y) > 20)) {
                delete this.touchDelta;
                return;
            }
            return this.handleClick(event);
        },
        updateEdgeClasses: function(index) {
            if (!index) {
                this.container.addClass(this.options.leftEdgeClass);
            } else {
                this.container.removeClass(this.options.leftEdgeClass);
            }
            if (index === this.num - 1) {
                this.container.addClass(this.options.rightEdgeClass);
            } else {
                this.container.removeClass(this.options.rightEdgeClass);
            }
        },
        updateActiveSlide: function(oldIndex, newIndex) {
            var slides = this.slides;
            var options = this.options;
            var list = [ {
                index: newIndex,
                method: "addClass",
                hidden: false
            }, {
                index: oldIndex,
                method: "removeClass",
                hidden: true
            } ];
            var item, index;
            while (list.length) {
                item = list.pop();
                $(slides[item.index])[item.method](options.slideActiveClass);
                index = this.circle(item.index - 1);
                if (options.continuous || index < item.index) {
                    $(slides[index])[item.method](options.slidePrevClass);
                }
                index = this.circle(item.index + 1);
                if (options.continuous || index > item.index) {
                    $(slides[index])[item.method](options.slideNextClass);
                }
            }
            this.slides[oldIndex].setAttribute("aria-hidden", "true");
            this.slides[newIndex].removeAttribute("aria-hidden");
        },
        handleSlide: function(oldIndex, newIndex) {
            if (!this.options.continuous) {
                this.updateEdgeClasses(newIndex);
            }
            this.updateActiveSlide(oldIndex, newIndex);
            this.loadElements(newIndex);
            if (this.options.unloadElements) {
                this.unloadElements(oldIndex, newIndex);
            }
            this.setTitle(newIndex);
        },
        onslide: function(index) {
            this.handleSlide(this.index, index);
            this.index = index;
            this.setTimeout(this.options.onslide, [ index, this.slides[index] ]);
        },
        setTitle: function(index) {
            var firstChild = this.slides[index].firstChild;
            var text = firstChild.title || firstChild.alt;
            var titleElement = this.titleElement;
            if (titleElement.length) {
                this.titleElement.empty();
                if (text) {
                    titleElement[0].appendChild(document.createTextNode(text));
                }
            }
        },
        setTimeout: function(func, args, wait) {
            var that = this;
            return func && window.setTimeout(function() {
                func.apply(that, args || []);
            }, wait || 0);
        },
        imageFactory: function(obj, callback) {
            var options = this.options;
            var that = this;
            var url = obj;
            var img = this.imagePrototype.cloneNode(false);
            var picture;
            var called;
            var sources;
            var srcset;
            var sizes;
            var title;
            var altText;
            var i;
            function callbackWrapper(event) {
                if (!called) {
                    event = {
                        type: event.type,
                        target: picture || img
                    };
                    if (!event.target.parentNode) {
                        return that.setTimeout(callbackWrapper, [ event ]);
                    }
                    called = true;
                    $(img).off("load error", callbackWrapper);
                    callback(event);
                }
            }
            if (typeof url !== "string") {
                url = this.getItemProperty(obj, options.urlProperty);
                sources = this.support.picture && this.support.source && this.getItemProperty(obj, options.sourcesProperty);
                srcset = this.getItemProperty(obj, options.srcsetProperty);
                sizes = this.getItemProperty(obj, options.sizesProperty);
                title = this.getItemProperty(obj, options.titleProperty);
                altText = this.getItemProperty(obj, options.altTextProperty) || title;
            }
            img.draggable = false;
            if (title) {
                img.title = title;
            }
            if (altText) {
                img.alt = altText;
            }
            $(img).on("load error", callbackWrapper);
            if (sources && sources.length) {
                picture = this.picturePrototype.cloneNode(false);
                for (i = 0; i < sources.length; i += 1) {
                    picture.appendChild($.extend(this.sourcePrototype.cloneNode(false), sources[i]));
                }
                picture.appendChild(img);
                $(picture).addClass(options.toggleClass);
            }
            if (srcset) {
                if (sizes) {
                    img.sizes = sizes;
                }
                img.srcset = srcset;
            }
            img.src = url;
            if (picture) return picture;
            return img;
        },
        createElement: function(obj, callback) {
            var type = obj && this.getItemProperty(obj, this.options.typeProperty);
            var factory = type && this[type.split("/")[0] + "Factory"] || this.imageFactory;
            var element = obj && factory.call(this, obj, callback);
            if (!element) {
                element = this.elementPrototype.cloneNode(false);
                this.setTimeout(callback, [ {
                    type: "error",
                    target: element
                } ]);
            }
            $(element).addClass(this.options.slideContentClass);
            return element;
        },
        iteratePreloadRange: function(index, func) {
            var num = this.num;
            var options = this.options;
            var limit = Math.min(num, options.preloadRange * 2 + 1);
            var j = index;
            var i;
            for (i = 0; i < limit; i += 1) {
                j += i * (i % 2 === 0 ? -1 : 1);
                if (j < 0 || j >= num) {
                    if (!options.continuous) continue;
                    j = this.circle(j);
                }
                func.call(this, j);
            }
        },
        loadElement: function(index) {
            if (!this.elements[index]) {
                if (this.slides[index].firstChild) {
                    this.elements[index] = $(this.slides[index]).hasClass(this.options.slideErrorClass) ? 3 : 2;
                } else {
                    this.elements[index] = 1;
                    $(this.slides[index]).addClass(this.options.slideLoadingClass);
                    this.slides[index].appendChild(this.createElement(this.list[index], this.proxyListener));
                }
            }
        },
        loadElements: function(index) {
            this.iteratePreloadRange(index, this.loadElement);
        },
        unloadElements: function(oldIndex, newIndex) {
            var preloadRange = this.options.preloadRange;
            this.iteratePreloadRange(oldIndex, function(i) {
                var diff = Math.abs(i - newIndex);
                if (diff > preloadRange && diff + preloadRange < this.num) {
                    this.unloadSlide(i);
                    delete this.elements[i];
                }
            });
        },
        addSlide: function(index) {
            var slide = this.slidePrototype.cloneNode(false);
            slide.setAttribute("data-index", index);
            slide.setAttribute("aria-hidden", "true");
            this.slidesContainer[0].appendChild(slide);
            this.slides.push(slide);
        },
        positionSlide: function(index) {
            var slide = this.slides[index];
            slide.style.width = this.slideWidth + "px";
            if (this.support.transform) {
                slide.style.left = index * -this.slideWidth + "px";
                this.move(index, this.index > index ? -this.slideWidth : this.index < index ? this.slideWidth : 0, 0);
            }
        },
        initSlides: function(reload) {
            var clearSlides, i;
            if (!reload) {
                this.positions = [];
                this.positions.length = this.num;
                this.elements = {};
                this.picturePrototype = this.support.picture && document.createElement("picture");
                this.sourcePrototype = this.support.source && document.createElement("source");
                this.imagePrototype = document.createElement("img");
                this.elementPrototype = document.createElement("div");
                this.slidePrototype = this.elementPrototype.cloneNode(false);
                $(this.slidePrototype).addClass(this.options.slideClass);
                this.slides = this.slidesContainer[0].children;
                clearSlides = this.options.clearSlides || this.slides.length !== this.num;
            }
            this.slideWidth = this.container[0].clientWidth;
            this.slideHeight = this.container[0].clientHeight;
            this.slidesContainer[0].style.width = this.num * this.slideWidth + "px";
            if (clearSlides) {
                this.resetSlides();
            }
            for (i = 0; i < this.num; i += 1) {
                if (clearSlides) {
                    this.addSlide(i);
                }
                this.positionSlide(i);
            }
            if (this.options.continuous && this.support.transform) {
                this.move(this.circle(this.index - 1), -this.slideWidth, 0);
                this.move(this.circle(this.index + 1), this.slideWidth, 0);
            }
            if (!this.support.transform) {
                this.slidesContainer[0].style.left = this.index * -this.slideWidth + "px";
            }
        },
        unloadSlide: function(index) {
            var slide, firstChild;
            slide = this.slides[index];
            firstChild = slide.firstChild;
            if (firstChild !== null) {
                slide.removeChild(firstChild);
            }
        },
        unloadAllSlides: function() {
            var i, len;
            for (i = 0, len = this.slides.length; i < len; i++) {
                this.unloadSlide(i);
            }
        },
        toggleControls: function() {
            var controlsClass = this.options.controlsClass;
            if (this.container.hasClass(controlsClass)) {
                this.container.removeClass(controlsClass);
            } else {
                this.container.addClass(controlsClass);
            }
        },
        toggleSlideshow: function() {
            if (!this.interval) {
                this.play();
            } else {
                this.pause();
            }
        },
        getNodeIndex: function(element) {
            return parseInt(element.getAttribute("data-index"), 10);
        },
        getNestedProperty: function(obj, property) {
            property.replace(/\[(?:'([^']+)'|"([^"]+)"|(\d+))\]|(?:(?:^|\.)([^\.\[]+))/g, function(str, singleQuoteProp, doubleQuoteProp, arrayIndex, dotProp) {
                var prop = dotProp || singleQuoteProp || doubleQuoteProp || arrayIndex && parseInt(arrayIndex, 10);
                if (str && obj) {
                    obj = obj[prop];
                }
            });
            return obj;
        },
        getDataProperty: function(obj, property) {
            var key;
            var prop;
            if (obj.dataset) {
                key = property.replace(/-([a-z])/g, function(_, b) {
                    return b.toUpperCase();
                });
                prop = obj.dataset[key];
            } else if (obj.getAttribute) {
                prop = obj.getAttribute("data-" + property.replace(/([A-Z])/g, "-$1").toLowerCase());
            }
            if (typeof prop === "string") {
                if (/^(true|false|null|-?\d+(\.\d+)?|\{[\s\S]*\}|\[[\s\S]*\])$/.test(prop)) {
                    try {
                        return $.parseJSON(prop);
                    } catch (ignore) {}
                }
                return prop;
            }
        },
        getItemProperty: function(obj, property) {
            var prop = this.getDataProperty(obj, property);
            if (prop === undefined) {
                prop = obj[property];
            }
            if (prop === undefined) {
                prop = this.getNestedProperty(obj, property);
            }
            return prop;
        },
        initStartIndex: function() {
            var index = this.options.index;
            var urlProperty = this.options.urlProperty;
            var i;
            if (index && typeof index !== "number") {
                for (i = 0; i < this.num; i += 1) {
                    if (this.list[i] === index || this.getItemProperty(this.list[i], urlProperty) === this.getItemProperty(index, urlProperty)) {
                        index = i;
                        break;
                    }
                }
            }
            this.index = this.circle(parseInt(index, 10) || 0);
        },
        initEventListeners: function() {
            var that = this;
            var slidesContainer = this.slidesContainer;
            function proxyListener(event) {
                var type = that.support.transition && that.support.transition.end === event.type ? "transitionend" : event.type;
                that["on" + type](event);
            }
            $(window).on("resize", proxyListener);
            $(window).on("hashchange", proxyListener);
            $(document.body).on("keydown", proxyListener);
            this.container.on("click", proxyListener);
            if (this.support.touch) {
                slidesContainer.on("touchstart touchmove touchend touchcancel", proxyListener);
            } else if (this.options.emulateTouchEvents && this.support.transition) {
                slidesContainer.on("mousedown mousemove mouseup mouseout", proxyListener);
            }
            if (this.support.transition) {
                slidesContainer.on(this.support.transition.end, proxyListener);
            }
            this.proxyListener = proxyListener;
        },
        destroyEventListeners: function() {
            var slidesContainer = this.slidesContainer;
            var proxyListener = this.proxyListener;
            $(window).off("resize", proxyListener);
            $(document.body).off("keydown", proxyListener);
            this.container.off("click", proxyListener);
            if (this.support.touch) {
                slidesContainer.off("touchstart touchmove touchend touchcancel", proxyListener);
            } else if (this.options.emulateTouchEvents && this.support.transition) {
                slidesContainer.off("mousedown mousemove mouseup mouseout", proxyListener);
            }
            if (this.support.transition) {
                slidesContainer.off(this.support.transition.end, proxyListener);
            }
        },
        handleOpen: function() {
            if (this.options.onopened) {
                this.options.onopened.call(this);
            }
        },
        initWidget: function() {
            var that = this;
            function openHandler(event) {
                if (event.target === that.container[0]) {
                    that.container.off(that.support.transition.end, openHandler);
                    that.handleOpen();
                }
            }
            this.container = $(this.options.container);
            if (!this.container.length) {
                this.console.log("blueimp Gallery: Widget container not found.", this.options.container);
                return false;
            }
            this.slidesContainer = this.container.find(this.options.slidesContainer).first();
            if (!this.slidesContainer.length) {
                this.console.log("blueimp Gallery: Slides container not found.", this.options.slidesContainer);
                return false;
            }
            this.titleElement = this.container.find(this.options.titleElement).first();
            this.playPauseElement = this.container.find("." + this.options.playPauseClass).first();
            if (this.num === 1) {
                this.container.addClass(this.options.singleClass);
            }
            if (this.support.svgasimg) {
                this.container.addClass(this.options.svgasimgClass);
            }
            if (this.support.smil) {
                this.container.addClass(this.options.smilClass);
            }
            if (this.options.onopen) {
                this.options.onopen.call(this);
            }
            if (this.support.transition && this.options.displayTransition) {
                this.container.on(this.support.transition.end, openHandler);
            } else {
                this.handleOpen();
            }
            if (this.options.hidePageScrollbars) {
                this.bodyOverflowStyle = document.body.style.overflow;
                document.body.style.overflow = "hidden";
            }
            this.container[0].style.display = "block";
            this.initSlides();
            this.container.addClass(this.options.displayClass);
        },
        initOptions: function(options) {
            this.options = $.extend({}, this.options);
            if (options && options.carousel || this.options.carousel && (!options || options.carousel !== false)) {
                $.extend(this.options, this.carouselOptions);
            }
            $.extend(this.options, options);
            if (this.num < 3) {
                this.options.continuous = this.options.continuous ? null : false;
            }
            if (!this.support.transition) {
                this.options.emulateTouchEvents = false;
            }
            if (this.options.event) {
                this.preventDefault(this.options.event);
            }
        }
    });
    return Gallery;
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "./blueimp-gallery" ], factory);
    } else {
        factory(window.jQuery, window.blueimp.Gallery);
    }
})(function($, Gallery) {
    "use strict";
    $(document).on("click", "[data-gallery]", function(event) {
        var id = $(this).data("gallery");
        var widget = $(id);
        var container = widget.length && widget || $(Gallery.prototype.options.container);
        var callbacks = {
            onopen: function() {
                $("#blueimp-gallery").removeClass("d-none");
                container.data("gallery", this).trigger("open");
            },
            onopened: function() {
                container.trigger("opened");
            },
            onslide: function() {
                container.trigger("slide", arguments);
            },
            onslideend: function() {
                container.trigger("slideend", arguments);
            },
            onslidecomplete: function() {
                container.trigger("slidecomplete", arguments);
            },
            onclose: function() {
                $("#blueimp-gallery").addClass("d-none");
                container.trigger("close");
                document.body.style.overflow = null;
            },
            onclosed: function() {
                container.trigger("closed").removeData("gallery");
            }
        };
        var options = $.extend(container.data(), {
            container: container[0],
            index: this,
            event: event
        }, callbacks);
        var links = $(this).closest("[data-gallery-group], body").find('[data-gallery="' + id + '"]');
        if (options.filter) {
            links = links.filter(options.filter);
        }
        return new Gallery(links, options);
    });
});

(function() {
    "use strict";
    function setup($) {
        $.fn._fadeIn = $.fn.fadeIn;
        var noOp = $.noop || function() {};
        var msie = /MSIE/.test(navigator.userAgent);
        var ie6 = /MSIE 6.0/.test(navigator.userAgent) && !/MSIE 8.0/.test(navigator.userAgent);
        var mode = document.documentMode || 0;
        var setExpr = $.isFunction(document.createElement("div").style.setExpression);
        $.blockUI = function(opts) {
            install(window, opts);
        };
        $.unblockUI = function(opts) {
            remove(window, opts);
        };
        $.growlUI = function(title, message, timeout, onClose) {
            var $m = $('<div class="growlUI"></div>');
            if (title) $m.append("<h1>" + title + "</h1>");
            if (message) $m.append("<h2>" + message + "</h2>");
            if (timeout === undefined) timeout = 3e3;
            var callBlock = function(opts) {
                opts = opts || {};
                $.blockUI({
                    message: $m,
                    fadeIn: typeof opts.fadeIn !== "undefined" ? opts.fadeIn : 700,
                    fadeOut: typeof opts.fadeOut !== "undefined" ? opts.fadeOut : 1e3,
                    timeout: typeof opts.timeout !== "undefined" ? opts.timeout : timeout,
                    centerY: false,
                    showOverlay: false,
                    onUnblock: onClose,
                    css: $.blockUI.defaults.growlCSS
                });
            };
            callBlock();
            var nonmousedOpacity = $m.css("opacity");
            $m.mouseover(function() {
                callBlock({
                    fadeIn: 0,
                    timeout: 3e4
                });
                var displayBlock = $(".blockMsg");
                displayBlock.stop();
                displayBlock.fadeTo(300, 1);
            }).mouseout(function() {
                $(".blockMsg").fadeOut(1e3);
            });
        };
        $.fn.block = function(opts) {
            if (this[0] === window) {
                $.blockUI(opts);
                return this;
            }
            var fullOpts = $.extend({}, $.blockUI.defaults, opts || {});
            this.each(function() {
                var $el = $(this);
                if (fullOpts.ignoreIfBlocked && $el.data("blockUI.isBlocked")) return;
                $el.unblock({
                    fadeOut: 0
                });
            });
            return this.each(function() {
                if ($.css(this, "position") == "static") {
                    this.style.position = "relative";
                    $(this).data("blockUI.static", true);
                }
                this.style.zoom = 1;
                install(this, opts);
            });
        };
        $.fn.unblock = function(opts) {
            if (this[0] === window) {
                $.unblockUI(opts);
                return this;
            }
            return this.each(function() {
                remove(this, opts);
            });
        };
        $.blockUI.version = 2.7;
        $.blockUI.defaults = {
            message: "<h1>Please wait...</h1>",
            title: null,
            draggable: true,
            theme: false,
            css: {
                padding: 0,
                margin: 0,
                width: "30%",
                top: "40%",
                left: "35%",
                textAlign: "center",
                cursor: "wait"
            },
            themedCSS: {
                width: "30%",
                top: "40%",
                left: "35%"
            },
            overlayCSS: {
                backgroundColor: "#000",
                opacity: .6,
                cursor: "wait"
            },
            cursorReset: "default",
            growlCSS: {
                width: "350px",
                top: "10px",
                left: "",
                right: "10px",
                border: "none",
                padding: "5px",
                opacity: .6,
                cursor: "default",
                color: "#fff",
                backgroundColor: "#000",
                "-webkit-border-radius": "10px",
                "-moz-border-radius": "10px",
                "border-radius": "10px"
            },
            iframeSrc: /^https/i.test(window.location.href || "") ? "javascript:false" : "about:blank",
            forceIframe: false,
            baseZ: 1e3,
            centerX: true,
            centerY: true,
            allowBodyStretch: true,
            bindEvents: true,
            constrainTabKey: true,
            fadeIn: 200,
            fadeOut: 400,
            timeout: 0,
            showOverlay: true,
            focusInput: true,
            focusableElements: ":input:enabled:visible",
            onBlock: null,
            onUnblock: null,
            onOverlayClick: null,
            quirksmodeOffsetHack: 4,
            blockMsgClass: "blockMsg",
            ignoreIfBlocked: false
        };
        var pageBlock = null;
        var pageBlockEls = [];
        function install(el, opts) {
            var css, themedCSS;
            var full = el == window;
            var msg = opts && opts.message !== undefined ? opts.message : undefined;
            opts = $.extend({}, $.blockUI.defaults, opts || {});
            if (opts.ignoreIfBlocked && $(el).data("blockUI.isBlocked")) return;
            opts.overlayCSS = $.extend({}, $.blockUI.defaults.overlayCSS, opts.overlayCSS || {});
            css = $.extend({}, $.blockUI.defaults.css, opts.css || {});
            if (opts.onOverlayClick) opts.overlayCSS.cursor = "pointer";
            themedCSS = $.extend({}, $.blockUI.defaults.themedCSS, opts.themedCSS || {});
            msg = msg === undefined ? opts.message : msg;
            if (full && pageBlock) remove(window, {
                fadeOut: 0
            });
            if (msg && typeof msg != "string" && (msg.parentNode || msg.jquery)) {
                var node = msg.jquery ? msg[0] : msg;
                var data = {};
                $(el).data("blockUI.history", data);
                data.el = node;
                data.parent = node.parentNode;
                data.display = node.style.display;
                data.position = node.style.position;
                if (data.parent) data.parent.removeChild(node);
            }
            $(el).data("blockUI.onUnblock", opts.onUnblock);
            var z = opts.baseZ;
            var lyr1, lyr2, lyr3, s;
            if (msie || opts.forceIframe) lyr1 = $('<iframe class="blockUI" style="z-index:' + z++ + ';display:none;border:none;margin:0;padding:0;position:absolute;width:100%;height:100%;top:0;left:0" src="' + opts.iframeSrc + '"></iframe>'); else lyr1 = $('<div class="blockUI" style="display:none"></div>');
            if (opts.theme) lyr2 = $('<div class="blockUI blockOverlay ui-widget-overlay" style="z-index:' + z++ + ';display:none"></div>'); else lyr2 = $('<div class="blockUI blockOverlay" style="z-index:' + z++ + ';display:none;border:none;margin:0;padding:0;width:100%;height:100%;top:0;left:0"></div>');
            if (opts.theme && full) {
                s = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage ui-dialog ui-widget ui-corner-all" style="z-index:' + (z + 10) + ';display:none;position:fixed">';
                if (opts.title) {
                    s += '<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">' + (opts.title || "&nbsp;") + "</div>";
                }
                s += '<div class="ui-widget-content ui-dialog-content"></div>';
                s += "</div>";
            } else if (opts.theme) {
                s = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement ui-dialog ui-widget ui-corner-all" style="z-index:' + (z + 10) + ';display:none;position:absolute">';
                if (opts.title) {
                    s += '<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">' + (opts.title || "&nbsp;") + "</div>";
                }
                s += '<div class="ui-widget-content ui-dialog-content"></div>';
                s += "</div>";
            } else if (full) {
                s = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage" style="z-index:' + (z + 10) + ';display:none;position:fixed"></div>';
            } else {
                s = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement" style="z-index:' + (z + 10) + ';display:none;position:absolute"></div>';
            }
            lyr3 = $(s);
            if (msg) {
                if (opts.theme) {
                    lyr3.css(themedCSS);
                    lyr3.addClass("ui-widget-content");
                } else lyr3.css(css);
            }
            if (!opts.theme) lyr2.css(opts.overlayCSS);
            lyr2.css("position", full ? "fixed" : "absolute");
            if (msie || opts.forceIframe) lyr1.css("opacity", 0);
            var layers = [ lyr1, lyr2, lyr3 ], $par = full ? $("body") : $(el);
            $.each(layers, function() {
                this.appendTo($par);
            });
            if (opts.theme && opts.draggable && $.fn.draggable) {
                lyr3.draggable({
                    handle: ".ui-dialog-titlebar",
                    cancel: "li"
                });
            }
            var expr = setExpr && (!$.support.boxModel || $("object,embed", full ? null : el).length > 0);
            if (ie6 || expr) {
                if (full && opts.allowBodyStretch && $.support.boxModel) $("html,body").css("height", "100%");
                if ((ie6 || !$.support.boxModel) && !full) {
                    var t = sz(el, "borderTopWidth"), l = sz(el, "borderLeftWidth");
                    var fixT = t ? "(0 - " + t + ")" : 0;
                    var fixL = l ? "(0 - " + l + ")" : 0;
                }
                $.each(layers, function(i, o) {
                    var s = o[0].style;
                    s.position = "absolute";
                    if (i < 2) {
                        if (full) s.setExpression("height", "Math.max(document.body.scrollHeight, document.body.offsetHeight) - (jQuery.support.boxModel?0:" + opts.quirksmodeOffsetHack + ') + "px"'); else s.setExpression("height", 'this.parentNode.offsetHeight + "px"');
                        if (full) s.setExpression("width", 'jQuery.support.boxModel && document.documentElement.clientWidth || document.body.clientWidth + "px"'); else s.setExpression("width", 'this.parentNode.offsetWidth + "px"');
                        if (fixL) s.setExpression("left", fixL);
                        if (fixT) s.setExpression("top", fixT);
                    } else if (opts.centerY) {
                        if (full) s.setExpression("top", '(document.documentElement.clientHeight || document.body.clientHeight) / 2 - (this.offsetHeight / 2) + (blah = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + "px"');
                        s.marginTop = 0;
                    } else if (!opts.centerY && full) {
                        var top = opts.css && opts.css.top ? parseInt(opts.css.top, 10) : 0;
                        var expression = "((document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + " + top + ') + "px"';
                        s.setExpression("top", expression);
                    }
                });
            }
            if (msg) {
                if (opts.theme) lyr3.find(".ui-widget-content").append(msg); else lyr3.append(msg);
                if (msg.jquery || msg.nodeType) $(msg).show();
            }
            if ((msie || opts.forceIframe) && opts.showOverlay) lyr1.show();
            if (opts.fadeIn) {
                var cb = opts.onBlock ? opts.onBlock : noOp;
                var cb1 = opts.showOverlay && !msg ? cb : noOp;
                var cb2 = msg ? cb : noOp;
                if (opts.showOverlay) lyr2._fadeIn(opts.fadeIn, cb1);
                if (msg) lyr3._fadeIn(opts.fadeIn, cb2);
            } else {
                if (opts.showOverlay) lyr2.show();
                if (msg) lyr3.show();
                if (opts.onBlock) opts.onBlock.bind(lyr3)();
            }
            bind(1, el, opts);
            if (full) {
                pageBlock = lyr3[0];
                pageBlockEls = $(opts.focusableElements, pageBlock);
                if (opts.focusInput) setTimeout(focus, 20);
            } else center(lyr3[0], opts.centerX, opts.centerY);
            if (opts.timeout) {
                var to = setTimeout(function() {
                    if (full) $.unblockUI(opts); else $(el).unblock(opts);
                }, opts.timeout);
                $(el).data("blockUI.timeout", to);
            }
        }
        function remove(el, opts) {
            var count;
            var full = el == window;
            var $el = $(el);
            var data = $el.data("blockUI.history");
            var to = $el.data("blockUI.timeout");
            if (to) {
                clearTimeout(to);
                $el.removeData("blockUI.timeout");
            }
            opts = $.extend({}, $.blockUI.defaults, opts || {});
            bind(0, el, opts);
            if (opts.onUnblock === null) {
                opts.onUnblock = $el.data("blockUI.onUnblock");
                $el.removeData("blockUI.onUnblock");
            }
            var els;
            if (full) els = $("body").children().filter(".blockUI").add("body > .blockUI"); else els = $el.find(">.blockUI");
            if (opts.cursorReset) {
                if (els.length > 1) els[1].style.cursor = opts.cursorReset;
                if (els.length > 2) els[2].style.cursor = opts.cursorReset;
            }
            if (full) pageBlock = pageBlockEls = null;
            if (opts.fadeOut) {
                count = els.length;
                els.stop().fadeOut(opts.fadeOut, function() {
                    if (--count === 0) reset(els, data, opts, el);
                });
            } else reset(els, data, opts, el);
        }
        function reset(els, data, opts, el) {
            var $el = $(el);
            if ($el.data("blockUI.isBlocked")) return;
            els.each(function(i, o) {
                if (this.parentNode) this.parentNode.removeChild(this);
            });
            if (data && data.el) {
                data.el.style.display = data.display;
                data.el.style.position = data.position;
                data.el.style.cursor = "default";
                if (data.parent) data.parent.appendChild(data.el);
                $el.removeData("blockUI.history");
            }
            if ($el.data("blockUI.static")) {
                $el.css("position", "static");
            }
            if (typeof opts.onUnblock == "function") opts.onUnblock(el, opts);
            var body = $(document.body), w = body.width(), cssW = body[0].style.width;
            body.width(w - 1).width(w);
            body[0].style.width = cssW;
        }
        function bind(b, el, opts) {
            var full = el == window, $el = $(el);
            if (!b && (full && !pageBlock || !full && !$el.data("blockUI.isBlocked"))) return;
            $el.data("blockUI.isBlocked", b);
            if (!full || !opts.bindEvents || b && !opts.showOverlay) return;
            var events = "mousedown mouseup keydown keypress keyup touchstart touchend touchmove";
            if (b) $(document).bind(events, opts, handler); else $(document).unbind(events, handler);
        }
        function handler(e) {
            if (e.type === "keydown" && e.keyCode && e.keyCode == 9) {
                if (pageBlock && e.data.constrainTabKey) {
                    var els = pageBlockEls;
                    var fwd = !e.shiftKey && e.target === els[els.length - 1];
                    var back = e.shiftKey && e.target === els[0];
                    if (fwd || back) {
                        setTimeout(function() {
                            focus(back);
                        }, 10);
                        return false;
                    }
                }
            }
            var opts = e.data;
            var target = $(e.target);
            if (target.hasClass("blockOverlay") && opts.onOverlayClick) opts.onOverlayClick(e);
            if (target.parents("div." + opts.blockMsgClass).length > 0) return true;
            return target.parents().children().filter("div.blockUI").length === 0;
        }
        function focus(back) {
            if (!pageBlockEls) return;
            var e = pageBlockEls[back === true ? pageBlockEls.length - 1 : 0];
            if (e) e.focus();
        }
        function center(el, x, y) {
            var p = el.parentNode, s = el.style;
            var l = (p.offsetWidth - el.offsetWidth) / 2 - sz(p, "borderLeftWidth");
            var t = (p.offsetHeight - el.offsetHeight) / 2 - sz(p, "borderTopWidth");
            if (x) s.left = l > 0 ? l + "px" : "0";
            if (y) s.top = t > 0 ? t + "px" : "0";
        }
        function sz(el, p) {
            return parseInt($.css(el, p), 10) || 0;
        }
    }
    if (typeof define === "function" && define.amd && define.amd.jQuery) {
        define([ "jquery" ], setup);
    } else {
        setup(jQuery);
    }
})();

(function($) {
    $.fn.hovercard = function(options) {
        var defaults = {
            openOnLeft: false,
            openOnTop: false,
            cardImgSrc: "",
            detailsHTML: "",
            loadingHTML: "Loading...",
            errorHTML: "Sorry, no data found.",
            pointsText: "",
            postsText: "",
            background: "#ffffff",
            delay: 0,
            autoAdjust: true,
            onHoverIn: function() {},
            onHoverOut: function() {}
        };
        options = $.extend(defaults, options);
        return this.each(function() {
            var obj = $(this).eq(0);
            obj.wrap('<div class="hc-preview" />');
            obj.addClass("hc-name");
            var hcImg = "";
            if (options.cardImgSrc.length > 0) {
                hcImg = '<img class="hc-pic" src="' + options.cardImgSrc + '" />';
            }
            var hcDetails = '<div class="hc-details" >' + hcImg + options.detailsHTML + "</div>";
            obj.after(hcDetails);
            obj.siblings(".hc-details").eq(0).css({
                background: options.background
            });
            obj.closest(".hc-preview").hoverIntent(function() {
                var $this = $(this);
                adjustToViewPort($this);
                obj.css("zIndex", "200");
                var curHCDetails = $this.find(".hc-details").eq(0);
                curHCDetails.stop(true, true).delay(options.delay).fadeIn();
                if (typeof options.onHoverIn == "function") {
                    var dataUrl;
                    if (curHCDetails.find(".s-card").length <= 0) {
                        dataUrl = options.customDataUrl;
                        if (typeof obj.attr("data-hovercard") == "undefined") {} else if (obj.attr("data-hovercard").length > 0) {
                            dataUrl = obj.attr("data-hovercard");
                        }
                        LoadSocialProfile("yaf", "", dataUrl, curHCDetails, options.customCardJSON);
                    }
                    $("body").on("keydown", function(event) {
                        if (event.keyCode === 27) {
                            closeHoverCard($this);
                        }
                    });
                    var closeButton = curHCDetails.find(".s-close").eq(0);
                    closeButton.click(function() {
                        closeHoverCard($this);
                    });
                    options.onHoverIn.call(this);
                }
            }, function() {
                closeHoverCard($(this));
            });
            function closeHoverCard(card) {
                card.find(".hc-details").eq(0).stop(true, true).fadeOut(300, function() {
                    obj.css("zIndex", "50");
                    if (typeof options.onHoverOut == "function") {
                        options.onHoverOut.call(this);
                    }
                });
                $("body").off("keydown");
            }
            function adjustToViewPort(hcPreview) {
                var hcDetails = hcPreview.find(".hc-details").eq(0);
                var hcPreviewRect = hcPreview[0].getBoundingClientRect();
                var hcdRight = hcPreviewRect.left + 35 + hcDetails.width();
                var hcdBottom = hcPreviewRect.top + 35 + hcDetails.height();
                if (options.openOnLeft || options.autoAdjust && hcdRight > window.innerWidth) {
                    hcDetails.addClass("hc-details-open-left");
                } else {
                    hcDetails.removeClass("hc-details-open-left");
                }
                if (options.openOnTop || options.autoAdjust && hcdBottom > window.innerHeight) {
                    hcDetails.addClass("hc-details-open-top");
                } else {
                    hcDetails.removeClass("hc-details-open-top");
                }
            }
            function LoadSocialProfile(type, href, username, curHCDetails, customCardJSON) {
                var cardHTML, dataType, urlToRequest, customCallback, loadingHTML, errorHTML;
                switch (type) {
                  case "yaf":
                    {
                        dataType = "json", urlToRequest = username, cardHTML = function(profileData) {
                            var online = profileData.Online ? "green" : "red";
                            var shtml = '<div class="s-card s-card-pad">' + '<div class="card rounded-0" style="width: 330px;">' + '<div class="card-header position-relative">' + '<h6 class="card-title text-center">' + (profileData.RealName ? profileData.RealName : profileData.Name) + "</h6>" + (profileData.Avatar ? '<img src="' + profileData.Avatar + '" class="rounded mx-auto d-block" style="width:75px" alt="" />' : "") + (profileData.Avatar ? '<div class="position-absolute" style="top:0;right:0;border-width: 0 25px 25px 0; border-style: solid; border-color: transparent ' + online + ';" ></div>' : "") + "</div>" + '<div class="card-body p-2">' + '<ul class="list-unstyled mt-1 mb-3">' + (profileData.Location ? '<li class="px-2 py-1"><i class="fas fa-home me-1"></i>' + profileData.Location + "</li>" : "") + (profileData.Rank ? '<li class="px-2 py-1"><i class="fas fa-graduation-cap me-1"></i>' + profileData.Rank + "</li>" : "") + (profileData.Interests ? '<li class="px-2 py-1"><i class="fas fa-running me-1"></i>' + profileData.Interests + "</li>" : "") + (profileData.Joined ? '<li class="px-2 py-1"><i class="fas fa-user-check me-1"></i>' + profileData.Joined + "</li>" : "") + (profileData.HomePage ? '<li class="px-2 py-1"><i class="fas fa-globe me-1"></i><a href="' + profileData.HomePage + '" target="_blank">' + profileData.HomePage + "</a></li>" : "") + '<li class="px-2 py-1"><i class="far fa-comment me-1"></i>' + profileData.Posts + "</li>" + "</ul>" + "</div>" + "</div>" + "</div>";
                            return shtml;
                        };
                        loadingHTML = options.loadingHTML;
                        errorHTML = options.errorHTML;
                        customCallback = function() {};
                        curHCDetails.append('<span class="s-action s-close"><a href="javascript:void(0)"><i class="fas fa-times fa-fw"></i></a></span>');
                    }
                    break;

                  default:
                    break;
                }
                if ($.isEmptyObject(customCardJSON)) {
                    $.ajax({
                        url: urlToRequest,
                        type: "GET",
                        dataType: dataType,
                        timeout: 6e3,
                        cache: true,
                        beforeSend: function() {
                            curHCDetails.find(".s-message").remove();
                            curHCDetails.append('<p class="s-message">' + loadingHTML + "</p>");
                        },
                        success: function(data) {
                            if (data.length <= 0) {
                                curHCDetails.find(".s-message").html(errorHTML);
                            } else {
                                curHCDetails.find(".s-message").replaceWith(cardHTML(data));
                                $(".hc-details").hide();
                                adjustToViewPort(curHCDetails.closest(".hc-preview"));
                                curHCDetails.stop(true, true).delay(options.delay).fadeIn();
                                customCallback(data);
                            }
                        },
                        error: function(jqXHR, textStatus, errorThrown) {
                            curHCDetails.find(".s-message").html(errorHTML + errorThrown);
                        }
                    });
                } else {
                    curHCDetails.prepend(cardHTML(customCardJSON));
                }
            }
        });
    };
})(jQuery);

(function($) {
    $.fn.hoverIntent = function(handlerIn, handlerOut, selector) {
        var cfg = {
            interval: 100,
            sensitivity: 7,
            timeout: 0
        };
        if (typeof handlerIn === "object") {
            cfg = $.extend(cfg, handlerIn);
        } else if ($.isFunction(handlerOut)) {
            cfg = $.extend(cfg, {
                over: handlerIn,
                out: handlerOut,
                selector: selector
            });
        } else {
            cfg = $.extend(cfg, {
                over: handlerIn,
                out: handlerIn,
                selector: handlerOut
            });
        }
        var cX, cY, pX, pY;
        var track = function(ev) {
            cX = ev.pageX;
            cY = ev.pageY;
        };
        var compare = function(ev, ob) {
            ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            if (Math.abs(pX - cX) + Math.abs(pY - cY) < cfg.sensitivity) {
                $(ob).off("mousemove.hoverIntent", track);
                ob.hoverIntent_s = 1;
                return cfg.over.apply(ob, [ ev ]);
            } else {
                pX = cX;
                pY = cY;
                ob.hoverIntent_t = setTimeout(function() {
                    compare(ev, ob);
                }, cfg.interval);
            }
        };
        var delay = function(ev, ob) {
            ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            ob.hoverIntent_s = 0;
            return cfg.out.apply(ob, [ ev ]);
        };
        var handleHover = function(e) {
            var ev = jQuery.extend({}, e);
            var ob = this;
            if (ob.hoverIntent_t) {
                ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            }
            if (e.type == "mouseenter") {
                pX = ev.pageX;
                pY = ev.pageY;
                $(ob).on("mousemove.hoverIntent", track);
                if (ob.hoverIntent_s != 1) {
                    ob.hoverIntent_t = setTimeout(function() {
                        compare(ev, ob);
                    }, cfg.interval);
                }
            } else {
                $(ob).off("mousemove.hoverIntent", track);
                if (ob.hoverIntent_s == 1) {
                    ob.hoverIntent_t = setTimeout(function() {
                        delay(ev, ob);
                    }, cfg.timeout);
                }
            }
        };
        return this.on({
            "mouseenter.hoverIntent": handleHover,
            "mouseleave.hoverIntent": handleHover
        }, cfg.selector);
    };
})(jQuery);

var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};

var Prism = function(_self) {
    var lang = /\blang(?:uage)?-([\w-]+)\b/i;
    var uniqueId = 0;
    var _ = {
        manual: _self.Prism && _self.Prism.manual,
        disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
        util: {
            encode: function encode(tokens) {
                if (tokens instanceof Token) {
                    return new Token(tokens.type, encode(tokens.content), tokens.alias);
                } else if (Array.isArray(tokens)) {
                    return tokens.map(encode);
                } else {
                    return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
                }
            },
            type: function(o) {
                return Object.prototype.toString.call(o).slice(8, -1);
            },
            objId: function(obj) {
                if (!obj["__id"]) {
                    Object.defineProperty(obj, "__id", {
                        value: ++uniqueId
                    });
                }
                return obj["__id"];
            },
            clone: function deepClone(o, visited) {
                visited = visited || {};
                var clone, id;
                switch (_.util.type(o)) {
                  case "Object":
                    id = _.util.objId(o);
                    if (visited[id]) {
                        return visited[id];
                    }
                    clone = {};
                    visited[id] = clone;
                    for (var key in o) {
                        if (o.hasOwnProperty(key)) {
                            clone[key] = deepClone(o[key], visited);
                        }
                    }
                    return clone;

                  case "Array":
                    id = _.util.objId(o);
                    if (visited[id]) {
                        return visited[id];
                    }
                    clone = [];
                    visited[id] = clone;
                    o.forEach(function(v, i) {
                        clone[i] = deepClone(v, visited);
                    });
                    return clone;

                  default:
                    return o;
                }
            },
            getLanguage: function(element) {
                while (element && !lang.test(element.className)) {
                    element = element.parentElement;
                }
                if (element) {
                    return (element.className.match(lang) || [ , "none" ])[1].toLowerCase();
                }
                return "none";
            },
            currentScript: function() {
                if (typeof document === "undefined") {
                    return null;
                }
                if ("currentScript" in document && 1 < 2) {
                    return document.currentScript;
                }
                try {
                    throw new Error();
                } catch (err) {
                    var src = (/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(err.stack) || [])[1];
                    if (src) {
                        var scripts = document.getElementsByTagName("script");
                        for (var i in scripts) {
                            if (scripts[i].src == src) {
                                return scripts[i];
                            }
                        }
                    }
                    return null;
                }
            },
            isActive: function(element, className, defaultActivation) {
                var no = "no-" + className;
                while (element) {
                    var classList = element.classList;
                    if (classList.contains(className)) {
                        return true;
                    }
                    if (classList.contains(no)) {
                        return false;
                    }
                    element = element.parentElement;
                }
                return !!defaultActivation;
            }
        },
        languages: {
            extend: function(id, redef) {
                var lang = _.util.clone(_.languages[id]);
                for (var key in redef) {
                    lang[key] = redef[key];
                }
                return lang;
            },
            insertBefore: function(inside, before, insert, root) {
                root = root || _.languages;
                var grammar = root[inside];
                var ret = {};
                for (var token in grammar) {
                    if (grammar.hasOwnProperty(token)) {
                        if (token == before) {
                            for (var newToken in insert) {
                                if (insert.hasOwnProperty(newToken)) {
                                    ret[newToken] = insert[newToken];
                                }
                            }
                        }
                        if (!insert.hasOwnProperty(token)) {
                            ret[token] = grammar[token];
                        }
                    }
                }
                var old = root[inside];
                root[inside] = ret;
                _.languages.DFS(_.languages, function(key, value) {
                    if (value === old && key != inside) {
                        this[key] = ret;
                    }
                });
                return ret;
            },
            DFS: function DFS(o, callback, type, visited) {
                visited = visited || {};
                var objId = _.util.objId;
                for (var i in o) {
                    if (o.hasOwnProperty(i)) {
                        callback.call(o, i, o[i], type || i);
                        var property = o[i], propertyType = _.util.type(property);
                        if (propertyType === "Object" && !visited[objId(property)]) {
                            visited[objId(property)] = true;
                            DFS(property, callback, null, visited);
                        } else if (propertyType === "Array" && !visited[objId(property)]) {
                            visited[objId(property)] = true;
                            DFS(property, callback, i, visited);
                        }
                    }
                }
            }
        },
        plugins: {},
        highlightAll: function(async, callback) {
            _.highlightAllUnder(document, async, callback);
        },
        highlightAllUnder: function(container, async, callback) {
            var env = {
                callback: callback,
                container: container,
                selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
            };
            _.hooks.run("before-highlightall", env);
            env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
            _.hooks.run("before-all-elements-highlight", env);
            for (var i = 0, element; element = env.elements[i++]; ) {
                _.highlightElement(element, async === true, env.callback);
            }
        },
        highlightElement: function(element, async, callback) {
            var language = _.util.getLanguage(element);
            var grammar = _.languages[language];
            element.className = element.className.replace(lang, "").replace(/\s+/g, " ") + " language-" + language;
            var parent = element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre") {
                parent.className = parent.className.replace(lang, "").replace(/\s+/g, " ") + " language-" + language;
            }
            var code = element.textContent;
            var env = {
                element: element,
                language: language,
                grammar: grammar,
                code: code
            };
            function insertHighlightedCode(highlightedCode) {
                env.highlightedCode = highlightedCode;
                _.hooks.run("before-insert", env);
                env.element.innerHTML = env.highlightedCode;
                _.hooks.run("after-highlight", env);
                _.hooks.run("complete", env);
                callback && callback.call(env.element);
            }
            _.hooks.run("before-sanity-check", env);
            if (!env.code) {
                _.hooks.run("complete", env);
                callback && callback.call(env.element);
                return;
            }
            _.hooks.run("before-highlight", env);
            if (!env.grammar) {
                insertHighlightedCode(_.util.encode(env.code));
                return;
            }
            if (async && _self.Worker) {
                var worker = new Worker(_.filename);
                worker.onmessage = function(evt) {
                    insertHighlightedCode(evt.data);
                };
                worker.postMessage(JSON.stringify({
                    language: env.language,
                    code: env.code,
                    immediateClose: true
                }));
            } else {
                insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
            }
        },
        highlight: function(text, grammar, language) {
            var env = {
                code: text,
                grammar: grammar,
                language: language
            };
            _.hooks.run("before-tokenize", env);
            env.tokens = _.tokenize(env.code, env.grammar);
            _.hooks.run("after-tokenize", env);
            return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        tokenize: function(text, grammar) {
            var rest = grammar.rest;
            if (rest) {
                for (var token in rest) {
                    grammar[token] = rest[token];
                }
                delete grammar.rest;
            }
            var tokenList = new LinkedList();
            addAfter(tokenList, tokenList.head, text);
            matchGrammar(text, tokenList, grammar, tokenList.head, 0);
            return toArray(tokenList);
        },
        hooks: {
            all: {},
            add: function(name, callback) {
                var hooks = _.hooks.all;
                hooks[name] = hooks[name] || [];
                hooks[name].push(callback);
            },
            run: function(name, env) {
                var callbacks = _.hooks.all[name];
                if (!callbacks || !callbacks.length) {
                    return;
                }
                for (var i = 0, callback; callback = callbacks[i++]; ) {
                    callback(env);
                }
            }
        },
        Token: Token
    };
    _self.Prism = _;
    function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
    }
    Token.stringify = function stringify(o, language) {
        if (typeof o == "string") {
            return o;
        }
        if (Array.isArray(o)) {
            var s = "";
            o.forEach(function(e) {
                s += stringify(e, language);
            });
            return s;
        }
        var env = {
            type: o.type,
            content: stringify(o.content, language),
            tag: "span",
            classes: [ "token", o.type ],
            attributes: {},
            language: language
        };
        var aliases = o.alias;
        if (aliases) {
            if (Array.isArray(aliases)) {
                Array.prototype.push.apply(env.classes, aliases);
            } else {
                env.classes.push(aliases);
            }
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for (var name in env.attributes) {
            attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
    };
    function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
            var lookbehindLength = match[1].length;
            match.index += lookbehindLength;
            match[0] = match[0].slice(lookbehindLength);
        }
        return match;
    }
    function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
            if (!grammar.hasOwnProperty(token) || !grammar[token]) {
                continue;
            }
            var patterns = grammar[token];
            patterns = Array.isArray(patterns) ? patterns : [ patterns ];
            for (var j = 0; j < patterns.length; ++j) {
                if (rematch && rematch.cause == token + "," + j) {
                    return;
                }
                var patternObj = patterns[j], inside = patternObj.inside, lookbehind = !!patternObj.lookbehind, greedy = !!patternObj.greedy, alias = patternObj.alias;
                if (greedy && !patternObj.pattern.global) {
                    var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
                    patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
                }
                var pattern = patternObj.pattern || patternObj;
                for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, 
                currentNode = currentNode.next) {
                    if (rematch && pos >= rematch.reach) {
                        break;
                    }
                    var str = currentNode.value;
                    if (tokenList.length > text.length) {
                        return;
                    }
                    if (str instanceof Token) {
                        continue;
                    }
                    var removeCount = 1;
                    var match;
                    if (greedy) {
                        match = matchPattern(pattern, pos, text, lookbehind);
                        if (!match) {
                            break;
                        }
                        var from = match.index;
                        var to = match.index + match[0].length;
                        var p = pos;
                        p += currentNode.value.length;
                        while (from >= p) {
                            currentNode = currentNode.next;
                            p += currentNode.value.length;
                        }
                        p -= currentNode.value.length;
                        pos = p;
                        if (currentNode.value instanceof Token) {
                            continue;
                        }
                        for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                            removeCount++;
                            p += k.value.length;
                        }
                        removeCount--;
                        str = text.slice(pos, p);
                        match.index -= pos;
                    } else {
                        match = matchPattern(pattern, 0, str, lookbehind);
                        if (!match) {
                            continue;
                        }
                    }
                    var from = match.index, matchStr = match[0], before = str.slice(0, from), after = str.slice(from + matchStr.length);
                    var reach = pos + str.length;
                    if (rematch && reach > rematch.reach) {
                        rematch.reach = reach;
                    }
                    var removeFrom = currentNode.prev;
                    if (before) {
                        removeFrom = addAfter(tokenList, removeFrom, before);
                        pos += before.length;
                    }
                    removeRange(tokenList, removeFrom, removeCount);
                    var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
                    currentNode = addAfter(tokenList, removeFrom, wrapped);
                    if (after) {
                        addAfter(tokenList, currentNode, after);
                    }
                    if (removeCount > 1) {
                        matchGrammar(text, tokenList, grammar, currentNode.prev, pos, {
                            cause: token + "," + j,
                            reach: reach
                        });
                    }
                }
            }
        }
    }
    function LinkedList() {
        var head = {
            value: null,
            prev: null,
            next: null
        };
        var tail = {
            value: null,
            prev: head,
            next: null
        };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
    }
    function addAfter(list, node, value) {
        var next = node.next;
        var newNode = {
            value: value,
            prev: node,
            next: next
        };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
    }
    function removeRange(list, node, count) {
        var next = node.next;
        for (var i = 0; i < count && next !== list.tail; i++) {
            next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
    }
    function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
            array.push(node.value);
            node = node.next;
        }
        return array;
    }
    if (!_self.document) {
        if (!_self.addEventListener) {
            return _;
        }
        if (!_.disableWorkerMessageHandler) {
            _self.addEventListener("message", function(evt) {
                var message = JSON.parse(evt.data), lang = message.language, code = message.code, immediateClose = message.immediateClose;
                _self.postMessage(_.highlight(code, _.languages[lang], lang));
                if (immediateClose) {
                    _self.close();
                }
            }, false);
        }
        return _;
    }
    var script = _.util.currentScript();
    if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) {
            _.manual = true;
        }
    }
    function highlightAutomaticallyCallback() {
        if (!_.manual) {
            _.highlightAll();
        }
    }
    if (!_.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
            document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
            if (window.requestAnimationFrame) {
                window.requestAnimationFrame(highlightAutomaticallyCallback);
            } else {
                window.setTimeout(highlightAutomaticallyCallback, 16);
            }
        }
    }
    return _;
}(_self);

if (typeof module !== "undefined" && module.exports) {
    module.exports = Prism;
}

if (typeof global !== "undefined") {
    global.Prism = Prism;
}

Prism.languages.markup = {
    comment: /<!--[\s\S]*?-->/,
    prolog: /<\?[\s\S]+?\?>/,
    doctype: {
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
            "internal-subset": {
                pattern: /(\[)[\s\S]+(?=\]>$)/,
                lookbehind: true,
                greedy: true,
                inside: null
            },
            string: {
                pattern: /"[^"]*"|'[^']*'/,
                greedy: true
            },
            punctuation: /^<!|>$|[[\]]/,
            "doctype-tag": /^DOCTYPE/,
            name: /[^\s<>'"]+/
        }
    },
    cdata: /<!\[CDATA\[[\s\S]*?]]>/i,
    tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
            tag: {
                pattern: /^<\/?[^\s>\/]+/,
                inside: {
                    punctuation: /^<\/?/,
                    namespace: /^[^\s>\/:]+:/
                }
            },
            "attr-value": {
                pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
                inside: {
                    punctuation: [ {
                        pattern: /^=/,
                        alias: "attr-equals"
                    }, /"|'/ ]
                }
            },
            punctuation: /\/?>/,
            "attr-name": {
                pattern: /[^\s>\/]+/,
                inside: {
                    namespace: /^[^\s>\/:]+:/
                }
            }
        }
    },
    entity: [ {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
    }, /&#x?[\da-f]{1,8};/i ]
};

Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];

Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;

Prism.hooks.add("wrap", function(env) {
    if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
    }
});

Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: true,
            inside: Prism.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
            "included-cdata": {
                pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                inside: includedCdataInside
            }
        };
        inside["language-" + lang] = {
            pattern: /[\s\S]+/,
            inside: Prism.languages[lang]
        };
        var def = {};
        def[tagName] = {
            pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
                return tagName;
            }), "i"),
            lookbehind: true,
            greedy: true,
            inside: inside
        };
        Prism.languages.insertBefore("markup", "cdata", def);
    }
});

Prism.languages.html = Prism.languages.markup;

Prism.languages.mathml = Prism.languages.markup;

Prism.languages.svg = Prism.languages.markup;

Prism.languages.xml = Prism.languages.extend("markup", {});

Prism.languages.ssml = Prism.languages.xml;

Prism.languages.atom = Prism.languages.xml;

Prism.languages.rss = Prism.languages.xml;

(function(Prism) {
    var string = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
    Prism.languages.css = {
        comment: /\/\*[\s\S]*?\*\//,
        atrule: {
            pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
            inside: {
                rule: /^@[\w-]+/,
                "selector-function-argument": {
                    pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                    lookbehind: true,
                    alias: "selector"
                },
                keyword: {
                    pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                    lookbehind: true
                }
            }
        },
        url: {
            pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
            greedy: true,
            inside: {
                function: /^url/i,
                punctuation: /^\(|\)$/,
                string: {
                    pattern: RegExp("^" + string.source + "$"),
                    alias: "url"
                }
            }
        },
        selector: RegExp("[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|" + string.source + ")*(?=\\s*\\{)"),
        string: {
            pattern: string,
            greedy: true
        },
        property: /(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        important: /!important\b/i,
        function: /[-a-z0-9]+(?=\()/i,
        punctuation: /[(){};:,]/
    };
    Prism.languages.css["atrule"].inside.rest = Prism.languages.css;
    var markup = Prism.languages.markup;
    if (markup) {
        markup.tag.addInlined("style", "css");
        Prism.languages.insertBefore("inside", "attr-value", {
            "style-attr": {
                pattern: /(^|["'\s])style\s*=\s*(?:"[^"]*"|'[^']*')/i,
                lookbehind: true,
                inside: {
                    "attr-value": {
                        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
                        inside: {
                            style: {
                                pattern: /(["'])[\s\S]+(?=["']$)/,
                                lookbehind: true,
                                alias: "language-css",
                                inside: Prism.languages.css
                            },
                            punctuation: [ {
                                pattern: /^=/,
                                alias: "attr-equals"
                            }, /"|'/ ]
                        }
                    },
                    "attr-name": /^style/i
                }
            }
        }, markup.tag);
    }
})(Prism);

Prism.languages.clike = {
    comment: [ {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true,
        greedy: true
    }, {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
    } ],
    string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
    },
    "class-name": {
        pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
            punctuation: /[.\\]/
        }
    },
    keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
    boolean: /\b(?:true|false)\b/,
    function: /\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
};

Prism.languages.javascript = Prism.languages.extend("clike", {
    "class-name": [ Prism.languages.clike["class-name"], {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype|constructor))/,
        lookbehind: true
    } ],
    keyword: [ {
        pattern: /((?:^|})\s*)(?:catch|finally)\b/,
        lookbehind: true
    }, {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|(?:get|set)(?=\s*[\[$\w\xA0-\uFFFF])|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: true
    } ],
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});

Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;

Prism.languages.insertBefore("javascript", "keyword", {
    regex: {
        pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
        lookbehind: true,
        greedy: true,
        inside: {
            "regex-source": {
                pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
                lookbehind: true,
                alias: "language-regex",
                inside: Prism.languages.regex
            },
            "regex-flags": /[a-z]+$/,
            "regex-delimiter": /^\/|\/$/
        }
    },
    "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
    },
    parameter: [ {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: true,
        inside: Prism.languages.javascript
    }, {
        pattern: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        inside: Prism.languages.javascript
    }, {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: true,
        inside: Prism.languages.javascript
    }, {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: true,
        inside: Prism.languages.javascript
    } ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});

Prism.languages.insertBefore("javascript", "string", {
    "template-string": {
        pattern: /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\${)[^\\`])*`/,
        greedy: true,
        inside: {
            "template-punctuation": {
                pattern: /^`|`$/,
                alias: "string"
            },
            interpolation: {
                pattern: /((?:^|[^\\])(?:\\{2})*)\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,
                lookbehind: true,
                inside: {
                    "interpolation-punctuation": {
                        pattern: /^\${|}$/,
                        alias: "punctuation"
                    },
                    rest: Prism.languages.javascript
                }
            },
            string: /[\s\S]+/
        }
    }
});

if (Prism.languages.markup) {
    Prism.languages.markup.tag.addInlined("script", "javascript");
}

Prism.languages.js = Prism.languages.javascript;

(function(Prism) {
    function replace(pattern, replacements) {
        return pattern.replace(/<<(\d+)>>/g, function(m, index) {
            return "(?:" + replacements[+index] + ")";
        });
    }
    function re(pattern, replacements, flags) {
        return RegExp(replace(pattern, replacements), flags || "");
    }
    function nested(pattern, depthLog2) {
        for (var i = 0; i < depthLog2; i++) {
            pattern = pattern.replace(/<<self>>/g, function() {
                return "(?:" + pattern + ")";
            });
        }
        return pattern.replace(/<<self>>/g, "[^\\s\\S]");
    }
    var keywordKinds = {
        type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
        typeDeclaration: "class enum interface struct",
        contextual: "add alias and ascending async await by descending from get global group into join let nameof not notnull on or orderby partial remove select set unmanaged value when where",
        other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
    };
    function keywordsToPattern(words) {
        return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
    }
    var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
    var keywords = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other));
    var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other);
    var nonContextualKeywords = keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other);
    var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
    var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
    var name = /@?\b[A-Za-z_]\w*\b/.source;
    var genericName = replace(/<<0>>(?:\s*<<1>>)?/.source, [ name, generic ]);
    var identifier = replace(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [ nonTypeKeywords, genericName ]);
    var array = /\[\s*(?:,\s*)*\]/.source;
    var typeExpressionWithoutTuple = replace(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [ identifier, array ]);
    var tupleElement = replace(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [ generic, nestedRound, array ]);
    var tuple = replace(/\(<<0>>+(?:,<<0>>+)+\)/.source, [ tupleElement ]);
    var typeExpression = replace(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [ tuple, identifier, array ]);
    var typeInside = {
        keyword: keywords,
        punctuation: /[<>()?,.:[\]]/
    };
    var character = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
    var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
    var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
    Prism.languages.csharp = Prism.languages.extend("clike", {
        string: [ {
            pattern: re(/(^|[^$\\])<<0>>/.source, [ verbatimString ]),
            lookbehind: true,
            greedy: true
        }, {
            pattern: re(/(^|[^@$\\])<<0>>/.source, [ regularString ]),
            lookbehind: true,
            greedy: true
        }, {
            pattern: RegExp(character),
            greedy: true,
            alias: "character"
        } ],
        "class-name": [ {
            pattern: re(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [ identifier ]),
            lookbehind: true,
            inside: typeInside
        }, {
            pattern: re(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [ name, typeExpression ]),
            lookbehind: true,
            inside: typeInside
        }, {
            pattern: re(/(\busing\s+)<<0>>(?=\s*=)/.source, [ name ]),
            lookbehind: true
        }, {
            pattern: re(/(\b<<0>>\s+)<<1>>/.source, [ typeDeclarationKeywords, genericName ]),
            lookbehind: true,
            inside: typeInside
        }, {
            pattern: re(/(\bcatch\s*\(\s*)<<0>>/.source, [ identifier ]),
            lookbehind: true,
            inside: typeInside
        }, {
            pattern: re(/(\bwhere\s+)<<0>>/.source, [ name ]),
            lookbehind: true
        }, {
            pattern: re(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [ typeExpressionWithoutTuple ]),
            lookbehind: true,
            inside: typeInside
        }, {
            pattern: re(/\b<<0>>(?=\s+(?!<<1>>)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [ typeExpression, nonContextualKeywords, name ]),
            inside: typeInside
        } ],
        keyword: keywords,
        number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:ul|lu|[dflmu])?\b/i,
        operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
        punctuation: /\?\.?|::|[{}[\];(),.:]/
    });
    Prism.languages.insertBefore("csharp", "number", {
        range: {
            pattern: /\.\./,
            alias: "operator"
        }
    });
    Prism.languages.insertBefore("csharp", "punctuation", {
        "named-parameter": {
            pattern: re(/([(,]\s*)<<0>>(?=\s*:)/.source, [ name ]),
            lookbehind: true,
            alias: "punctuation"
        }
    });
    Prism.languages.insertBefore("csharp", "class-name", {
        namespace: {
            pattern: re(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [ name ]),
            lookbehind: true,
            inside: {
                punctuation: /\./
            }
        },
        "type-expression": {
            pattern: re(/(\b(?:default|typeof|sizeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [ nestedRound ]),
            lookbehind: true,
            alias: "class-name",
            inside: typeInside
        },
        "return-type": {
            pattern: re(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [ typeExpression, identifier ]),
            inside: typeInside,
            alias: "class-name"
        },
        "constructor-invocation": {
            pattern: re(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [ typeExpression ]),
            lookbehind: true,
            inside: typeInside,
            alias: "class-name"
        },
        "generic-method": {
            pattern: re(/<<0>>\s*<<1>>(?=\s*\()/.source, [ name, generic ]),
            inside: {
                function: re(/^<<0>>/.source, [ name ]),
                generic: {
                    pattern: RegExp(generic),
                    alias: "class-name",
                    inside: typeInside
                }
            }
        },
        "type-list": {
            pattern: re(/\b((?:<<0>>\s+<<1>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>)(?:\s*,\s*(?:<<3>>|<<4>>))*(?=\s*(?:where|[{;]|=>|$))/.source, [ typeDeclarationKeywords, genericName, name, typeExpression, keywords.source ]),
            lookbehind: true,
            inside: {
                keyword: keywords,
                "class-name": {
                    pattern: RegExp(typeExpression),
                    greedy: true,
                    inside: typeInside
                },
                punctuation: /,/
            }
        },
        preprocessor: {
            pattern: /(^\s*)#.*/m,
            lookbehind: true,
            alias: "property",
            inside: {
                directive: {
                    pattern: /(\s*#)\b(?:define|elif|else|endif|endregion|error|if|line|pragma|region|undef|warning)\b/,
                    lookbehind: true,
                    alias: "keyword"
                }
            }
        }
    });
    var regularStringOrCharacter = regularString + "|" + character;
    var regularStringCharacterOrComment = replace(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [ regularStringOrCharacter ]);
    var roundExpression = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [ regularStringCharacterOrComment ]), 2);
    var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
    var attr = replace(/<<0>>(?:\s*\(<<1>>*\))?/.source, [ identifier, roundExpression ]);
    Prism.languages.insertBefore("csharp", "class-name", {
        attribute: {
            pattern: re(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [ attrTarget, attr ]),
            lookbehind: true,
            greedy: true,
            inside: {
                target: {
                    pattern: re(/^<<0>>(?=\s*:)/.source, [ attrTarget ]),
                    alias: "keyword"
                },
                "attribute-arguments": {
                    pattern: re(/\(<<0>>*\)/.source, [ roundExpression ]),
                    inside: Prism.languages.csharp
                },
                "class-name": {
                    pattern: RegExp(identifier),
                    inside: {
                        punctuation: /\./
                    }
                },
                punctuation: /[:,]/
            }
        }
    });
    var formatString = /:[^}\r\n]+/.source;
    var mInterpolationRound = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [ regularStringCharacterOrComment ]), 2);
    var mInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [ mInterpolationRound, formatString ]);
    var sInterpolationRound = nested(replace(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [ regularStringOrCharacter ]), 2);
    var sInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [ sInterpolationRound, formatString ]);
    function createInterpolationInside(interpolation, interpolationRound) {
        return {
            interpolation: {
                pattern: re(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [ interpolation ]),
                lookbehind: true,
                inside: {
                    "format-string": {
                        pattern: re(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [ interpolationRound, formatString ]),
                        lookbehind: true,
                        inside: {
                            punctuation: /^:/
                        }
                    },
                    punctuation: /^\{|\}$/,
                    expression: {
                        pattern: /[\s\S]+/,
                        alias: "language-csharp",
                        inside: Prism.languages.csharp
                    }
                }
            },
            string: /[\s\S]+/
        };
    }
    Prism.languages.insertBefore("csharp", "string", {
        "interpolation-string": [ {
            pattern: re(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [ mInterpolation ]),
            lookbehind: true,
            greedy: true,
            inside: createInterpolationInside(mInterpolation, mInterpolationRound)
        }, {
            pattern: re(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [ sInterpolation ]),
            lookbehind: true,
            greedy: true,
            inside: createInterpolationInside(sInterpolation, sInterpolationRound)
        } ]
    });
})(Prism);

Prism.languages.dotnet = Prism.languages.cs = Prism.languages.csharp;

Prism.languages.aspnet = Prism.languages.extend("markup", {
    "page-directive": {
        pattern: /<%\s*@.*%>/i,
        alias: "tag",
        inside: {
            "page-directive": {
                pattern: /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,
                alias: "tag"
            },
            rest: Prism.languages.markup.tag.inside
        }
    },
    directive: {
        pattern: /<%.*%>/i,
        alias: "tag",
        inside: {
            directive: {
                pattern: /<%\s*?[$=%#:]{0,2}|%>/i,
                alias: "tag"
            },
            rest: Prism.languages.csharp
        }
    }
});

Prism.languages.aspnet.tag.pattern = /<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i;

Prism.languages.insertBefore("inside", "punctuation", {
    directive: Prism.languages.aspnet["directive"]
}, Prism.languages.aspnet.tag.inside["attr-value"]);

Prism.languages.insertBefore("aspnet", "comment", {
    "asp-comment": {
        pattern: /<%--[\s\S]*?--%>/,
        alias: [ "asp", "comment" ]
    }
});

Prism.languages.insertBefore("aspnet", Prism.languages.javascript ? "script" : "tag", {
    "asp-script": {
        pattern: /(<script(?=.*runat=['"]?server['"]?)[^>]*>)[\s\S]*?(?=<\/script>)/i,
        lookbehind: true,
        alias: [ "asp", "script" ],
        inside: Prism.languages.csharp || {}
    }
});

(function(Prism) {
    var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
    var commandAfterHeredoc = {
        pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
        lookbehind: true,
        alias: "punctuation",
        inside: null
    };
    var insideString = {
        bash: commandAfterHeredoc,
        environment: {
            pattern: RegExp("\\$" + envVars),
            alias: "constant"
        },
        variable: [ {
            pattern: /\$?\(\([\s\S]+?\)\)/,
            greedy: true,
            inside: {
                variable: [ {
                    pattern: /(^\$\(\([\s\S]+)\)\)/,
                    lookbehind: true
                }, /^\$\(\(/ ],
                number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
                operator: /--?|-=|\+\+?|\+=|!=?|~|\*\*?|\*=|\/=?|%=?|<<=?|>>=?|<=?|>=?|==?|&&?|&=|\^=?|\|\|?|\|=|\?|:/,
                punctuation: /\(\(?|\)\)?|,|;/
            }
        }, {
            pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
            greedy: true,
            inside: {
                variable: /^\$\(|^`|\)$|`$/
            }
        }, {
            pattern: /\$\{[^}]+\}/,
            greedy: true,
            inside: {
                operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
                punctuation: /[\[\]]/,
                environment: {
                    pattern: RegExp("(\\{)" + envVars),
                    lookbehind: true,
                    alias: "constant"
                }
            }
        }, /\$(?:\w+|[#?*!@$])/ ],
        entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|x[0-9a-fA-F]{1,2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})/
    };
    Prism.languages.bash = {
        shebang: {
            pattern: /^#!\s*\/.*/,
            alias: "important"
        },
        comment: {
            pattern: /(^|[^"{\\$])#.*/,
            lookbehind: true
        },
        "function-name": [ {
            pattern: /(\bfunction\s+)\w+(?=(?:\s*\(?:\s*\))?\s*\{)/,
            lookbehind: true,
            alias: "function"
        }, {
            pattern: /\b\w+(?=\s*\(\s*\)\s*\{)/,
            alias: "function"
        } ],
        "for-or-select": {
            pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
            alias: "variable",
            lookbehind: true
        },
        "assign-left": {
            pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
            inside: {
                environment: {
                    pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
                    lookbehind: true,
                    alias: "constant"
                }
            },
            alias: "variable",
            lookbehind: true
        },
        string: [ {
            pattern: /((?:^|[^<])<<-?\s*)(\w+?)\s[\s\S]*?(?:\r?\n|\r)\2/,
            lookbehind: true,
            greedy: true,
            inside: insideString
        }, {
            pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
            lookbehind: true,
            greedy: true,
            inside: {
                bash: commandAfterHeredoc
            }
        }, {
            pattern: /(^|[^\\](?:\\\\)*)(["'])(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|(?!\2)[^\\`$])*\2/,
            lookbehind: true,
            greedy: true,
            inside: insideString
        } ],
        environment: {
            pattern: RegExp("\\$?" + envVars),
            alias: "constant"
        },
        variable: insideString.variable,
        function: {
            pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|aptitude|apt-cache|apt-get|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
            lookbehind: true
        },
        keyword: {
            pattern: /(^|[\s;|&]|[<>]\()(?:if|then|else|elif|fi|for|while|in|case|esac|function|select|do|done|until)(?=$|[)\s;|&])/,
            lookbehind: true
        },
        builtin: {
            pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|break|cd|continue|eval|exec|exit|export|getopts|hash|pwd|readonly|return|shift|test|times|trap|umask|unset|alias|bind|builtin|caller|command|declare|echo|enable|help|let|local|logout|mapfile|printf|read|readarray|source|type|typeset|ulimit|unalias|set|shopt)(?=$|[)\s;|&])/,
            lookbehind: true,
            alias: "class-name"
        },
        boolean: {
            pattern: /(^|[\s;|&]|[<>]\()(?:true|false)(?=$|[)\s;|&])/,
            lookbehind: true
        },
        "file-descriptor": {
            pattern: /\B&\d\b/,
            alias: "important"
        },
        operator: {
            pattern: /\d?<>|>\||\+=|==?|!=?|=~|<<[<-]?|[&\d]?>>|\d?[<>]&?|&[>&]?|\|[&|]?|<=?|>=?/,
            inside: {
                "file-descriptor": {
                    pattern: /^\d/,
                    alias: "important"
                }
            }
        },
        punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
        number: {
            pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
            lookbehind: true
        }
    };
    commandAfterHeredoc.inside = Prism.languages.bash;
    var toBeCopied = [ "comment", "function-name", "for-or-select", "assign-left", "string", "environment", "function", "keyword", "builtin", "boolean", "file-descriptor", "operator", "punctuation", "number" ];
    var inside = insideString.variable[1].inside;
    for (var i = 0; i < toBeCopied.length; i++) {
        inside[toBeCopied[i]] = Prism.languages.bash[toBeCopied[i]];
    }
    Prism.languages.shell = Prism.languages.bash;
})(Prism);

Prism.languages.basic = {
    comment: {
        pattern: /(?:!|REM\b).+/i,
        inside: {
            keyword: /^REM/i
        }
    },
    string: {
        pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^_ +\-.A-Z\d])*"/i,
        greedy: true
    },
    number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
    keyword: /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SHARED|SINGLE|SELECT CASE|SHELL|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
    function: /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
    operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
    punctuation: /[,;:()]/
};

Prism.languages.c = Prism.languages.extend("clike", {
    comment: {
        pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
        greedy: true
    },
    "class-name": {
        pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
        lookbehind: true
    },
    keyword: /\b(?:__attribute__|_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,
    function: /[a-z_]\w*(?=\s*\()/i,
    number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});

Prism.languages.insertBefore("c", "string", {
    macro: {
        pattern: /(^\s*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
        lookbehind: true,
        greedy: true,
        alias: "property",
        inside: {
            string: [ {
                pattern: /^(#\s*include\s*)<[^>]+>/,
                lookbehind: true
            }, Prism.languages.c["string"] ],
            comment: Prism.languages.c["comment"],
            "macro-name": [ {
                pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
                lookbehind: true
            }, {
                pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
                lookbehind: true,
                alias: "function"
            } ],
            directive: {
                pattern: /^(#\s*)[a-z]+/,
                lookbehind: true,
                alias: "keyword"
            },
            "directive-hash": /^#/,
            punctuation: /##|\\(?=[\r\n])/,
            expression: {
                pattern: /\S[\s\S]*/,
                inside: Prism.languages.c
            }
        }
    },
    constant: /\b(?:__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|stdin|stdout|stderr)\b/
});

delete Prism.languages.c["boolean"];

(function(Prism) {
    var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char8_t|char16_t|char32_t|class|compl|concept|const|consteval|constexpr|constinit|const_cast|continue|co_await|co_return|co_yield|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
    Prism.languages.cpp = Prism.languages.extend("c", {
        "class-name": [ {
            pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
                return keyword.source;
            })),
            lookbehind: true
        }, /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/, /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i, /\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/ ],
        keyword: keyword,
        number: {
            pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
            greedy: true
        },
        operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
        boolean: /\b(?:true|false)\b/
    });
    Prism.languages.insertBefore("cpp", "string", {
        "raw-string": {
            pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
            alias: "string",
            greedy: true
        }
    });
    Prism.languages.insertBefore("cpp", "class-name", {
        "base-clause": {
            pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
            lookbehind: true,
            greedy: true,
            inside: Prism.languages.extend("cpp", {})
        }
    });
    Prism.languages.insertBefore("inside", "operator", {
        "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
    }, Prism.languages.cpp["base-clause"]);
})(Prism);

(function(Prism) {
    var string = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
    var selectorInside;
    Prism.languages.css.selector = {
        pattern: Prism.languages.css.selector,
        inside: selectorInside = {
            "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
            "pseudo-class": /:[-\w]+/,
            class: /\.[-\w]+/,
            id: /#[-\w]+/,
            attribute: {
                pattern: RegExp("\\[(?:[^[\\]\"']|" + string.source + ")*\\]"),
                greedy: true,
                inside: {
                    punctuation: /^\[|\]$/,
                    "case-sensitivity": {
                        pattern: /(\s)[si]$/i,
                        lookbehind: true,
                        alias: "keyword"
                    },
                    namespace: {
                        pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
                        lookbehind: true,
                        inside: {
                            punctuation: /\|$/
                        }
                    },
                    "attr-name": {
                        pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
                        lookbehind: true
                    },
                    "attr-value": [ string, {
                        pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
                        lookbehind: true
                    } ],
                    operator: /[|~*^$]?=/
                }
            },
            "n-th": [ {
                pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
                lookbehind: true,
                inside: {
                    number: /[\dn]+/,
                    operator: /[+-]/
                }
            }, {
                pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
                lookbehind: true
            } ],
            combinator: />|\+|~|\|\|/,
            punctuation: /[(),]/
        }
    };
    Prism.languages.css["atrule"].inside["selector-function-argument"].inside = selectorInside;
    Prism.languages.insertBefore("css", "property", {
        variable: {
            pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,
            lookbehind: true
        }
    });
    var unit = {
        pattern: /(\b\d+)(?:%|[a-z]+\b)/,
        lookbehind: true
    };
    var number = {
        pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
        lookbehind: true
    };
    Prism.languages.insertBefore("css", "function", {
        operator: {
            pattern: /(\s)[+\-*\/](?=\s)/,
            lookbehind: true
        },
        hexcode: {
            pattern: /\B#(?:[\da-f]{1,2}){3,4}\b/i,
            alias: "color"
        },
        color: [ /\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i, {
            pattern: /\b(?:rgb|hsl)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:rgb|hsl)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
            inside: {
                unit: unit,
                number: number,
                function: /[\w-]+(?=\()/,
                punctuation: /[(),]/
            }
        } ],
        entity: /\\[\da-f]{1,8}/i,
        unit: unit,
        number: number
    });
})(Prism);

Prism.languages.git = {
    comment: /^#.*/m,
    deleted: /^[-].*/m,
    inserted: /^\+.*/m,
    string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/m,
    command: {
        pattern: /^.*\$ git .*$/m,
        inside: {
            parameter: /\s--?\w+/m
        }
    },
    coord: /^@@.*@@$/m,
    "commit-sha1": /^commit \w{40}$/m
};

(function(Prism) {
    var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
    var classNamePrefix = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
    var className = {
        pattern: RegExp(classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
        lookbehind: true,
        inside: {
            namespace: {
                pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
                inside: {
                    punctuation: /\./
                }
            },
            punctuation: /\./
        }
    };
    Prism.languages.java = Prism.languages.extend("clike", {
        "class-name": [ className, {
            pattern: RegExp(classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=())])/.source),
            lookbehind: true,
            inside: className.inside
        } ],
        keyword: keywords,
        function: [ Prism.languages.clike.function, {
            pattern: /(\:\:\s*)[a-z_]\w*/,
            lookbehind: true
        } ],
        number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
        operator: {
            pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
            lookbehind: true
        }
    });
    Prism.languages.insertBefore("java", "string", {
        "triple-quoted-string": {
            pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
            greedy: true,
            alias: "string"
        }
    });
    Prism.languages.insertBefore("java", "class-name", {
        annotation: {
            pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
            lookbehind: true,
            alias: "punctuation"
        },
        generics: {
            pattern: /<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<[\w\s,.&?]*>)*>)*>)*>/,
            inside: {
                "class-name": className,
                keyword: keywords,
                punctuation: /[<>(),.:]/,
                operator: /[?&|]/
            }
        },
        namespace: {
            pattern: RegExp(/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
                return keywords.source;
            })),
            lookbehind: true,
            inside: {
                punctuation: /\./
            }
        }
    });
})(Prism);

Prism.languages.python = {
    comment: {
        pattern: /(^|[^\\])#.*/,
        lookbehind: true
    },
    "string-interpolation": {
        pattern: /(?:f|rf|fr)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
        greedy: true,
        inside: {
            interpolation: {
                pattern: /((?:^|[^{])(?:{{)*){(?!{)(?:[^{}]|{(?!{)(?:[^{}]|{(?!{)(?:[^{}])+})+})+}/,
                lookbehind: true,
                inside: {
                    "format-spec": {
                        pattern: /(:)[^:(){}]+(?=}$)/,
                        lookbehind: true
                    },
                    "conversion-option": {
                        pattern: /![sra](?=[:}]$)/,
                        alias: "punctuation"
                    },
                    rest: null
                }
            },
            string: /[\s\S]+/
        }
    },
    "triple-quoted-string": {
        pattern: /(?:[rub]|rb|br)?("""|''')[\s\S]*?\1/i,
        greedy: true,
        alias: "string"
    },
    string: {
        pattern: /(?:[rub]|rb|br)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
        greedy: true
    },
    function: {
        pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
        lookbehind: true
    },
    "class-name": {
        pattern: /(\bclass\s+)\w+/i,
        lookbehind: true
    },
    decorator: {
        pattern: /(^\s*)@\w+(?:\.\w+)*/im,
        lookbehind: true,
        alias: [ "annotation", "punctuation" ],
        inside: {
            punctuation: /\./
        }
    },
    keyword: /\b(?:and|as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    boolean: /\b(?:True|False|None)\b/,
    number: /(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?j?\b/i,
    operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    punctuation: /[{}[\];(),.:]/
};

Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;

Prism.languages.py = Prism.languages.python;

Prism.languages.scss = Prism.languages.extend("css", {
    comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
        lookbehind: true
    },
    atrule: {
        pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
        inside: {
            rule: /@[\w-]+/
        }
    },
    url: /(?:[-a-z]+-)?url(?=\()/i,
    selector: {
        pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]+))/m,
        inside: {
            parent: {
                pattern: /&/,
                alias: "important"
            },
            placeholder: /%[-\w]+/,
            variable: /\$[-\w]+|#\{\$[-\w]+\}/
        }
    },
    property: {
        pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
        inside: {
            variable: /\$[-\w]+|#\{\$[-\w]+\}/
        }
    }
});

Prism.languages.insertBefore("scss", "atrule", {
    keyword: [ /@(?:if|else(?: if)?|forward|for|each|while|import|use|extend|debug|warn|mixin|include|function|return|content)\b/i, {
        pattern: /( +)(?:from|through)(?= )/,
        lookbehind: true
    } ]
});

Prism.languages.insertBefore("scss", "important", {
    variable: /\$[-\w]+|#\{\$[-\w]+\}/
});

Prism.languages.insertBefore("scss", "function", {
    "module-modifier": {
        pattern: /\b(?:as|with|show|hide)\b/i,
        alias: "keyword"
    },
    placeholder: {
        pattern: /%[-\w]+/,
        alias: "selector"
    },
    statement: {
        pattern: /\B!(?:default|optional)\b/i,
        alias: "keyword"
    },
    boolean: /\b(?:true|false)\b/,
    null: {
        pattern: /\bnull\b/,
        alias: "keyword"
    },
    operator: {
        pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|or|not)(?=\s)/,
        lookbehind: true
    }
});

Prism.languages.scss["atrule"].inside.rest = Prism.languages.scss;

Prism.languages.sql = {
    comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
        lookbehind: true
    },
    variable: [ {
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: true
    }, /@[\w.$]+/ ],
    string: {
        pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
        greedy: true,
        lookbehind: true
    },
    function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:S|ING)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    boolean: /\b(?:TRUE|FALSE|NULL)\b/i,
    number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|IN|LIKE|NOT|OR|IS|DIV|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    punctuation: /[;[\]()`,.]/
};

Prism.languages.vbnet = Prism.languages.extend("basic", {
    comment: [ {
        pattern: /(?:!|REM\b).+/i,
        inside: {
            keyword: /^REM/i
        }
    }, {
        pattern: /(^|[^\\:])'.*/,
        lookbehind: true
    } ],
    keyword: /(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDEC|CDBL|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEFAULT|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LINE INPUT|LET|LIB|LIKE|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPERATOR|OPEN|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHORT|SINGLE|SHELL|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SYNCLOCK|SWAP|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i
});

Prism.languages["visual-basic"] = {
    comment: {
        pattern: /(?:[']|REM\b)(?:[^\r\n_]|_(?:\r\n?|\n)?)*/i,
        inside: {
            keyword: /^REM/i
        }
    },
    directive: {
        pattern: /#(?:Const|Else|ElseIf|End|ExternalChecksum|ExternalSource|If|Region)(?:[^\S\r\n]_[^\S\r\n]*(?:\r\n?|\n)|.)+/i,
        alias: "comment",
        greedy: true
    },
    string: {
        pattern: /\$?["](?:["]{2}|[^"])*["]C?/i,
        greedy: true
    },
    date: {
        pattern: /#[^\S\r\n]*(?:\d+([/-])\d+\1\d+(?:[^\S\r\n]+(?:\d+[^\S\r\n]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[^\S\r\n]*(?:AM|PM))?))?|\d+[^\S\r\n]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[^\S\r\n]*(?:AM|PM))?)[^\S\r\n]*#/i,
        alias: "builtin"
    },
    number: /(?:(?:\b\d+(?:\.\d+)?|\.\d+)(?:E[+-]?\d+)?|&[HO][\dA-F]+)(?:U?[ILS]|[FRD])?/i,
    boolean: /\b(?:True|False|Nothing)\b/i,
    keyword: /\b(?:AddHandler|AddressOf|Alias|And(?:Also)?|As|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|C(?:Bool|Byte|Char|Date|Dbl|Dec|Int|Lng|Obj|SByte|Short|Sng|Str|Type|UInt|ULng|UShort)|Char|Class|Const|Continue|Currency|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else(?:If)?|End(?:If)?|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get(?:Type|XMLNamespace)?|Global|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|IsNot|Let|Lib|Like|Long|Loop|Me|Mod|Module|Must(?:Inherit|Override)|My(?:Base|Class)|Namespace|Narrowing|New|Next|Not(?:Inheritable|Overridable)?|Object|Of|On|Operator|Option(?:al)?|Or(?:Else)?|Out|Overloads|Overridable|Overrides|ParamArray|Partial|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|SByte|Select|Set|Shadows|Shared|short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TryCast|Type|TypeOf|U(?:Integer|Long|Short)|Using|Variant|Wend|When|While|Widening|With(?:Events)?|WriteOnly|Until|Xor)\b/i,
    operator: [ /[+\-*/\\^<=>&#@$%!]/, {
        pattern: /([^\S\r\n])_(?=[^\S\r\n]*[\r\n])/,
        lookbehind: true
    } ],
    punctuation: /[{}().,:?]/
};

Prism.languages.vb = Prism.languages["visual-basic"];

Prism.languages.vba = Prism.languages["visual-basic"];

(function() {
    if (typeof self === "undefined" || !self.Prism || !self.document || !document.querySelector) {
        return;
    }
    function $$(selector, container) {
        return Array.prototype.slice.call((container || document).querySelectorAll(selector));
    }
    function hasClass(element, className) {
        className = " " + className + " ";
        return (" " + element.className + " ").replace(/[\n\t]/g, " ").indexOf(className) > -1;
    }
    function callFunction(func) {
        func();
    }
    var isLineHeightRounded = function() {
        var res;
        return function() {
            if (typeof res === "undefined") {
                var d = document.createElement("div");
                d.style.fontSize = "13px";
                d.style.lineHeight = "1.5";
                d.style.padding = "0";
                d.style.border = "0";
                d.innerHTML = "&nbsp;<br />&nbsp;";
                document.body.appendChild(d);
                res = d.offsetHeight === 38;
                document.body.removeChild(d);
            }
            return res;
        };
    }();
    function getContentBoxTopOffset(parent, child) {
        var parentStyle = getComputedStyle(parent);
        var childStyle = getComputedStyle(child);
        function pxToNumber(px) {
            return +px.substr(0, px.length - 2);
        }
        return child.offsetTop + pxToNumber(childStyle.borderTopWidth) + pxToNumber(childStyle.paddingTop) - pxToNumber(parentStyle.paddingTop);
    }
    function highlightLines(pre, lines, classes) {
        lines = typeof lines === "string" ? lines : pre.getAttribute("data-line");
        var ranges = lines.replace(/\s+/g, "").split(",").filter(Boolean);
        var offset = +pre.getAttribute("data-line-offset") || 0;
        var parseMethod = isLineHeightRounded() ? parseInt : parseFloat;
        var lineHeight = parseMethod(getComputedStyle(pre).lineHeight);
        var hasLineNumbers = hasClass(pre, "line-numbers");
        var codeElement = pre.querySelector("code");
        var parentElement = hasLineNumbers ? pre : codeElement || pre;
        var mutateActions = [];
        var codePreOffset = !codeElement || parentElement == codeElement ? 0 : getContentBoxTopOffset(pre, codeElement);
        ranges.forEach(function(currentRange) {
            var range = currentRange.split("-");
            var start = +range[0];
            var end = +range[1] || start;
            var line = pre.querySelector('.line-highlight[data-range="' + currentRange + '"]') || document.createElement("div");
            mutateActions.push(function() {
                line.setAttribute("aria-hidden", "true");
                line.setAttribute("data-range", currentRange);
                line.className = (classes || "") + " line-highlight";
            });
            if (hasLineNumbers && Prism.plugins.lineNumbers) {
                var startNode = Prism.plugins.lineNumbers.getLine(pre, start);
                var endNode = Prism.plugins.lineNumbers.getLine(pre, end);
                if (startNode) {
                    var top = startNode.offsetTop + codePreOffset + "px";
                    mutateActions.push(function() {
                        line.style.top = top;
                    });
                }
                if (endNode) {
                    var height = endNode.offsetTop - startNode.offsetTop + endNode.offsetHeight + "px";
                    mutateActions.push(function() {
                        line.style.height = height;
                    });
                }
            } else {
                mutateActions.push(function() {
                    line.setAttribute("data-start", String(start));
                    if (end > start) {
                        line.setAttribute("data-end", String(end));
                    }
                    line.style.top = (start - offset - 1) * lineHeight + codePreOffset + "px";
                    line.textContent = new Array(end - start + 2).join(" \n");
                });
            }
            mutateActions.push(function() {
                parentElement.appendChild(line);
            });
        });
        var id = pre.id;
        if (hasLineNumbers && id) {
            var linkableLineNumbersClass = "linkable-line-numbers";
            var linkableLineNumbers = false;
            var node = pre;
            while (node) {
                if (hasClass(node, linkableLineNumbersClass)) {
                    linkableLineNumbers = true;
                    break;
                }
                node = node.parentElement;
            }
            if (linkableLineNumbers) {
                if (!hasClass(pre, linkableLineNumbersClass)) {
                    mutateActions.push(function() {
                        pre.className = (pre.className + " " + linkableLineNumbersClass).trim();
                    });
                }
                var start = parseInt(pre.getAttribute("data-start") || "1");
                $$(".line-numbers-rows > span", pre).forEach(function(lineSpan, i) {
                    var lineNumber = i + start;
                    lineSpan.onclick = function() {
                        var hash = id + "." + lineNumber;
                        scrollIntoView = false;
                        location.hash = hash;
                        setTimeout(function() {
                            scrollIntoView = true;
                        }, 1);
                    };
                });
            }
        }
        return function() {
            mutateActions.forEach(callFunction);
        };
    }
    var scrollIntoView = true;
    function applyHash() {
        var hash = location.hash.slice(1);
        $$(".temporary.line-highlight").forEach(function(line) {
            line.parentNode.removeChild(line);
        });
        var range = (hash.match(/\.([\d,-]+)$/) || [ , "" ])[1];
        if (!range || document.getElementById(hash)) {
            return;
        }
        var id = hash.slice(0, hash.lastIndexOf(".")), pre = document.getElementById(id);
        if (!pre) {
            return;
        }
        if (!pre.hasAttribute("data-line")) {
            pre.setAttribute("data-line", "");
        }
        var mutateDom = highlightLines(pre, range, "temporary ");
        mutateDom();
        if (scrollIntoView) {
            document.querySelector(".temporary.line-highlight").scrollIntoView();
        }
    }
    var fakeTimer = 0;
    Prism.hooks.add("before-sanity-check", function(env) {
        var pre = env.element.parentElement;
        var lines = pre && pre.getAttribute("data-line");
        if (!pre || !lines || !/pre/i.test(pre.nodeName)) {
            return;
        }
        var num = 0;
        $$(".line-highlight", pre).forEach(function(line) {
            num += line.textContent.length;
            line.parentNode.removeChild(line);
        });
        if (num && /^( \n)+$/.test(env.code.slice(-num))) {
            env.code = env.code.slice(0, -num);
        }
    });
    Prism.hooks.add("complete", function completeHook(env) {
        var pre = env.element.parentElement;
        var lines = pre && pre.getAttribute("data-line");
        if (!pre || !lines || !/pre/i.test(pre.nodeName)) {
            return;
        }
        clearTimeout(fakeTimer);
        var hasLineNumbers = Prism.plugins.lineNumbers;
        var isLineNumbersLoaded = env.plugins && env.plugins.lineNumbers;
        if (hasClass(pre, "line-numbers") && hasLineNumbers && !isLineNumbersLoaded) {
            Prism.hooks.add("line-numbers", completeHook);
        } else {
            var mutateDom = highlightLines(pre, lines);
            mutateDom();
            fakeTimer = setTimeout(applyHash, 1);
        }
    });
    window.addEventListener("hashchange", applyHash);
    window.addEventListener("resize", function() {
        var actions = $$("pre[data-line]").map(function(pre) {
            return highlightLines(pre);
        });
        actions.forEach(callFunction);
    });
})();

(function() {
    if (typeof self === "undefined" || !self.Prism || !self.document) {
        return;
    }
    var PLUGIN_NAME = "line-numbers";
    var NEW_LINE_EXP = /\n(?!$)/g;
    var config = Prism.plugins.lineNumbers = {
        getLine: function(element, number) {
            if (element.tagName !== "PRE" || !element.classList.contains(PLUGIN_NAME)) {
                return;
            }
            var lineNumberRows = element.querySelector(".line-numbers-rows");
            if (!lineNumberRows) {
                return;
            }
            var lineNumberStart = parseInt(element.getAttribute("data-start"), 10) || 1;
            var lineNumberEnd = lineNumberStart + (lineNumberRows.children.length - 1);
            if (number < lineNumberStart) {
                number = lineNumberStart;
            }
            if (number > lineNumberEnd) {
                number = lineNumberEnd;
            }
            var lineIndex = number - lineNumberStart;
            return lineNumberRows.children[lineIndex];
        },
        resize: function(element) {
            resizeElements([ element ]);
        },
        assumeViewportIndependence: true
    };
    function resizeElements(elements) {
        elements = elements.filter(function(e) {
            var codeStyles = getStyles(e);
            var whiteSpace = codeStyles["white-space"];
            return whiteSpace === "pre-wrap" || whiteSpace === "pre-line";
        });
        if (elements.length == 0) {
            return;
        }
        var infos = elements.map(function(element) {
            var codeElement = element.querySelector("code");
            var lineNumbersWrapper = element.querySelector(".line-numbers-rows");
            if (!codeElement || !lineNumbersWrapper) {
                return undefined;
            }
            var lineNumberSizer = element.querySelector(".line-numbers-sizer");
            var codeLines = codeElement.textContent.split(NEW_LINE_EXP);
            if (!lineNumberSizer) {
                lineNumberSizer = document.createElement("span");
                lineNumberSizer.className = "line-numbers-sizer";
                codeElement.appendChild(lineNumberSizer);
            }
            lineNumberSizer.innerHTML = "0";
            lineNumberSizer.style.display = "block";
            var oneLinerHeight = lineNumberSizer.getBoundingClientRect().height;
            lineNumberSizer.innerHTML = "";
            return {
                element: element,
                lines: codeLines,
                lineHeights: [],
                oneLinerHeight: oneLinerHeight,
                sizer: lineNumberSizer
            };
        }).filter(Boolean);
        infos.forEach(function(info) {
            var lineNumberSizer = info.sizer;
            var lines = info.lines;
            var lineHeights = info.lineHeights;
            var oneLinerHeight = info.oneLinerHeight;
            lineHeights[lines.length - 1] = undefined;
            lines.forEach(function(line, index) {
                if (line && line.length > 1) {
                    var e = lineNumberSizer.appendChild(document.createElement("span"));
                    e.style.display = "block";
                    e.textContent = line;
                } else {
                    lineHeights[index] = oneLinerHeight;
                }
            });
        });
        infos.forEach(function(info) {
            var lineNumberSizer = info.sizer;
            var lineHeights = info.lineHeights;
            var childIndex = 0;
            for (var i = 0; i < lineHeights.length; i++) {
                if (lineHeights[i] === undefined) {
                    lineHeights[i] = lineNumberSizer.children[childIndex++].getBoundingClientRect().height;
                }
            }
        });
        infos.forEach(function(info) {
            var lineNumberSizer = info.sizer;
            var wrapper = info.element.querySelector(".line-numbers-rows");
            lineNumberSizer.style.display = "none";
            lineNumberSizer.innerHTML = "";
            info.lineHeights.forEach(function(height, lineNumber) {
                wrapper.children[lineNumber].style.height = height + "px";
            });
        });
    }
    var getStyles = function(element) {
        if (!element) {
            return null;
        }
        return window.getComputedStyle ? getComputedStyle(element) : element.currentStyle || null;
    };
    var lastWidth = undefined;
    window.addEventListener("resize", function() {
        if (config.assumeViewportIndependence && lastWidth === window.innerWidth) {
            return;
        }
        lastWidth = window.innerWidth;
        resizeElements(Array.prototype.slice.call(document.querySelectorAll("pre." + PLUGIN_NAME)));
    });
    Prism.hooks.add("complete", function(env) {
        if (!env.code) {
            return;
        }
        var code = env.element;
        var pre = code.parentNode;
        if (!pre || !/pre/i.test(pre.nodeName)) {
            return;
        }
        if (code.querySelector(".line-numbers-rows")) {
            return;
        }
        if (!Prism.util.isActive(code, PLUGIN_NAME)) {
            return;
        }
        code.classList.remove(PLUGIN_NAME);
        pre.classList.add(PLUGIN_NAME);
        var match = env.code.match(NEW_LINE_EXP);
        var linesNum = match ? match.length + 1 : 1;
        var lineNumbersWrapper;
        var lines = new Array(linesNum + 1).join("<span></span>");
        lineNumbersWrapper = document.createElement("span");
        lineNumbersWrapper.setAttribute("aria-hidden", "true");
        lineNumbersWrapper.className = "line-numbers-rows";
        lineNumbersWrapper.innerHTML = lines;
        if (pre.hasAttribute("data-start")) {
            pre.style.counterReset = "linenumber " + (parseInt(pre.getAttribute("data-start"), 10) - 1);
        }
        env.element.appendChild(lineNumbersWrapper);
        resizeElements([ pre ]);
        Prism.hooks.run("line-numbers", env);
    });
    Prism.hooks.add("line-numbers", function(env) {
        env.plugins = env.plugins || {};
        env.plugins.lineNumbers = true;
    });
})();

(function() {
    if (typeof self !== "undefined" && !self.Prism || typeof global !== "undefined" && !global.Prism) {
        return;
    }
    var url = /\b([a-z]{3,7}:\/\/|tel:)[\w\-+%~/.:=&@]+(?:\?[\w\-+%~/.:=?&!$'()*,;@]*)?(?:#[\w\-+%~/.:#=?&!$'()*,;@]*)?/, email = /\b\S+@[\w.]+[a-z]{2}/, linkMd = /\[([^\]]+)]\(([^)]+)\)/, candidates = [ "comment", "url", "attr-value", "string" ];
    Prism.plugins.autolinker = {
        processGrammar: function(grammar) {
            if (!grammar || grammar["url-link"]) {
                return;
            }
            Prism.languages.DFS(grammar, function(key, def, type) {
                if (candidates.indexOf(type) > -1 && !Array.isArray(def)) {
                    if (!def.pattern) {
                        def = this[key] = {
                            pattern: def
                        };
                    }
                    def.inside = def.inside || {};
                    if (type == "comment") {
                        def.inside["md-link"] = linkMd;
                    }
                    if (type == "attr-value") {
                        Prism.languages.insertBefore("inside", "punctuation", {
                            "url-link": url
                        }, def);
                    } else {
                        def.inside["url-link"] = url;
                    }
                    def.inside["email-link"] = email;
                }
            });
            grammar["url-link"] = url;
            grammar["email-link"] = email;
        }
    };
    Prism.hooks.add("before-highlight", function(env) {
        Prism.plugins.autolinker.processGrammar(env.grammar);
    });
    Prism.hooks.add("wrap", function(env) {
        if (/-link$/.test(env.type)) {
            env.tag = "a";
            var href = env.content;
            if (env.type == "email-link" && href.indexOf("mailto:") != 0) {
                href = "mailto:" + href;
            } else if (env.type == "md-link") {
                var match = env.content.match(linkMd);
                href = match[2];
                env.content = match[1];
            }
            env.attributes.href = href;
            try {
                env.content = decodeURIComponent(env.content);
            } catch (e) {}
        }
    });
})();

(function() {
    var assign = Object.assign || function(obj1, obj2) {
        for (var name in obj2) {
            if (obj2.hasOwnProperty(name)) obj1[name] = obj2[name];
        }
        return obj1;
    };
    function NormalizeWhitespace(defaults) {
        this.defaults = assign({}, defaults);
    }
    function toCamelCase(value) {
        return value.replace(/-(\w)/g, function(match, firstChar) {
            return firstChar.toUpperCase();
        });
    }
    function tabLen(str) {
        var res = 0;
        for (var i = 0; i < str.length; ++i) {
            if (str.charCodeAt(i) == "\t".charCodeAt(0)) res += 3;
        }
        return str.length + res;
    }
    NormalizeWhitespace.prototype = {
        setDefaults: function(defaults) {
            this.defaults = assign(this.defaults, defaults);
        },
        normalize: function(input, settings) {
            settings = assign(this.defaults, settings);
            for (var name in settings) {
                var methodName = toCamelCase(name);
                if (name !== "normalize" && methodName !== "setDefaults" && settings[name] && this[methodName]) {
                    input = this[methodName].call(this, input, settings[name]);
                }
            }
            return input;
        },
        leftTrim: function(input) {
            return input.replace(/^\s+/, "");
        },
        rightTrim: function(input) {
            return input.replace(/\s+$/, "");
        },
        tabsToSpaces: function(input, spaces) {
            spaces = spaces | 0 || 4;
            return input.replace(/\t/g, new Array(++spaces).join(" "));
        },
        spacesToTabs: function(input, spaces) {
            spaces = spaces | 0 || 4;
            return input.replace(RegExp(" {" + spaces + "}", "g"), "\t");
        },
        removeTrailing: function(input) {
            return input.replace(/\s*?$/gm, "");
        },
        removeInitialLineFeed: function(input) {
            return input.replace(/^(?:\r?\n|\r)/, "");
        },
        removeIndent: function(input) {
            var indents = input.match(/^[^\S\n\r]*(?=\S)/gm);
            if (!indents || !indents[0].length) return input;
            indents.sort(function(a, b) {
                return a.length - b.length;
            });
            if (!indents[0].length) return input;
            return input.replace(RegExp("^" + indents[0], "gm"), "");
        },
        indent: function(input, tabs) {
            return input.replace(/^[^\S\n\r]*(?=\S)/gm, new Array(++tabs).join("\t") + "$&");
        },
        breakLines: function(input, characters) {
            characters = characters === true ? 80 : characters | 0 || 80;
            var lines = input.split("\n");
            for (var i = 0; i < lines.length; ++i) {
                if (tabLen(lines[i]) <= characters) continue;
                var line = lines[i].split(/(\s+)/g), len = 0;
                for (var j = 0; j < line.length; ++j) {
                    var tl = tabLen(line[j]);
                    len += tl;
                    if (len > characters) {
                        line[j] = "\n" + line[j];
                        len = tl;
                    }
                }
                lines[i] = line.join("");
            }
            return lines.join("\n");
        }
    };
    if (typeof module !== "undefined" && module.exports) {
        module.exports = NormalizeWhitespace;
    }
    if (typeof Prism === "undefined") {
        return;
    }
    Prism.plugins.NormalizeWhitespace = new NormalizeWhitespace({
        "remove-trailing": true,
        "remove-indent": true,
        "left-trim": true,
        "right-trim": true
    });
    Prism.hooks.add("before-sanity-check", function(env) {
        var Normalizer = Prism.plugins.NormalizeWhitespace;
        if (env.settings && env.settings["whitespace-normalization"] === false) {
            return;
        }
        if (!Prism.util.isActive(env.element, "whitespace-normalization", true)) {
            return;
        }
        if ((!env.element || !env.element.parentNode) && env.code) {
            env.code = Normalizer.normalize(env.code, env.settings);
            return;
        }
        var pre = env.element.parentNode;
        if (!env.code || !pre || pre.nodeName.toLowerCase() !== "pre") {
            return;
        }
        var children = pre.childNodes, before = "", after = "", codeFound = false;
        for (var i = 0; i < children.length; ++i) {
            var node = children[i];
            if (node == env.element) {
                codeFound = true;
            } else if (node.nodeName === "#text") {
                if (codeFound) {
                    after += node.nodeValue;
                } else {
                    before += node.nodeValue;
                }
                pre.removeChild(node);
                --i;
            }
        }
        if (!env.element.children.length || !Prism.plugins.KeepMarkup) {
            env.code = before + env.code + after;
            env.code = Normalizer.normalize(env.code, env.settings);
        } else {
            var html = before + env.element.innerHTML + after;
            env.element.innerHTML = Normalizer.normalize(html, env.settings);
            env.code = env.element.textContent;
        }
    });
})();

(function() {
    if (typeof self === "undefined" || !self.Prism || !self.document) {
        return;
    }
    var callbacks = [];
    var map = {};
    var noop = function() {};
    Prism.plugins.toolbar = {};
    var registerButton = Prism.plugins.toolbar.registerButton = function(key, opts) {
        var callback;
        if (typeof opts === "function") {
            callback = opts;
        } else {
            callback = function(env) {
                var element;
                if (typeof opts.onClick === "function") {
                    element = document.createElement("button");
                    element.type = "button";
                    element.addEventListener("click", function() {
                        opts.onClick.call(this, env);
                    });
                } else if (typeof opts.url === "string") {
                    element = document.createElement("a");
                    element.href = opts.url;
                } else {
                    element = document.createElement("span");
                }
                if (opts.className) {
                    element.classList.add(opts.className);
                }
                element.textContent = opts.text;
                return element;
            };
        }
        if (key in map) {
            console.warn('There is a button with the key "' + key + '" registered already.');
            return;
        }
        callbacks.push(map[key] = callback);
    };
    function getOrder(element) {
        while (element) {
            var order = element.getAttribute("data-toolbar-order");
            if (order != null) {
                order = order.trim();
                if (order.length) {
                    return order.split(/\s*,\s*/g);
                } else {
                    return [];
                }
            }
            element = element.parentElement;
        }
    }
    var hook = Prism.plugins.toolbar.hook = function(env) {
        var pre = env.element.parentNode;
        if (!pre || !/pre/i.test(pre.nodeName)) {
            return;
        }
        if (pre.parentNode.classList.contains("code-toolbar")) {
            return;
        }
        var wrapper = document.createElement("div");
        wrapper.classList.add("code-toolbar");
        pre.parentNode.insertBefore(wrapper, pre);
        wrapper.appendChild(pre);
        var toolbar = document.createElement("div");
        toolbar.classList.add("toolbar");
        var elementCallbacks = callbacks;
        var order = getOrder(env.element);
        if (order) {
            elementCallbacks = order.map(function(key) {
                return map[key] || noop;
            });
        }
        elementCallbacks.forEach(function(callback) {
            var element = callback(env);
            if (!element) {
                return;
            }
            var item = document.createElement("div");
            item.classList.add("toolbar-item");
            item.appendChild(element);
            toolbar.appendChild(item);
        });
        wrapper.appendChild(toolbar);
    };
    registerButton("label", function(env) {
        var pre = env.element.parentNode;
        if (!pre || !/pre/i.test(pre.nodeName)) {
            return;
        }
        if (!pre.hasAttribute("data-label")) {
            return;
        }
        var element, template;
        var text = pre.getAttribute("data-label");
        try {
            template = document.querySelector("template#" + text);
        } catch (e) {}
        if (template) {
            element = template.content;
        } else {
            if (pre.hasAttribute("data-url")) {
                element = document.createElement("a");
                element.href = pre.getAttribute("data-url");
            } else {
                element = document.createElement("span");
            }
            element.textContent = text;
        }
        return element;
    });
    Prism.hooks.add("complete", hook);
})();

(function() {
    if (typeof self === "undefined" || !self.Prism || !self.document) {
        return;
    }
    if (!Prism.plugins.toolbar) {
        console.warn("Copy to Clipboard plugin loaded before Toolbar plugin.");
        return;
    }
    var ClipboardJS = window.ClipboardJS || undefined;
    if (!ClipboardJS && typeof require === "function") {
        ClipboardJS = require("clipboard");
    }
    var callbacks = [];
    if (!ClipboardJS) {
        var script = document.createElement("script");
        var head = document.querySelector("head");
        script.onload = function() {
            ClipboardJS = window.ClipboardJS;
            if (ClipboardJS) {
                while (callbacks.length) {
                    callbacks.pop()();
                }
            }
        };
        script.src = "https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js";
        head.appendChild(script);
    }
    Prism.plugins.toolbar.registerButton("copy-to-clipboard", function(env) {
        var linkCopy = document.createElement("button");
        linkCopy.textContent = "Copy";
        linkCopy.setAttribute("type", "button");
        var element = env.element;
        if (!ClipboardJS) {
            callbacks.push(registerClipboard);
        } else {
            registerClipboard();
        }
        return linkCopy;
        function registerClipboard() {
            var clip = new ClipboardJS(linkCopy, {
                text: function() {
                    return element.textContent;
                }
            });
            clip.on("success", function() {
                linkCopy.textContent = "Copied!";
                resetText();
            });
            clip.on("error", function() {
                linkCopy.textContent = "Press Ctrl+C to copy";
                resetText();
            });
        }
        function resetText() {
            setTimeout(function() {
                linkCopy.textContent = "Copy";
            }, 5e3);
        }
    });
})();

!function(a, b, c, d) {
    "use strict";
    function e(a, b, c) {
        return setTimeout(j(a, c), b);
    }
    function f(a, b, c) {
        return Array.isArray(a) ? (g(a, c[b], c), !0) : !1;
    }
    function g(a, b, c) {
        var e;
        if (a) if (a.forEach) a.forEach(b, c); else if (a.length !== d) for (e = 0; e < a.length; ) b.call(c, a[e], e, a), 
        e++; else for (e in a) a.hasOwnProperty(e) && b.call(c, a[e], e, a);
    }
    function h(b, c, d) {
        var e = "DEPRECATED METHOD: " + c + "\n" + d + " AT \n";
        return function() {
            var c = new Error("get-stack-trace"), d = c && c.stack ? c.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", f = a.console && (a.console.warn || a.console.log);
            return f && f.call(a.console, e, d), b.apply(this, arguments);
        };
    }
    function i(a, b, c) {
        var d, e = b.prototype;
        d = a.prototype = Object.create(e), d.constructor = a, d._super = e, c && la(d, c);
    }
    function j(a, b) {
        return function() {
            return a.apply(b, arguments);
        };
    }
    function k(a, b) {
        return typeof a == oa ? a.apply(b ? b[0] || d : d, b) : a;
    }
    function l(a, b) {
        return a === d ? b : a;
    }
    function m(a, b, c) {
        g(q(b), function(b) {
            a.addEventListener(b, c, !1);
        });
    }
    function n(a, b, c) {
        g(q(b), function(b) {
            a.removeEventListener(b, c, !1);
        });
    }
    function o(a, b) {
        for (;a; ) {
            if (a == b) return !0;
            a = a.parentNode;
        }
        return !1;
    }
    function p(a, b) {
        return a.indexOf(b) > -1;
    }
    function q(a) {
        return a.trim().split(/\s+/g);
    }
    function r(a, b, c) {
        if (a.indexOf && !c) return a.indexOf(b);
        for (var d = 0; d < a.length; ) {
            if (c && a[d][c] == b || !c && a[d] === b) return d;
            d++;
        }
        return -1;
    }
    function s(a) {
        return Array.prototype.slice.call(a, 0);
    }
    function t(a, b, c) {
        for (var d = [], e = [], f = 0; f < a.length; ) {
            var g = b ? a[f][b] : a[f];
            r(e, g) < 0 && d.push(a[f]), e[f] = g, f++;
        }
        return c && (d = b ? d.sort(function(a, c) {
            return a[b] > c[b];
        }) : d.sort()), d;
    }
    function u(a, b) {
        for (var c, e, f = b[0].toUpperCase() + b.slice(1), g = 0; g < ma.length; ) {
            if (c = ma[g], e = c ? c + f : b, e in a) return e;
            g++;
        }
        return d;
    }
    function v() {
        return ua++;
    }
    function w(b) {
        var c = b.ownerDocument || b;
        return c.defaultView || c.parentWindow || a;
    }
    function x(a, b) {
        var c = this;
        this.manager = a, this.callback = b, this.element = a.element, this.target = a.options.inputTarget, 
        this.domHandler = function(b) {
            k(a.options.enable, [ a ]) && c.handler(b);
        }, this.init();
    }
    function y(a) {
        var b, c = a.options.inputClass;
        return new (b = c ? c : xa ? M : ya ? P : wa ? R : L)(a, z);
    }
    function z(a, b, c) {
        var d = c.pointers.length, e = c.changedPointers.length, f = b & Ea && d - e === 0, g = b & (Ga | Ha) && d - e === 0;
        c.isFirst = !!f, c.isFinal = !!g, f && (a.session = {}), c.eventType = b, A(a, c), 
        a.emit("hammer.input", c), a.recognize(c), a.session.prevInput = c;
    }
    function A(a, b) {
        var c = a.session, d = b.pointers, e = d.length;
        c.firstInput || (c.firstInput = D(b)), e > 1 && !c.firstMultiple ? c.firstMultiple = D(b) : 1 === e && (c.firstMultiple = !1);
        var f = c.firstInput, g = c.firstMultiple, h = g ? g.center : f.center, i = b.center = E(d);
        b.timeStamp = ra(), b.deltaTime = b.timeStamp - f.timeStamp, b.angle = I(h, i), 
        b.distance = H(h, i), B(c, b), b.offsetDirection = G(b.deltaX, b.deltaY);
        var j = F(b.deltaTime, b.deltaX, b.deltaY);
        b.overallVelocityX = j.x, b.overallVelocityY = j.y, b.overallVelocity = qa(j.x) > qa(j.y) ? j.x : j.y, 
        b.scale = g ? K(g.pointers, d) : 1, b.rotation = g ? J(g.pointers, d) : 0, b.maxPointers = c.prevInput ? b.pointers.length > c.prevInput.maxPointers ? b.pointers.length : c.prevInput.maxPointers : b.pointers.length, 
        C(c, b);
        var k = a.element;
        o(b.srcEvent.target, k) && (k = b.srcEvent.target), b.target = k;
    }
    function B(a, b) {
        var c = b.center, d = a.offsetDelta || {}, e = a.prevDelta || {}, f = a.prevInput || {};
        b.eventType !== Ea && f.eventType !== Ga || (e = a.prevDelta = {
            x: f.deltaX || 0,
            y: f.deltaY || 0
        }, d = a.offsetDelta = {
            x: c.x,
            y: c.y
        }), b.deltaX = e.x + (c.x - d.x), b.deltaY = e.y + (c.y - d.y);
    }
    function C(a, b) {
        var c, e, f, g, h = a.lastInterval || b, i = b.timeStamp - h.timeStamp;
        if (b.eventType != Ha && (i > Da || h.velocity === d)) {
            var j = b.deltaX - h.deltaX, k = b.deltaY - h.deltaY, l = F(i, j, k);
            e = l.x, f = l.y, c = qa(l.x) > qa(l.y) ? l.x : l.y, g = G(j, k), a.lastInterval = b;
        } else c = h.velocity, e = h.velocityX, f = h.velocityY, g = h.direction;
        b.velocity = c, b.velocityX = e, b.velocityY = f, b.direction = g;
    }
    function D(a) {
        for (var b = [], c = 0; c < a.pointers.length; ) b[c] = {
            clientX: pa(a.pointers[c].clientX),
            clientY: pa(a.pointers[c].clientY)
        }, c++;
        return {
            timeStamp: ra(),
            pointers: b,
            center: E(b),
            deltaX: a.deltaX,
            deltaY: a.deltaY
        };
    }
    function E(a) {
        var b = a.length;
        if (1 === b) return {
            x: pa(a[0].clientX),
            y: pa(a[0].clientY)
        };
        for (var c = 0, d = 0, e = 0; b > e; ) c += a[e].clientX, d += a[e].clientY, e++;
        return {
            x: pa(c / b),
            y: pa(d / b)
        };
    }
    function F(a, b, c) {
        return {
            x: b / a || 0,
            y: c / a || 0
        };
    }
    function G(a, b) {
        return a === b ? Ia : qa(a) >= qa(b) ? 0 > a ? Ja : Ka : 0 > b ? La : Ma;
    }
    function H(a, b, c) {
        c || (c = Qa);
        var d = b[c[0]] - a[c[0]], e = b[c[1]] - a[c[1]];
        return Math.sqrt(d * d + e * e);
    }
    function I(a, b, c) {
        c || (c = Qa);
        var d = b[c[0]] - a[c[0]], e = b[c[1]] - a[c[1]];
        return 180 * Math.atan2(e, d) / Math.PI;
    }
    function J(a, b) {
        return I(b[1], b[0], Ra) + I(a[1], a[0], Ra);
    }
    function K(a, b) {
        return H(b[0], b[1], Ra) / H(a[0], a[1], Ra);
    }
    function L() {
        this.evEl = Ta, this.evWin = Ua, this.pressed = !1, x.apply(this, arguments);
    }
    function M() {
        this.evEl = Xa, this.evWin = Ya, x.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
    }
    function N() {
        this.evTarget = $a, this.evWin = _a, this.started = !1, x.apply(this, arguments);
    }
    function O(a, b) {
        var c = s(a.touches), d = s(a.changedTouches);
        return b & (Ga | Ha) && (c = t(c.concat(d), "identifier", !0)), [ c, d ];
    }
    function P() {
        this.evTarget = bb, this.targetIds = {}, x.apply(this, arguments);
    }
    function Q(a, b) {
        var c = s(a.touches), d = this.targetIds;
        if (b & (Ea | Fa) && 1 === c.length) return d[c[0].identifier] = !0, [ c, c ];
        var e, f, g = s(a.changedTouches), h = [], i = this.target;
        if (f = c.filter(function(a) {
            return o(a.target, i);
        }), b === Ea) for (e = 0; e < f.length; ) d[f[e].identifier] = !0, e++;
        for (e = 0; e < g.length; ) d[g[e].identifier] && h.push(g[e]), b & (Ga | Ha) && delete d[g[e].identifier], 
        e++;
        return h.length ? [ t(f.concat(h), "identifier", !0), h ] : void 0;
    }
    function R() {
        x.apply(this, arguments);
        var a = j(this.handler, this);
        this.touch = new P(this.manager, a), this.mouse = new L(this.manager, a), this.primaryTouch = null, 
        this.lastTouches = [];
    }
    function S(a, b) {
        a & Ea ? (this.primaryTouch = b.changedPointers[0].identifier, T.call(this, b)) : a & (Ga | Ha) && T.call(this, b);
    }
    function T(a) {
        var b = a.changedPointers[0];
        if (b.identifier === this.primaryTouch) {
            var c = {
                x: b.clientX,
                y: b.clientY
            };
            this.lastTouches.push(c);
            var d = this.lastTouches, e = function() {
                var a = d.indexOf(c);
                a > -1 && d.splice(a, 1);
            };
            setTimeout(e, cb);
        }
    }
    function U(a) {
        for (var b = a.srcEvent.clientX, c = a.srcEvent.clientY, d = 0; d < this.lastTouches.length; d++) {
            var e = this.lastTouches[d], f = Math.abs(b - e.x), g = Math.abs(c - e.y);
            if (db >= f && db >= g) return !0;
        }
        return !1;
    }
    function V(a, b) {
        this.manager = a, this.set(b);
    }
    function W(a) {
        if (p(a, jb)) return jb;
        var b = p(a, kb), c = p(a, lb);
        return b && c ? jb : b || c ? b ? kb : lb : p(a, ib) ? ib : hb;
    }
    function X() {
        if (!fb) return !1;
        var b = {}, c = a.CSS && a.CSS.supports;
        return [ "auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none" ].forEach(function(d) {
            b[d] = c ? a.CSS.supports("touch-action", d) : !0;
        }), b;
    }
    function Y(a) {
        this.options = la({}, this.defaults, a || {}), this.id = v(), this.manager = null, 
        this.options.enable = l(this.options.enable, !0), this.state = nb, this.simultaneous = {}, 
        this.requireFail = [];
    }
    function Z(a) {
        return a & sb ? "cancel" : a & qb ? "end" : a & pb ? "move" : a & ob ? "start" : "";
    }
    function $(a) {
        return a == Ma ? "down" : a == La ? "up" : a == Ja ? "left" : a == Ka ? "right" : "";
    }
    function _(a, b) {
        var c = b.manager;
        return c ? c.get(a) : a;
    }
    function aa() {
        Y.apply(this, arguments);
    }
    function ba() {
        aa.apply(this, arguments), this.pX = null, this.pY = null;
    }
    function ca() {
        aa.apply(this, arguments);
    }
    function da() {
        Y.apply(this, arguments), this._timer = null, this._input = null;
    }
    function ea() {
        aa.apply(this, arguments);
    }
    function fa() {
        aa.apply(this, arguments);
    }
    function ga() {
        Y.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, 
        this._input = null, this.count = 0;
    }
    function ha(a, b) {
        return b = b || {}, b.recognizers = l(b.recognizers, ha.defaults.preset), new ia(a, b);
    }
    function ia(a, b) {
        this.options = la({}, ha.defaults, b || {}), this.options.inputTarget = this.options.inputTarget || a, 
        this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, 
        this.element = a, this.input = y(this), this.touchAction = new V(this, this.options.touchAction), 
        ja(this, !0), g(this.options.recognizers, function(a) {
            var b = this.add(new a[0](a[1]));
            a[2] && b.recognizeWith(a[2]), a[3] && b.requireFailure(a[3]);
        }, this);
    }
    function ja(a, b) {
        var c = a.element;
        if (c.style) {
            var d;
            g(a.options.cssProps, function(e, f) {
                d = u(c.style, f), b ? (a.oldCssProps[d] = c.style[d], c.style[d] = e) : c.style[d] = a.oldCssProps[d] || "";
            }), b || (a.oldCssProps = {});
        }
    }
    function ka(a, c) {
        var d = b.createEvent("Event");
        d.initEvent(a, !0, !0), d.gesture = c, c.target.dispatchEvent(d);
    }
    var la, ma = [ "", "webkit", "Moz", "MS", "ms", "o" ], na = b.createElement("div"), oa = "function", pa = Math.round, qa = Math.abs, ra = Date.now;
    la = "function" != typeof Object.assign ? function(a) {
        if (a === d || null === a) throw new TypeError("Cannot convert undefined or null to object");
        for (var b = Object(a), c = 1; c < arguments.length; c++) {
            var e = arguments[c];
            if (e !== d && null !== e) for (var f in e) e.hasOwnProperty(f) && (b[f] = e[f]);
        }
        return b;
    } : Object.assign;
    var sa = h(function(a, b, c) {
        for (var e = Object.keys(b), f = 0; f < e.length; ) (!c || c && a[e[f]] === d) && (a[e[f]] = b[e[f]]), 
        f++;
        return a;
    }, "extend", "Use `assign`."), ta = h(function(a, b) {
        return sa(a, b, !0);
    }, "merge", "Use `assign`."), ua = 1, va = /mobile|tablet|ip(ad|hone|od)|android/i, wa = "ontouchstart" in a, xa = u(a, "PointerEvent") !== d, ya = wa && va.test(navigator.userAgent), za = "touch", Aa = "pen", Ba = "mouse", Ca = "kinect", Da = 25, Ea = 1, Fa = 2, Ga = 4, Ha = 8, Ia = 1, Ja = 2, Ka = 4, La = 8, Ma = 16, Na = Ja | Ka, Oa = La | Ma, Pa = Na | Oa, Qa = [ "x", "y" ], Ra = [ "clientX", "clientY" ];
    x.prototype = {
        handler: function() {},
        init: function() {
            this.evEl && m(this.element, this.evEl, this.domHandler), this.evTarget && m(this.target, this.evTarget, this.domHandler), 
            this.evWin && m(w(this.element), this.evWin, this.domHandler);
        },
        destroy: function() {
            this.evEl && n(this.element, this.evEl, this.domHandler), this.evTarget && n(this.target, this.evTarget, this.domHandler), 
            this.evWin && n(w(this.element), this.evWin, this.domHandler);
        }
    };
    var Sa = {
        mousedown: Ea,
        mousemove: Fa,
        mouseup: Ga
    }, Ta = "mousedown", Ua = "mousemove mouseup";
    i(L, x, {
        handler: function(a) {
            var b = Sa[a.type];
            b & Ea && 0 === a.button && (this.pressed = !0), b & Fa && 1 !== a.which && (b = Ga), 
            this.pressed && (b & Ga && (this.pressed = !1), this.callback(this.manager, b, {
                pointers: [ a ],
                changedPointers: [ a ],
                pointerType: Ba,
                srcEvent: a
            }));
        }
    });
    var Va = {
        pointerdown: Ea,
        pointermove: Fa,
        pointerup: Ga,
        pointercancel: Ha,
        pointerout: Ha
    }, Wa = {
        2: za,
        3: Aa,
        4: Ba,
        5: Ca
    }, Xa = "pointerdown", Ya = "pointermove pointerup pointercancel";
    a.MSPointerEvent && !a.PointerEvent && (Xa = "MSPointerDown", Ya = "MSPointerMove MSPointerUp MSPointerCancel"), 
    i(M, x, {
        handler: function(a) {
            var b = this.store, c = !1, d = a.type.toLowerCase().replace("ms", ""), e = Va[d], f = Wa[a.pointerType] || a.pointerType, g = f == za, h = r(b, a.pointerId, "pointerId");
            e & Ea && (0 === a.button || g) ? 0 > h && (b.push(a), h = b.length - 1) : e & (Ga | Ha) && (c = !0), 
            0 > h || (b[h] = a, this.callback(this.manager, e, {
                pointers: b,
                changedPointers: [ a ],
                pointerType: f,
                srcEvent: a
            }), c && b.splice(h, 1));
        }
    });
    var Za = {
        touchstart: Ea,
        touchmove: Fa,
        touchend: Ga,
        touchcancel: Ha
    }, $a = "touchstart", _a = "touchstart touchmove touchend touchcancel";
    i(N, x, {
        handler: function(a) {
            var b = Za[a.type];
            if (b === Ea && (this.started = !0), this.started) {
                var c = O.call(this, a, b);
                b & (Ga | Ha) && c[0].length - c[1].length === 0 && (this.started = !1), this.callback(this.manager, b, {
                    pointers: c[0],
                    changedPointers: c[1],
                    pointerType: za,
                    srcEvent: a
                });
            }
        }
    });
    var ab = {
        touchstart: Ea,
        touchmove: Fa,
        touchend: Ga,
        touchcancel: Ha
    }, bb = "touchstart touchmove touchend touchcancel";
    i(P, x, {
        handler: function(a) {
            var b = ab[a.type], c = Q.call(this, a, b);
            c && this.callback(this.manager, b, {
                pointers: c[0],
                changedPointers: c[1],
                pointerType: za,
                srcEvent: a
            });
        }
    });
    var cb = 2500, db = 25;
    i(R, x, {
        handler: function(a, b, c) {
            var d = c.pointerType == za, e = c.pointerType == Ba;
            if (!(e && c.sourceCapabilities && c.sourceCapabilities.firesTouchEvents)) {
                if (d) S.call(this, b, c); else if (e && U.call(this, c)) return;
                this.callback(a, b, c);
            }
        },
        destroy: function() {
            this.touch.destroy(), this.mouse.destroy();
        }
    });
    var eb = u(na.style, "touchAction"), fb = eb !== d, gb = "compute", hb = "auto", ib = "manipulation", jb = "none", kb = "pan-x", lb = "pan-y", mb = X();
    V.prototype = {
        set: function(a) {
            a == gb && (a = this.compute()), fb && this.manager.element.style && mb[a] && (this.manager.element.style[eb] = a), 
            this.actions = a.toLowerCase().trim();
        },
        update: function() {
            this.set(this.manager.options.touchAction);
        },
        compute: function() {
            var a = [];
            return g(this.manager.recognizers, function(b) {
                k(b.options.enable, [ b ]) && (a = a.concat(b.getTouchAction()));
            }), W(a.join(" "));
        },
        preventDefaults: function(a) {
            var b = a.srcEvent, c = a.offsetDirection;
            if (this.manager.session.prevented) return void b.preventDefault();
            var d = this.actions, e = p(d, jb) && !mb[jb], f = p(d, lb) && !mb[lb], g = p(d, kb) && !mb[kb];
            if (e) {
                var h = 1 === a.pointers.length, i = a.distance < 2, j = a.deltaTime < 250;
                if (h && i && j) return;
            }
            return g && f ? void 0 : e || f && c & Na || g && c & Oa ? this.preventSrc(b) : void 0;
        },
        preventSrc: function(a) {
            this.manager.session.prevented = !0, a.preventDefault();
        }
    };
    var nb = 1, ob = 2, pb = 4, qb = 8, rb = qb, sb = 16, tb = 32;
    Y.prototype = {
        defaults: {},
        set: function(a) {
            return la(this.options, a), this.manager && this.manager.touchAction.update(), this;
        },
        recognizeWith: function(a) {
            if (f(a, "recognizeWith", this)) return this;
            var b = this.simultaneous;
            return a = _(a, this), b[a.id] || (b[a.id] = a, a.recognizeWith(this)), this;
        },
        dropRecognizeWith: function(a) {
            return f(a, "dropRecognizeWith", this) ? this : (a = _(a, this), delete this.simultaneous[a.id], 
            this);
        },
        requireFailure: function(a) {
            if (f(a, "requireFailure", this)) return this;
            var b = this.requireFail;
            return a = _(a, this), -1 === r(b, a) && (b.push(a), a.requireFailure(this)), this;
        },
        dropRequireFailure: function(a) {
            if (f(a, "dropRequireFailure", this)) return this;
            a = _(a, this);
            var b = r(this.requireFail, a);
            return b > -1 && this.requireFail.splice(b, 1), this;
        },
        hasRequireFailures: function() {
            return this.requireFail.length > 0;
        },
        canRecognizeWith: function(a) {
            return !!this.simultaneous[a.id];
        },
        emit: function(a) {
            function b(b) {
                c.manager.emit(b, a);
            }
            var c = this, d = this.state;
            qb > d && b(c.options.event + Z(d)), b(c.options.event), a.additionalEvent && b(a.additionalEvent), 
            d >= qb && b(c.options.event + Z(d));
        },
        tryEmit: function(a) {
            return this.canEmit() ? this.emit(a) : void (this.state = tb);
        },
        canEmit: function() {
            for (var a = 0; a < this.requireFail.length; ) {
                if (!(this.requireFail[a].state & (tb | nb))) return !1;
                a++;
            }
            return !0;
        },
        recognize: function(a) {
            var b = la({}, a);
            return k(this.options.enable, [ this, b ]) ? (this.state & (rb | sb | tb) && (this.state = nb), 
            this.state = this.process(b), void (this.state & (ob | pb | qb | sb) && this.tryEmit(b))) : (this.reset(), 
            void (this.state = tb));
        },
        process: function(a) {},
        getTouchAction: function() {},
        reset: function() {}
    }, i(aa, Y, {
        defaults: {
            pointers: 1
        },
        attrTest: function(a) {
            var b = this.options.pointers;
            return 0 === b || a.pointers.length === b;
        },
        process: function(a) {
            var b = this.state, c = a.eventType, d = b & (ob | pb), e = this.attrTest(a);
            return d && (c & Ha || !e) ? b | sb : d || e ? c & Ga ? b | qb : b & ob ? b | pb : ob : tb;
        }
    }), i(ba, aa, {
        defaults: {
            event: "pan",
            threshold: 10,
            pointers: 1,
            direction: Pa
        },
        getTouchAction: function() {
            var a = this.options.direction, b = [];
            return a & Na && b.push(lb), a & Oa && b.push(kb), b;
        },
        directionTest: function(a) {
            var b = this.options, c = !0, d = a.distance, e = a.direction, f = a.deltaX, g = a.deltaY;
            return e & b.direction || (b.direction & Na ? (e = 0 === f ? Ia : 0 > f ? Ja : Ka, 
            c = f != this.pX, d = Math.abs(a.deltaX)) : (e = 0 === g ? Ia : 0 > g ? La : Ma, 
            c = g != this.pY, d = Math.abs(a.deltaY))), a.direction = e, c && d > b.threshold && e & b.direction;
        },
        attrTest: function(a) {
            return aa.prototype.attrTest.call(this, a) && (this.state & ob || !(this.state & ob) && this.directionTest(a));
        },
        emit: function(a) {
            this.pX = a.deltaX, this.pY = a.deltaY;
            var b = $(a.direction);
            b && (a.additionalEvent = this.options.event + b), this._super.emit.call(this, a);
        }
    }), i(ca, aa, {
        defaults: {
            event: "pinch",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [ jb ];
        },
        attrTest: function(a) {
            return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold || this.state & ob);
        },
        emit: function(a) {
            if (1 !== a.scale) {
                var b = a.scale < 1 ? "in" : "out";
                a.additionalEvent = this.options.event + b;
            }
            this._super.emit.call(this, a);
        }
    }), i(da, Y, {
        defaults: {
            event: "press",
            pointers: 1,
            time: 251,
            threshold: 9
        },
        getTouchAction: function() {
            return [ hb ];
        },
        process: function(a) {
            var b = this.options, c = a.pointers.length === b.pointers, d = a.distance < b.threshold, f = a.deltaTime > b.time;
            if (this._input = a, !d || !c || a.eventType & (Ga | Ha) && !f) this.reset(); else if (a.eventType & Ea) this.reset(), 
            this._timer = e(function() {
                this.state = rb, this.tryEmit();
            }, b.time, this); else if (a.eventType & Ga) return rb;
            return tb;
        },
        reset: function() {
            clearTimeout(this._timer);
        },
        emit: function(a) {
            this.state === rb && (a && a.eventType & Ga ? this.manager.emit(this.options.event + "up", a) : (this._input.timeStamp = ra(), 
            this.manager.emit(this.options.event, this._input)));
        }
    }), i(ea, aa, {
        defaults: {
            event: "rotate",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [ jb ];
        },
        attrTest: function(a) {
            return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & ob);
        }
    }), i(fa, aa, {
        defaults: {
            event: "swipe",
            threshold: 10,
            velocity: .3,
            direction: Na | Oa,
            pointers: 1
        },
        getTouchAction: function() {
            return ba.prototype.getTouchAction.call(this);
        },
        attrTest: function(a) {
            var b, c = this.options.direction;
            return c & (Na | Oa) ? b = a.overallVelocity : c & Na ? b = a.overallVelocityX : c & Oa && (b = a.overallVelocityY), 
            this._super.attrTest.call(this, a) && c & a.offsetDirection && a.distance > this.options.threshold && a.maxPointers == this.options.pointers && qa(b) > this.options.velocity && a.eventType & Ga;
        },
        emit: function(a) {
            var b = $(a.offsetDirection);
            b && this.manager.emit(this.options.event + b, a), this.manager.emit(this.options.event, a);
        }
    }), i(ga, Y, {
        defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            time: 250,
            threshold: 9,
            posThreshold: 10
        },
        getTouchAction: function() {
            return [ ib ];
        },
        process: function(a) {
            var b = this.options, c = a.pointers.length === b.pointers, d = a.distance < b.threshold, f = a.deltaTime < b.time;
            if (this.reset(), a.eventType & Ea && 0 === this.count) return this.failTimeout();
            if (d && f && c) {
                if (a.eventType != Ga) return this.failTimeout();
                var g = this.pTime ? a.timeStamp - this.pTime < b.interval : !0, h = !this.pCenter || H(this.pCenter, a.center) < b.posThreshold;
                this.pTime = a.timeStamp, this.pCenter = a.center, h && g ? this.count += 1 : this.count = 1, 
                this._input = a;
                var i = this.count % b.taps;
                if (0 === i) return this.hasRequireFailures() ? (this._timer = e(function() {
                    this.state = rb, this.tryEmit();
                }, b.interval, this), ob) : rb;
            }
            return tb;
        },
        failTimeout: function() {
            return this._timer = e(function() {
                this.state = tb;
            }, this.options.interval, this), tb;
        },
        reset: function() {
            clearTimeout(this._timer);
        },
        emit: function() {
            this.state == rb && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
        }
    }), ha.VERSION = "2.0.8", ha.defaults = {
        domEvents: !1,
        touchAction: gb,
        enable: !0,
        inputTarget: null,
        inputClass: null,
        preset: [ [ ea, {
            enable: !1
        } ], [ ca, {
            enable: !1
        }, [ "rotate" ] ], [ fa, {
            direction: Na
        } ], [ ba, {
            direction: Na
        }, [ "swipe" ] ], [ ga ], [ ga, {
            event: "doubletap",
            taps: 2
        }, [ "tap" ] ], [ da ] ],
        cssProps: {
            userSelect: "none",
            touchSelect: "none",
            touchCallout: "none",
            contentZooming: "none",
            userDrag: "none",
            tapHighlightColor: "rgba(0,0,0,0)"
        }
    };
    var ub = 1, vb = 2;
    ia.prototype = {
        set: function(a) {
            return la(this.options, a), a.touchAction && this.touchAction.update(), a.inputTarget && (this.input.destroy(), 
            this.input.target = a.inputTarget, this.input.init()), this;
        },
        stop: function(a) {
            this.session.stopped = a ? vb : ub;
        },
        recognize: function(a) {
            var b = this.session;
            if (!b.stopped) {
                this.touchAction.preventDefaults(a);
                var c, d = this.recognizers, e = b.curRecognizer;
                (!e || e && e.state & rb) && (e = b.curRecognizer = null);
                for (var f = 0; f < d.length; ) c = d[f], b.stopped === vb || e && c != e && !c.canRecognizeWith(e) ? c.reset() : c.recognize(a), 
                !e && c.state & (ob | pb | qb) && (e = b.curRecognizer = c), f++;
            }
        },
        get: function(a) {
            if (a instanceof Y) return a;
            for (var b = this.recognizers, c = 0; c < b.length; c++) if (b[c].options.event == a) return b[c];
            return null;
        },
        add: function(a) {
            if (f(a, "add", this)) return this;
            var b = this.get(a.options.event);
            return b && this.remove(b), this.recognizers.push(a), a.manager = this, this.touchAction.update(), 
            a;
        },
        remove: function(a) {
            if (f(a, "remove", this)) return this;
            if (a = this.get(a)) {
                var b = this.recognizers, c = r(b, a);
                -1 !== c && (b.splice(c, 1), this.touchAction.update());
            }
            return this;
        },
        on: function(a, b) {
            if (a !== d && b !== d) {
                var c = this.handlers;
                return g(q(a), function(a) {
                    c[a] = c[a] || [], c[a].push(b);
                }), this;
            }
        },
        off: function(a, b) {
            if (a !== d) {
                var c = this.handlers;
                return g(q(a), function(a) {
                    b ? c[a] && c[a].splice(r(c[a], b), 1) : delete c[a];
                }), this;
            }
        },
        emit: function(a, b) {
            this.options.domEvents && ka(a, b);
            var c = this.handlers[a] && this.handlers[a].slice();
            if (c && c.length) {
                b.type = a, b.preventDefault = function() {
                    b.srcEvent.preventDefault();
                };
                for (var d = 0; d < c.length; ) c[d](b), d++;
            }
        },
        destroy: function() {
            this.element && ja(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), 
            this.element = null;
        }
    }, la(ha, {
        INPUT_START: Ea,
        INPUT_MOVE: Fa,
        INPUT_END: Ga,
        INPUT_CANCEL: Ha,
        STATE_POSSIBLE: nb,
        STATE_BEGAN: ob,
        STATE_CHANGED: pb,
        STATE_ENDED: qb,
        STATE_RECOGNIZED: rb,
        STATE_CANCELLED: sb,
        STATE_FAILED: tb,
        DIRECTION_NONE: Ia,
        DIRECTION_LEFT: Ja,
        DIRECTION_RIGHT: Ka,
        DIRECTION_UP: La,
        DIRECTION_DOWN: Ma,
        DIRECTION_HORIZONTAL: Na,
        DIRECTION_VERTICAL: Oa,
        DIRECTION_ALL: Pa,
        Manager: ia,
        Input: x,
        TouchAction: V,
        TouchInput: P,
        MouseInput: L,
        PointerEventInput: M,
        TouchMouseInput: R,
        SingleTouchInput: N,
        Recognizer: Y,
        AttrRecognizer: aa,
        Tap: ga,
        Pan: ba,
        Swipe: fa,
        Pinch: ca,
        Rotate: ea,
        Press: da,
        on: m,
        off: n,
        each: g,
        merge: ta,
        extend: sa,
        assign: la,
        inherit: i,
        bindFn: j,
        prefixed: u
    });
    var wb = "undefined" != typeof a ? a : "undefined" != typeof self ? self : {};
    wb.Hammer = ha, "function" == typeof define && define.amd ? define(function() {
        return ha;
    }) : "undefined" != typeof module && module.exports ? module.exports = ha : a[c] = ha;
}(window, document, "Hammer");

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function(jQuery) {
    (function($) {
        "use strict";
        var ts = $.tablesorter = {
            version: "2.31.3",
            parsers: [],
            widgets: [],
            defaults: {
                theme: "default",
                widthFixed: false,
                showProcessing: false,
                headerTemplate: "{content}",
                onRenderTemplate: null,
                onRenderHeader: null,
                cancelSelection: true,
                tabIndex: true,
                dateFormat: "mmddyyyy",
                sortMultiSortKey: "shiftKey",
                sortResetKey: "ctrlKey",
                usNumberFormat: true,
                delayInit: false,
                serverSideSorting: false,
                resort: true,
                headers: {},
                ignoreCase: true,
                sortForce: null,
                sortList: [],
                sortAppend: null,
                sortStable: false,
                sortInitialOrder: "asc",
                sortLocaleCompare: false,
                sortReset: false,
                sortRestart: false,
                emptyTo: "bottom",
                stringTo: "max",
                duplicateSpan: true,
                textExtraction: "basic",
                textAttribute: "data-text",
                textSorter: null,
                numberSorter: null,
                initWidgets: true,
                widgetClass: "widget-{name}",
                widgets: [],
                widgetOptions: {
                    zebra: [ "even", "odd" ]
                },
                initialized: null,
                tableClass: "",
                cssAsc: "",
                cssDesc: "",
                cssNone: "",
                cssHeader: "",
                cssHeaderRow: "",
                cssProcessing: "",
                cssChildRow: "tablesorter-childRow",
                cssInfoBlock: "tablesorter-infoOnly",
                cssNoSort: "tablesorter-noSort",
                cssIgnoreRow: "tablesorter-ignoreRow",
                cssIcon: "tablesorter-icon",
                cssIconNone: "",
                cssIconAsc: "",
                cssIconDesc: "",
                cssIconDisabled: "",
                pointerClick: "click",
                pointerDown: "mousedown",
                pointerUp: "mouseup",
                selectorHeaders: "> thead th, > thead td",
                selectorSort: "th, td",
                selectorRemove: ".remove-me",
                debug: false,
                headerList: [],
                empties: {},
                strings: {},
                parsers: [],
                globalize: 0,
                imgAttr: 0
            },
            css: {
                table: "tablesorter",
                cssHasChild: "tablesorter-hasChildRow",
                childRow: "tablesorter-childRow",
                colgroup: "tablesorter-colgroup",
                header: "tablesorter-header",
                headerRow: "tablesorter-headerRow",
                headerIn: "tablesorter-header-inner",
                icon: "tablesorter-icon",
                processing: "tablesorter-processing",
                sortAsc: "tablesorter-headerAsc",
                sortDesc: "tablesorter-headerDesc",
                sortNone: "tablesorter-headerUnSorted"
            },
            language: {
                sortAsc: "Ascending sort applied, ",
                sortDesc: "Descending sort applied, ",
                sortNone: "No sort applied, ",
                sortDisabled: "sorting is disabled",
                nextAsc: "activate to apply an ascending sort",
                nextDesc: "activate to apply a descending sort",
                nextNone: "activate to remove the sort"
            },
            regex: {
                templateContent: /\{content\}/g,
                templateIcon: /\{icon\}/g,
                templateName: /\{name\}/i,
                spaces: /\s+/g,
                nonWord: /\W/g,
                formElements: /(input|select|button|textarea)/i,
                chunk: /(^([+\-]?(?:\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,
                chunks: /(^\\0|\\0$)/,
                hex: /^0x[0-9a-f]+$/i,
                comma: /,/g,
                digitNonUS: /[\s|\.]/g,
                digitNegativeTest: /^\s*\([.\d]+\)/,
                digitNegativeReplace: /^\s*\(([.\d]+)\)/,
                digitTest: /^[\-+(]?\d+[)]?$/,
                digitReplace: /[,.'"\s]/g
            },
            string: {
                max: 1,
                min: -1,
                emptymin: 1,
                emptymax: -1,
                zero: 0,
                none: 0,
                null: 0,
                top: true,
                bottom: false
            },
            keyCodes: {
                enter: 13
            },
            dates: {},
            instanceMethods: {},
            setup: function(table, c) {
                if (!table || !table.tHead || table.tBodies.length === 0 || table.hasInitialized === true) {
                    if (ts.debug(c, "core")) {
                        if (table.hasInitialized) {
                            console.warn("Stopping initialization. Tablesorter has already been initialized");
                        } else {
                            console.error("Stopping initialization! No table, thead or tbody", table);
                        }
                    }
                    return;
                }
                var tmp = "", $table = $(table), meta = $.metadata;
                table.hasInitialized = false;
                table.isProcessing = true;
                table.config = c;
                $.data(table, "tablesorter", c);
                if (ts.debug(c, "core")) {
                    console[console.group ? "group" : "log"]("Initializing tablesorter v" + ts.version);
                    $.data(table, "startoveralltimer", new Date());
                }
                c.supportsDataObject = function(version) {
                    version[0] = parseInt(version[0], 10);
                    return version[0] > 1 || version[0] === 1 && parseInt(version[1], 10) >= 4;
                }($.fn.jquery.split("."));
                c.emptyTo = c.emptyTo.toLowerCase();
                c.stringTo = c.stringTo.toLowerCase();
                c.last = {
                    sortList: [],
                    clickedIndex: -1
                };
                if (!/tablesorter\-/.test($table.attr("class"))) {
                    tmp = c.theme !== "" ? " tablesorter-" + c.theme : "";
                }
                if (!c.namespace) {
                    c.namespace = ".tablesorter" + Math.random().toString(16).slice(2);
                } else {
                    c.namespace = "." + c.namespace.replace(ts.regex.nonWord, "");
                }
                c.table = table;
                c.$table = $table.addClass(ts.css.table + " " + c.tableClass + tmp + " " + c.namespace.slice(1)).attr("role", "grid");
                c.$headers = $table.find(c.selectorHeaders);
                c.$table.children().children("tr").attr("role", "row");
                c.$tbodies = $table.children("tbody:not(." + c.cssInfoBlock + ")").attr({
                    "aria-live": "polite",
                    "aria-relevant": "all"
                });
                if (c.$table.children("caption").length) {
                    tmp = c.$table.children("caption")[0];
                    if (!tmp.id) {
                        tmp.id = c.namespace.slice(1) + "caption";
                    }
                    c.$table.attr("aria-labelledby", tmp.id);
                }
                c.widgetInit = {};
                c.textExtraction = c.$table.attr("data-text-extraction") || c.textExtraction || "basic";
                ts.buildHeaders(c);
                ts.fixColumnWidth(table);
                ts.addWidgetFromClass(table);
                ts.applyWidgetOptions(table);
                ts.setupParsers(c);
                c.totalRows = 0;
                if (c.debug) {
                    ts.validateOptions(c);
                }
                if (!c.delayInit) {
                    ts.buildCache(c);
                }
                ts.bindEvents(table, c.$headers, true);
                ts.bindMethods(c);
                if (c.supportsDataObject && typeof $table.data().sortlist !== "undefined") {
                    c.sortList = $table.data().sortlist;
                } else if (meta && ($table.metadata() && $table.metadata().sortlist)) {
                    c.sortList = $table.metadata().sortlist;
                }
                ts.applyWidget(table, true);
                if (c.sortList.length > 0) {
                    c.last.sortList = c.sortList;
                    ts.sortOn(c, c.sortList, {}, !c.initWidgets);
                } else {
                    ts.setHeadersCss(c);
                    if (c.initWidgets) {
                        ts.applyWidget(table, false);
                    }
                }
                if (c.showProcessing) {
                    $table.unbind("sortBegin" + c.namespace + " sortEnd" + c.namespace).bind("sortBegin" + c.namespace + " sortEnd" + c.namespace, function(e) {
                        clearTimeout(c.timerProcessing);
                        ts.isProcessing(table);
                        if (e.type === "sortBegin") {
                            c.timerProcessing = setTimeout(function() {
                                ts.isProcessing(table, true);
                            }, 500);
                        }
                    });
                }
                table.hasInitialized = true;
                table.isProcessing = false;
                if (ts.debug(c, "core")) {
                    console.log("Overall initialization time:" + ts.benchmark($.data(table, "startoveralltimer")));
                    if (ts.debug(c, "core") && console.groupEnd) {
                        console.groupEnd();
                    }
                }
                $table.triggerHandler("tablesorter-initialized", table);
                if (typeof c.initialized === "function") {
                    c.initialized(table);
                }
            },
            bindMethods: function(c) {
                var $table = c.$table, namespace = c.namespace, events = ("sortReset update updateRows updateAll updateHeaders addRows updateCell updateComplete " + "sorton appendCache updateCache applyWidgetId applyWidgets refreshWidgets destroy mouseup " + "mouseleave ").split(" ").join(namespace + " ");
                $table.unbind(events.replace(ts.regex.spaces, " ")).bind("sortReset" + namespace, function(e, callback) {
                    e.stopPropagation();
                    ts.sortReset(this.config, function(table) {
                        if (table.isApplyingWidgets) {
                            setTimeout(function() {
                                ts.applyWidget(table, "", callback);
                            }, 100);
                        } else {
                            ts.applyWidget(table, "", callback);
                        }
                    });
                }).bind("updateAll" + namespace, function(e, resort, callback) {
                    e.stopPropagation();
                    ts.updateAll(this.config, resort, callback);
                }).bind("update" + namespace + " updateRows" + namespace, function(e, resort, callback) {
                    e.stopPropagation();
                    ts.update(this.config, resort, callback);
                }).bind("updateHeaders" + namespace, function(e, callback) {
                    e.stopPropagation();
                    ts.updateHeaders(this.config, callback);
                }).bind("updateCell" + namespace, function(e, cell, resort, callback) {
                    e.stopPropagation();
                    ts.updateCell(this.config, cell, resort, callback);
                }).bind("addRows" + namespace, function(e, $row, resort, callback) {
                    e.stopPropagation();
                    ts.addRows(this.config, $row, resort, callback);
                }).bind("updateComplete" + namespace, function() {
                    this.isUpdating = false;
                }).bind("sorton" + namespace, function(e, list, callback, init) {
                    e.stopPropagation();
                    ts.sortOn(this.config, list, callback, init);
                }).bind("appendCache" + namespace, function(e, callback, init) {
                    e.stopPropagation();
                    ts.appendCache(this.config, init);
                    if ($.isFunction(callback)) {
                        callback(this);
                    }
                }).bind("updateCache" + namespace, function(e, callback, $tbodies) {
                    e.stopPropagation();
                    ts.updateCache(this.config, callback, $tbodies);
                }).bind("applyWidgetId" + namespace, function(e, id) {
                    e.stopPropagation();
                    ts.applyWidgetId(this, id);
                }).bind("applyWidgets" + namespace, function(e, callback) {
                    e.stopPropagation();
                    ts.applyWidget(this, false, callback);
                }).bind("refreshWidgets" + namespace, function(e, all, dontapply) {
                    e.stopPropagation();
                    ts.refreshWidgets(this, all, dontapply);
                }).bind("removeWidget" + namespace, function(e, name, refreshing) {
                    e.stopPropagation();
                    ts.removeWidget(this, name, refreshing);
                }).bind("destroy" + namespace, function(e, removeClasses, callback) {
                    e.stopPropagation();
                    ts.destroy(this, removeClasses, callback);
                }).bind("resetToLoadState" + namespace, function(e) {
                    e.stopPropagation();
                    ts.removeWidget(this, true, false);
                    var tmp = $.extend(true, {}, c.originalSettings);
                    c = $.extend(true, {}, ts.defaults, tmp);
                    c.originalSettings = tmp;
                    this.hasInitialized = false;
                    ts.setup(this, c);
                });
            },
            bindEvents: function(table, $headers, core) {
                table = $(table)[0];
                var tmp, c = table.config, namespace = c.namespace, downTarget = null;
                if (core !== true) {
                    $headers.addClass(namespace.slice(1) + "_extra_headers");
                    tmp = ts.getClosest($headers, "table");
                    if (tmp.length && tmp[0].nodeName === "TABLE" && tmp[0] !== table) {
                        $(tmp[0]).addClass(namespace.slice(1) + "_extra_table");
                    }
                }
                tmp = (c.pointerDown + " " + c.pointerUp + " " + c.pointerClick + " sort keyup ").replace(ts.regex.spaces, " ").split(" ").join(namespace + " ");
                $headers.find(c.selectorSort).add($headers.filter(c.selectorSort)).unbind(tmp).bind(tmp, function(e, external) {
                    var $cell, cell, temp, $target = $(e.target), type = " " + e.type + " ";
                    if ((e.which || e.button) !== 1 && !type.match(" " + c.pointerClick + " | sort | keyup ") || type === " keyup " && e.which !== ts.keyCodes.enter || type.match(" " + c.pointerClick + " ") && typeof e.which !== "undefined") {
                        return;
                    }
                    if (type.match(" " + c.pointerUp + " ") && downTarget !== e.target && external !== true) {
                        return;
                    }
                    if (type.match(" " + c.pointerDown + " ")) {
                        downTarget = e.target;
                        temp = $target.jquery.split(".");
                        if (temp[0] === "1" && temp[1] < 4) {
                            e.preventDefault();
                        }
                        return;
                    }
                    downTarget = null;
                    $cell = ts.getClosest($(this), "." + ts.css.header);
                    if (ts.regex.formElements.test(e.target.nodeName) || $target.hasClass(c.cssNoSort) || $target.parents("." + c.cssNoSort).length > 0 || $cell.hasClass("sorter-false") || $target.parents("button").length > 0) {
                        return !c.cancelSelection;
                    }
                    if (c.delayInit && ts.isEmptyObject(c.cache)) {
                        ts.buildCache(c);
                    }
                    c.last.clickedIndex = $cell.attr("data-column") || $cell.index();
                    cell = c.$headerIndexed[c.last.clickedIndex][0];
                    if (cell && !cell.sortDisabled) {
                        ts.initSort(c, cell, e);
                    }
                });
                if (c.cancelSelection) {
                    $headers.attr("unselectable", "on").bind("selectstart", false).css({
                        "user-select": "none",
                        MozUserSelect: "none"
                    });
                }
            },
            buildHeaders: function(c) {
                var $temp, icon, timer, indx;
                c.headerList = [];
                c.headerContent = [];
                c.sortVars = [];
                if (ts.debug(c, "core")) {
                    timer = new Date();
                }
                c.columns = ts.computeColumnIndex(c.$table.children("thead, tfoot").children("tr"));
                icon = c.cssIcon ? '<i class="' + (c.cssIcon === ts.css.icon ? ts.css.icon : c.cssIcon + " " + ts.css.icon) + '"></i>' : "";
                c.$headers = $($.map(c.$table.find(c.selectorHeaders), function(elem, index) {
                    var configHeaders, header, column, template, tmp, $elem = $(elem);
                    if (ts.getClosest($elem, "tr").hasClass(c.cssIgnoreRow)) {
                        return;
                    }
                    if (!/(th|td)/i.test(elem.nodeName)) {
                        tmp = ts.getClosest($elem, "th, td");
                        $elem.attr("data-column", tmp.attr("data-column"));
                    }
                    configHeaders = ts.getColumnData(c.table, c.headers, index, true);
                    c.headerContent[index] = $elem.html();
                    if (c.headerTemplate !== "" && !$elem.find("." + ts.css.headerIn).length) {
                        template = c.headerTemplate.replace(ts.regex.templateContent, $elem.html()).replace(ts.regex.templateIcon, $elem.find("." + ts.css.icon).length ? "" : icon);
                        if (c.onRenderTemplate) {
                            header = c.onRenderTemplate.apply($elem, [ index, template ]);
                            if (header && typeof header === "string") {
                                template = header;
                            }
                        }
                        $elem.html('<div class="' + ts.css.headerIn + '">' + template + "</div>");
                    }
                    if (c.onRenderHeader) {
                        c.onRenderHeader.apply($elem, [ index, c, c.$table ]);
                    }
                    column = parseInt($elem.attr("data-column"), 10);
                    elem.column = column;
                    tmp = ts.getOrder(ts.getData($elem, configHeaders, "sortInitialOrder") || c.sortInitialOrder);
                    c.sortVars[column] = {
                        count: -1,
                        order: tmp ? c.sortReset ? [ 1, 0, 2 ] : [ 1, 0 ] : c.sortReset ? [ 0, 1, 2 ] : [ 0, 1 ],
                        lockedOrder: false,
                        sortedBy: ""
                    };
                    tmp = ts.getData($elem, configHeaders, "lockedOrder") || false;
                    if (typeof tmp !== "undefined" && tmp !== false) {
                        c.sortVars[column].lockedOrder = true;
                        c.sortVars[column].order = ts.getOrder(tmp) ? [ 1, 1 ] : [ 0, 0 ];
                    }
                    c.headerList[index] = elem;
                    $elem.addClass(ts.css.header + " " + c.cssHeader);
                    ts.getClosest($elem, "tr").addClass(ts.css.headerRow + " " + c.cssHeaderRow).attr("role", "row");
                    if (c.tabIndex) {
                        $elem.attr("tabindex", 0);
                    }
                    return elem;
                }));
                c.$headerIndexed = [];
                for (indx = 0; indx < c.columns; indx++) {
                    if (ts.isEmptyObject(c.sortVars[indx])) {
                        c.sortVars[indx] = {};
                    }
                    $temp = c.$headers.filter('[data-column="' + indx + '"]');
                    c.$headerIndexed[indx] = $temp.length ? $temp.not(".sorter-false").length ? $temp.not(".sorter-false").filter(":last") : $temp.filter(":last") : $();
                }
                c.$table.find(c.selectorHeaders).attr({
                    scope: "col",
                    role: "columnheader"
                });
                ts.updateHeader(c);
                if (ts.debug(c, "core")) {
                    console.log("Built headers:" + ts.benchmark(timer));
                    console.log(c.$headers);
                }
            },
            addInstanceMethods: function(methods) {
                $.extend(ts.instanceMethods, methods);
            },
            setupParsers: function(c, $tbodies) {
                var rows, list, span, max, colIndex, indx, header, configHeaders, noParser, parser, extractor, time, tbody, len, table = c.table, tbodyIndex = 0, debug = ts.debug(c, "core"), debugOutput = {};
                c.$tbodies = c.$table.children("tbody:not(." + c.cssInfoBlock + ")");
                tbody = typeof $tbodies === "undefined" ? c.$tbodies : $tbodies;
                len = tbody.length;
                if (len === 0) {
                    return debug ? console.warn("Warning: *Empty table!* Not building a parser cache") : "";
                } else if (debug) {
                    time = new Date();
                    console[console.group ? "group" : "log"]("Detecting parsers for each column");
                }
                list = {
                    extractors: [],
                    parsers: []
                };
                while (tbodyIndex < len) {
                    rows = tbody[tbodyIndex].rows;
                    if (rows.length) {
                        colIndex = 0;
                        max = c.columns;
                        for (indx = 0; indx < max; indx++) {
                            header = c.$headerIndexed[colIndex];
                            if (header && header.length) {
                                configHeaders = ts.getColumnData(table, c.headers, colIndex);
                                extractor = ts.getParserById(ts.getData(header, configHeaders, "extractor"));
                                parser = ts.getParserById(ts.getData(header, configHeaders, "sorter"));
                                noParser = ts.getData(header, configHeaders, "parser") === "false";
                                c.empties[colIndex] = (ts.getData(header, configHeaders, "empty") || c.emptyTo || (c.emptyToBottom ? "bottom" : "top")).toLowerCase();
                                c.strings[colIndex] = (ts.getData(header, configHeaders, "string") || c.stringTo || "max").toLowerCase();
                                if (noParser) {
                                    parser = ts.getParserById("no-parser");
                                }
                                if (!extractor) {
                                    extractor = false;
                                }
                                if (!parser) {
                                    parser = ts.detectParserForColumn(c, rows, -1, colIndex);
                                }
                                if (debug) {
                                    debugOutput["(" + colIndex + ") " + header.text()] = {
                                        parser: parser.id,
                                        extractor: extractor ? extractor.id : "none",
                                        string: c.strings[colIndex],
                                        empty: c.empties[colIndex]
                                    };
                                }
                                list.parsers[colIndex] = parser;
                                list.extractors[colIndex] = extractor;
                                span = header[0].colSpan - 1;
                                if (span > 0) {
                                    colIndex += span;
                                    max += span;
                                    while (span + 1 > 0) {
                                        list.parsers[colIndex - span] = parser;
                                        list.extractors[colIndex - span] = extractor;
                                        span--;
                                    }
                                }
                            }
                            colIndex++;
                        }
                    }
                    tbodyIndex += list.parsers.length ? len : 1;
                }
                if (debug) {
                    if (!ts.isEmptyObject(debugOutput)) {
                        console[console.table ? "table" : "log"](debugOutput);
                    } else {
                        console.warn("  No parsers detected!");
                    }
                    console.log("Completed detecting parsers" + ts.benchmark(time));
                    if (console.groupEnd) {
                        console.groupEnd();
                    }
                }
                c.parsers = list.parsers;
                c.extractors = list.extractors;
            },
            addParser: function(parser) {
                var indx, len = ts.parsers.length, add = true;
                for (indx = 0; indx < len; indx++) {
                    if (ts.parsers[indx].id.toLowerCase() === parser.id.toLowerCase()) {
                        add = false;
                    }
                }
                if (add) {
                    ts.parsers[ts.parsers.length] = parser;
                }
            },
            getParserById: function(name) {
                if (name == "false") {
                    return false;
                }
                var indx, len = ts.parsers.length;
                for (indx = 0; indx < len; indx++) {
                    if (ts.parsers[indx].id.toLowerCase() === name.toString().toLowerCase()) {
                        return ts.parsers[indx];
                    }
                }
                return false;
            },
            detectParserForColumn: function(c, rows, rowIndex, cellIndex) {
                var cur, $node, row, indx = ts.parsers.length, node = false, nodeValue = "", debug = ts.debug(c, "core"), keepLooking = true;
                while (nodeValue === "" && keepLooking) {
                    rowIndex++;
                    row = rows[rowIndex];
                    if (row && rowIndex < 50) {
                        if (row.className.indexOf(ts.cssIgnoreRow) < 0) {
                            node = rows[rowIndex].cells[cellIndex];
                            nodeValue = ts.getElementText(c, node, cellIndex);
                            $node = $(node);
                            if (debug) {
                                console.log("Checking if value was empty on row " + rowIndex + ", column: " + cellIndex + ': "' + nodeValue + '"');
                            }
                        }
                    } else {
                        keepLooking = false;
                    }
                }
                while (--indx >= 0) {
                    cur = ts.parsers[indx];
                    if (cur && cur.id !== "text" && cur.is && cur.is(nodeValue, c.table, node, $node)) {
                        return cur;
                    }
                }
                return ts.getParserById("text");
            },
            getElementText: function(c, node, cellIndex) {
                if (!node) {
                    return "";
                }
                var tmp, extract = c.textExtraction || "", $node = node.jquery ? node : $(node);
                if (typeof extract === "string") {
                    if (extract === "basic" && typeof (tmp = $node.attr(c.textAttribute)) !== "undefined") {
                        return $.trim(tmp);
                    }
                    return $.trim(node.textContent || $node.text());
                } else {
                    if (typeof extract === "function") {
                        return $.trim(extract($node[0], c.table, cellIndex));
                    } else if (typeof (tmp = ts.getColumnData(c.table, extract, cellIndex)) === "function") {
                        return $.trim(tmp($node[0], c.table, cellIndex));
                    }
                }
                return $.trim($node[0].textContent || $node.text());
            },
            getParsedText: function(c, cell, colIndex, txt) {
                if (typeof txt === "undefined") {
                    txt = ts.getElementText(c, cell, colIndex);
                }
                var val = "" + txt, parser = c.parsers[colIndex], extractor = c.extractors[colIndex];
                if (parser) {
                    if (extractor && typeof extractor.format === "function") {
                        txt = extractor.format(txt, c.table, cell, colIndex);
                    }
                    val = parser.id === "no-parser" ? "" : parser.format("" + txt, c.table, cell, colIndex);
                    if (c.ignoreCase && typeof val === "string") {
                        val = val.toLowerCase();
                    }
                }
                return val;
            },
            buildCache: function(c, callback, $tbodies) {
                var cache, val, txt, rowIndex, colIndex, tbodyIndex, $tbody, $row, cols, $cells, cell, cacheTime, totalRows, rowData, prevRowData, colMax, span, cacheIndex, hasParser, max, len, index, table = c.table, parsers = c.parsers, debug = ts.debug(c, "core");
                c.$tbodies = c.$table.children("tbody:not(." + c.cssInfoBlock + ")");
                $tbody = typeof $tbodies === "undefined" ? c.$tbodies : $tbodies, c.cache = {};
                c.totalRows = 0;
                if (!parsers) {
                    return debug ? console.warn("Warning: *Empty table!* Not building a cache") : "";
                }
                if (debug) {
                    cacheTime = new Date();
                }
                if (c.showProcessing) {
                    ts.isProcessing(table, true);
                }
                for (tbodyIndex = 0; tbodyIndex < $tbody.length; tbodyIndex++) {
                    colMax = [];
                    cache = c.cache[tbodyIndex] = {
                        normalized: []
                    };
                    totalRows = $tbody[tbodyIndex] && $tbody[tbodyIndex].rows.length || 0;
                    for (rowIndex = 0; rowIndex < totalRows; ++rowIndex) {
                        rowData = {
                            child: [],
                            raw: []
                        };
                        $row = $($tbody[tbodyIndex].rows[rowIndex]);
                        cols = [];
                        if ($row.hasClass(c.selectorRemove.slice(1))) {
                            continue;
                        }
                        if ($row.hasClass(c.cssChildRow) && rowIndex !== 0) {
                            len = cache.normalized.length - 1;
                            prevRowData = cache.normalized[len][c.columns];
                            prevRowData.$row = prevRowData.$row.add($row);
                            if (!$row.prev().hasClass(c.cssChildRow)) {
                                $row.prev().addClass(ts.css.cssHasChild);
                            }
                            $cells = $row.children("th, td");
                            len = prevRowData.child.length;
                            prevRowData.child[len] = [];
                            cacheIndex = 0;
                            max = c.columns;
                            for (colIndex = 0; colIndex < max; colIndex++) {
                                cell = $cells[colIndex];
                                if (cell) {
                                    prevRowData.child[len][colIndex] = ts.getParsedText(c, cell, colIndex);
                                    span = $cells[colIndex].colSpan - 1;
                                    if (span > 0) {
                                        cacheIndex += span;
                                        max += span;
                                    }
                                }
                                cacheIndex++;
                            }
                            continue;
                        }
                        rowData.$row = $row;
                        rowData.order = rowIndex;
                        cacheIndex = 0;
                        max = c.columns;
                        for (colIndex = 0; colIndex < max; ++colIndex) {
                            cell = $row[0].cells[colIndex];
                            if (cell && cacheIndex < c.columns) {
                                hasParser = typeof parsers[cacheIndex] !== "undefined";
                                if (!hasParser && debug) {
                                    console.warn("No parser found for row: " + rowIndex + ", column: " + colIndex + '; cell containing: "' + $(cell).text() + '"; does it have a header?');
                                }
                                val = ts.getElementText(c, cell, cacheIndex);
                                rowData.raw[cacheIndex] = val;
                                txt = ts.getParsedText(c, cell, cacheIndex, val);
                                cols[cacheIndex] = txt;
                                if (hasParser && (parsers[cacheIndex].type || "").toLowerCase() === "numeric") {
                                    colMax[cacheIndex] = Math.max(Math.abs(txt) || 0, colMax[cacheIndex] || 0);
                                }
                                span = cell.colSpan - 1;
                                if (span > 0) {
                                    index = 0;
                                    while (index <= span) {
                                        txt = c.duplicateSpan || index === 0 ? txt : typeof c.textExtraction !== "string" ? ts.getElementText(c, cell, cacheIndex + index) || "" : "";
                                        rowData.raw[cacheIndex + index] = txt;
                                        cols[cacheIndex + index] = txt;
                                        index++;
                                    }
                                    cacheIndex += span;
                                    max += span;
                                }
                            }
                            cacheIndex++;
                        }
                        cols[c.columns] = rowData;
                        cache.normalized[cache.normalized.length] = cols;
                    }
                    cache.colMax = colMax;
                    c.totalRows += cache.normalized.length;
                }
                if (c.showProcessing) {
                    ts.isProcessing(table);
                }
                if (debug) {
                    len = Math.min(5, c.cache[0].normalized.length);
                    console[console.group ? "group" : "log"]("Building cache for " + c.totalRows + " rows (showing " + len + " rows in log) and " + c.columns + " columns" + ts.benchmark(cacheTime));
                    val = {};
                    for (colIndex = 0; colIndex < c.columns; colIndex++) {
                        for (cacheIndex = 0; cacheIndex < len; cacheIndex++) {
                            if (!val["row: " + cacheIndex]) {
                                val["row: " + cacheIndex] = {};
                            }
                            val["row: " + cacheIndex][c.$headerIndexed[colIndex].text()] = c.cache[0].normalized[cacheIndex][colIndex];
                        }
                    }
                    console[console.table ? "table" : "log"](val);
                    if (console.groupEnd) {
                        console.groupEnd();
                    }
                }
                if ($.isFunction(callback)) {
                    callback(table);
                }
            },
            getColumnText: function(table, column, callback, rowFilter) {
                table = $(table)[0];
                var tbodyIndex, rowIndex, cache, row, tbodyLen, rowLen, raw, parsed, $cell, result, hasCallback = typeof callback === "function", allColumns = column === "all", data = {
                    raw: [],
                    parsed: [],
                    $cell: []
                }, c = table.config;
                if (ts.isEmptyObject(c)) {
                    if (ts.debug(c, "core")) {
                        console.warn("No cache found - aborting getColumnText function!");
                    }
                } else {
                    tbodyLen = c.$tbodies.length;
                    for (tbodyIndex = 0; tbodyIndex < tbodyLen; tbodyIndex++) {
                        cache = c.cache[tbodyIndex].normalized;
                        rowLen = cache.length;
                        for (rowIndex = 0; rowIndex < rowLen; rowIndex++) {
                            row = cache[rowIndex];
                            if (rowFilter && !row[c.columns].$row.is(rowFilter)) {
                                continue;
                            }
                            result = true;
                            parsed = allColumns ? row.slice(0, c.columns) : row[column];
                            row = row[c.columns];
                            raw = allColumns ? row.raw : row.raw[column];
                            $cell = allColumns ? row.$row.children() : row.$row.children().eq(column);
                            if (hasCallback) {
                                result = callback({
                                    tbodyIndex: tbodyIndex,
                                    rowIndex: rowIndex,
                                    parsed: parsed,
                                    raw: raw,
                                    $row: row.$row,
                                    $cell: $cell
                                });
                            }
                            if (result !== false) {
                                data.parsed[data.parsed.length] = parsed;
                                data.raw[data.raw.length] = raw;
                                data.$cell[data.$cell.length] = $cell;
                            }
                        }
                    }
                    return data;
                }
            },
            setHeadersCss: function(c) {
                var indx, column, list = c.sortList, len = list.length, none = ts.css.sortNone + " " + c.cssNone, css = [ ts.css.sortAsc + " " + c.cssAsc, ts.css.sortDesc + " " + c.cssDesc ], cssIcon = [ c.cssIconAsc, c.cssIconDesc, c.cssIconNone ], aria = [ "ascending", "descending" ], updateColumnSort = function($el, index) {
                    $el.removeClass(none).addClass(css[index]).attr("aria-sort", aria[index]).find("." + ts.css.icon).removeClass(cssIcon[2]).addClass(cssIcon[index]);
                }, $extras = c.$table.find("tfoot tr").children("td, th").add($(c.namespace + "_extra_headers")).removeClass(css.join(" ")), $sorted = c.$headers.add($("thead " + c.namespace + "_extra_headers")).removeClass(css.join(" ")).addClass(none).attr("aria-sort", "none").find("." + ts.css.icon).removeClass(cssIcon.join(" ")).end();
                $sorted.not(".sorter-false").find("." + ts.css.icon).addClass(cssIcon[2]);
                if (c.cssIconDisabled) {
                    $sorted.filter(".sorter-false").find("." + ts.css.icon).addClass(c.cssIconDisabled);
                }
                for (indx = 0; indx < len; indx++) {
                    if (list[indx][1] !== 2) {
                        $sorted = c.$headers.filter(function(i) {
                            var include = true, $el = c.$headers.eq(i), col = parseInt($el.attr("data-column"), 10), end = col + ts.getClosest($el, "th, td")[0].colSpan;
                            for (;col < end; col++) {
                                include = include ? include || ts.isValueInArray(col, c.sortList) > -1 : false;
                            }
                            return include;
                        });
                        $sorted = $sorted.not(".sorter-false").filter('[data-column="' + list[indx][0] + '"]' + (len === 1 ? ":last" : ""));
                        if ($sorted.length) {
                            for (column = 0; column < $sorted.length; column++) {
                                if (!$sorted[column].sortDisabled) {
                                    updateColumnSort($sorted.eq(column), list[indx][1]);
                                }
                            }
                        }
                        if ($extras.length) {
                            updateColumnSort($extras.filter('[data-column="' + list[indx][0] + '"]'), list[indx][1]);
                        }
                    }
                }
                len = c.$headers.length;
                for (indx = 0; indx < len; indx++) {
                    ts.setColumnAriaLabel(c, c.$headers.eq(indx));
                }
            },
            getClosest: function($el, selector) {
                if ($.fn.closest) {
                    return $el.closest(selector);
                }
                return $el.is(selector) ? $el : $el.parents(selector).filter(":first");
            },
            setColumnAriaLabel: function(c, $header, nextSort) {
                if ($header.length) {
                    var column = parseInt($header.attr("data-column"), 10), vars = c.sortVars[column], tmp = $header.hasClass(ts.css.sortAsc) ? "sortAsc" : $header.hasClass(ts.css.sortDesc) ? "sortDesc" : "sortNone", txt = $.trim($header.text()) + ": " + ts.language[tmp];
                    if ($header.hasClass("sorter-false") || nextSort === false) {
                        txt += ts.language.sortDisabled;
                    } else {
                        tmp = (vars.count + 1) % vars.order.length;
                        nextSort = vars.order[tmp];
                        txt += ts.language[nextSort === 0 ? "nextAsc" : nextSort === 1 ? "nextDesc" : "nextNone"];
                    }
                    $header.attr("aria-label", txt);
                    if (vars.sortedBy) {
                        $header.attr("data-sortedBy", vars.sortedBy);
                    } else {
                        $header.removeAttr("data-sortedBy");
                    }
                }
            },
            updateHeader: function(c) {
                var index, isDisabled, $header, col, table = c.table, len = c.$headers.length;
                for (index = 0; index < len; index++) {
                    $header = c.$headers.eq(index);
                    col = ts.getColumnData(table, c.headers, index, true);
                    isDisabled = ts.getData($header, col, "sorter") === "false" || ts.getData($header, col, "parser") === "false";
                    ts.setColumnSort(c, $header, isDisabled);
                }
            },
            setColumnSort: function(c, $header, isDisabled) {
                var id = c.table.id;
                $header[0].sortDisabled = isDisabled;
                $header[isDisabled ? "addClass" : "removeClass"]("sorter-false").attr("aria-disabled", "" + isDisabled);
                if (c.tabIndex) {
                    if (isDisabled) {
                        $header.removeAttr("tabindex");
                    } else {
                        $header.attr("tabindex", "0");
                    }
                }
                if (id) {
                    if (isDisabled) {
                        $header.removeAttr("aria-controls");
                    } else {
                        $header.attr("aria-controls", id);
                    }
                }
            },
            updateHeaderSortCount: function(c, list) {
                var col, dir, group, indx, primary, temp, val, order, sortList = list || c.sortList, len = sortList.length;
                c.sortList = [];
                for (indx = 0; indx < len; indx++) {
                    val = sortList[indx];
                    col = parseInt(val[0], 10);
                    if (col < c.columns) {
                        if (!c.sortVars[col].order) {
                            if (ts.getOrder(c.sortInitialOrder)) {
                                order = c.sortReset ? [ 1, 0, 2 ] : [ 1, 0 ];
                            } else {
                                order = c.sortReset ? [ 0, 1, 2 ] : [ 0, 1 ];
                            }
                            c.sortVars[col].order = order;
                            c.sortVars[col].count = 0;
                        }
                        order = c.sortVars[col].order;
                        dir = ("" + val[1]).match(/^(1|d|s|o|n)/);
                        dir = dir ? dir[0] : "";
                        switch (dir) {
                          case "1":
                          case "d":
                            dir = 1;
                            break;

                          case "s":
                            dir = primary || 0;
                            break;

                          case "o":
                            temp = order[(primary || 0) % order.length];
                            dir = temp === 0 ? 1 : temp === 1 ? 0 : 2;
                            break;

                          case "n":
                            dir = order[++c.sortVars[col].count % order.length];
                            break;

                          default:
                            dir = 0;
                            break;
                        }
                        primary = indx === 0 ? dir : primary;
                        group = [ col, parseInt(dir, 10) || 0 ];
                        c.sortList[c.sortList.length] = group;
                        dir = $.inArray(group[1], order);
                        c.sortVars[col].count = dir >= 0 ? dir : group[1] % order.length;
                    }
                }
            },
            updateAll: function(c, resort, callback) {
                var table = c.table;
                table.isUpdating = true;
                ts.refreshWidgets(table, true, true);
                ts.buildHeaders(c);
                ts.bindEvents(table, c.$headers, true);
                ts.bindMethods(c);
                ts.commonUpdate(c, resort, callback);
            },
            update: function(c, resort, callback) {
                var table = c.table;
                table.isUpdating = true;
                ts.updateHeader(c);
                ts.commonUpdate(c, resort, callback);
            },
            updateHeaders: function(c, callback) {
                c.table.isUpdating = true;
                ts.buildHeaders(c);
                ts.bindEvents(c.table, c.$headers, true);
                ts.resortComplete(c, callback);
            },
            updateCell: function(c, cell, resort, callback) {
                if ($(cell).closest("tr").hasClass(c.cssChildRow)) {
                    console.warn('Tablesorter Warning! "updateCell" for child row content has been disabled, use "update" instead');
                    return;
                }
                if (ts.isEmptyObject(c.cache)) {
                    ts.updateHeader(c);
                    ts.commonUpdate(c, resort, callback);
                    return;
                }
                c.table.isUpdating = true;
                c.$table.find(c.selectorRemove).remove();
                var tmp, indx, row, icell, cache, len, $tbodies = c.$tbodies, $cell = $(cell), tbodyIndex = $tbodies.index(ts.getClosest($cell, "tbody")), tbcache = c.cache[tbodyIndex], $row = ts.getClosest($cell, "tr");
                cell = $cell[0];
                if ($tbodies.length && tbodyIndex >= 0) {
                    row = $tbodies.eq(tbodyIndex).find("tr").not("." + c.cssChildRow).index($row);
                    cache = tbcache.normalized[row];
                    len = $row[0].cells.length;
                    if (len !== c.columns) {
                        icell = 0;
                        tmp = false;
                        for (indx = 0; indx < len; indx++) {
                            if (!tmp && $row[0].cells[indx] !== cell) {
                                icell += $row[0].cells[indx].colSpan;
                            } else {
                                tmp = true;
                            }
                        }
                    } else {
                        icell = $cell.index();
                    }
                    tmp = ts.getElementText(c, cell, icell);
                    cache[c.columns].raw[icell] = tmp;
                    tmp = ts.getParsedText(c, cell, icell, tmp);
                    cache[icell] = tmp;
                    if ((c.parsers[icell].type || "").toLowerCase() === "numeric") {
                        tbcache.colMax[icell] = Math.max(Math.abs(tmp) || 0, tbcache.colMax[icell] || 0);
                    }
                    tmp = resort !== "undefined" ? resort : c.resort;
                    if (tmp !== false) {
                        ts.checkResort(c, tmp, callback);
                    } else {
                        ts.resortComplete(c, callback);
                    }
                } else {
                    if (ts.debug(c, "core")) {
                        console.error("updateCell aborted, tbody missing or not within the indicated table");
                    }
                    c.table.isUpdating = false;
                }
            },
            addRows: function(c, $row, resort, callback) {
                var txt, val, tbodyIndex, rowIndex, rows, cellIndex, len, order, cacheIndex, rowData, cells, cell, span, valid = typeof $row === "string" && c.$tbodies.length === 1 && /<tr/.test($row || ""), table = c.table;
                if (valid) {
                    $row = $($row);
                    c.$tbodies.append($row);
                } else if (!$row || !($row instanceof $) || ts.getClosest($row, "table")[0] !== c.table) {
                    if (ts.debug(c, "core")) {
                        console.error("addRows method requires (1) a jQuery selector reference to rows that have already " + "been added to the table, or (2) row HTML string to be added to a table with only one tbody");
                    }
                    return false;
                }
                table.isUpdating = true;
                if (ts.isEmptyObject(c.cache)) {
                    ts.updateHeader(c);
                    ts.commonUpdate(c, resort, callback);
                } else {
                    rows = $row.filter("tr").attr("role", "row").length;
                    tbodyIndex = c.$tbodies.index($row.parents("tbody").filter(":first"));
                    if (!(c.parsers && c.parsers.length)) {
                        ts.setupParsers(c);
                    }
                    for (rowIndex = 0; rowIndex < rows; rowIndex++) {
                        cacheIndex = 0;
                        len = $row[rowIndex].cells.length;
                        order = c.cache[tbodyIndex].normalized.length;
                        cells = [];
                        rowData = {
                            child: [],
                            raw: [],
                            $row: $row.eq(rowIndex),
                            order: order
                        };
                        for (cellIndex = 0; cellIndex < len; cellIndex++) {
                            cell = $row[rowIndex].cells[cellIndex];
                            txt = ts.getElementText(c, cell, cacheIndex);
                            rowData.raw[cacheIndex] = txt;
                            val = ts.getParsedText(c, cell, cacheIndex, txt);
                            cells[cacheIndex] = val;
                            if ((c.parsers[cacheIndex].type || "").toLowerCase() === "numeric") {
                                c.cache[tbodyIndex].colMax[cacheIndex] = Math.max(Math.abs(val) || 0, c.cache[tbodyIndex].colMax[cacheIndex] || 0);
                            }
                            span = cell.colSpan - 1;
                            if (span > 0) {
                                cacheIndex += span;
                            }
                            cacheIndex++;
                        }
                        cells[c.columns] = rowData;
                        c.cache[tbodyIndex].normalized[order] = cells;
                    }
                    ts.checkResort(c, resort, callback);
                }
            },
            updateCache: function(c, callback, $tbodies) {
                if (!(c.parsers && c.parsers.length)) {
                    ts.setupParsers(c, $tbodies);
                }
                ts.buildCache(c, callback, $tbodies);
            },
            appendCache: function(c, init) {
                var parsed, totalRows, $tbody, $curTbody, rowIndex, tbodyIndex, appendTime, table = c.table, $tbodies = c.$tbodies, rows = [], cache = c.cache;
                if (ts.isEmptyObject(cache)) {
                    return c.appender ? c.appender(table, rows) : table.isUpdating ? c.$table.triggerHandler("updateComplete", table) : "";
                }
                if (ts.debug(c, "core")) {
                    appendTime = new Date();
                }
                for (tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++) {
                    $tbody = $tbodies.eq(tbodyIndex);
                    if ($tbody.length) {
                        $curTbody = ts.processTbody(table, $tbody, true);
                        parsed = cache[tbodyIndex].normalized;
                        totalRows = parsed.length;
                        for (rowIndex = 0; rowIndex < totalRows; rowIndex++) {
                            rows[rows.length] = parsed[rowIndex][c.columns].$row;
                            if (!c.appender || c.pager && !c.pager.removeRows && !c.pager.ajax) {
                                $curTbody.append(parsed[rowIndex][c.columns].$row);
                            }
                        }
                        ts.processTbody(table, $curTbody, false);
                    }
                }
                if (c.appender) {
                    c.appender(table, rows);
                }
                if (ts.debug(c, "core")) {
                    console.log("Rebuilt table" + ts.benchmark(appendTime));
                }
                if (!init && !c.appender) {
                    ts.applyWidget(table);
                }
                if (table.isUpdating) {
                    c.$table.triggerHandler("updateComplete", table);
                }
            },
            commonUpdate: function(c, resort, callback) {
                c.$table.find(c.selectorRemove).remove();
                ts.setupParsers(c);
                ts.buildCache(c);
                ts.checkResort(c, resort, callback);
            },
            initSort: function(c, cell, event) {
                if (c.table.isUpdating) {
                    return setTimeout(function() {
                        ts.initSort(c, cell, event);
                    }, 50);
                }
                var arry, indx, headerIndx, dir, temp, tmp, $header, notMultiSort = !event[c.sortMultiSortKey], table = c.table, len = c.$headers.length, th = ts.getClosest($(cell), "th, td"), col = parseInt(th.attr("data-column"), 10), sortedBy = event.type === "mouseup" ? "user" : event.type, order = c.sortVars[col].order;
                th = th[0];
                c.$table.triggerHandler("sortStart", table);
                tmp = (c.sortVars[col].count + 1) % order.length;
                c.sortVars[col].count = event[c.sortResetKey] ? 2 : tmp;
                if (c.sortRestart) {
                    for (headerIndx = 0; headerIndx < len; headerIndx++) {
                        $header = c.$headers.eq(headerIndx);
                        tmp = parseInt($header.attr("data-column"), 10);
                        if (col !== tmp && (notMultiSort || $header.hasClass(ts.css.sortNone))) {
                            c.sortVars[tmp].count = -1;
                        }
                    }
                }
                if (notMultiSort) {
                    $.each(c.sortVars, function(i) {
                        c.sortVars[i].sortedBy = "";
                    });
                    c.sortList = [];
                    c.last.sortList = [];
                    if (c.sortForce !== null) {
                        arry = c.sortForce;
                        for (indx = 0; indx < arry.length; indx++) {
                            if (arry[indx][0] !== col) {
                                c.sortList[c.sortList.length] = arry[indx];
                                c.sortVars[arry[indx][0]].sortedBy = "sortForce";
                            }
                        }
                    }
                    dir = order[c.sortVars[col].count];
                    if (dir < 2) {
                        c.sortList[c.sortList.length] = [ col, dir ];
                        c.sortVars[col].sortedBy = sortedBy;
                        if (th.colSpan > 1) {
                            for (indx = 1; indx < th.colSpan; indx++) {
                                c.sortList[c.sortList.length] = [ col + indx, dir ];
                                c.sortVars[col + indx].count = $.inArray(dir, order);
                                c.sortVars[col + indx].sortedBy = sortedBy;
                            }
                        }
                    }
                } else {
                    c.sortList = $.extend([], c.last.sortList);
                    if (ts.isValueInArray(col, c.sortList) >= 0) {
                        c.sortVars[col].sortedBy = sortedBy;
                        for (indx = 0; indx < c.sortList.length; indx++) {
                            tmp = c.sortList[indx];
                            if (tmp[0] === col) {
                                tmp[1] = order[c.sortVars[col].count];
                                if (tmp[1] === 2) {
                                    c.sortList.splice(indx, 1);
                                    c.sortVars[col].count = -1;
                                }
                            }
                        }
                    } else {
                        dir = order[c.sortVars[col].count];
                        c.sortVars[col].sortedBy = sortedBy;
                        if (dir < 2) {
                            c.sortList[c.sortList.length] = [ col, dir ];
                            if (th.colSpan > 1) {
                                for (indx = 1; indx < th.colSpan; indx++) {
                                    c.sortList[c.sortList.length] = [ col + indx, dir ];
                                    c.sortVars[col + indx].count = $.inArray(dir, order);
                                    c.sortVars[col + indx].sortedBy = sortedBy;
                                }
                            }
                        }
                    }
                }
                c.last.sortList = $.extend([], c.sortList);
                if (c.sortList.length && c.sortAppend) {
                    arry = $.isArray(c.sortAppend) ? c.sortAppend : c.sortAppend[c.sortList[0][0]];
                    if (!ts.isEmptyObject(arry)) {
                        for (indx = 0; indx < arry.length; indx++) {
                            if (arry[indx][0] !== col && ts.isValueInArray(arry[indx][0], c.sortList) < 0) {
                                dir = arry[indx][1];
                                temp = ("" + dir).match(/^(a|d|s|o|n)/);
                                if (temp) {
                                    tmp = c.sortList[0][1];
                                    switch (temp[0]) {
                                      case "d":
                                        dir = 1;
                                        break;

                                      case "s":
                                        dir = tmp;
                                        break;

                                      case "o":
                                        dir = tmp === 0 ? 1 : 0;
                                        break;

                                      case "n":
                                        dir = (tmp + 1) % order.length;
                                        break;

                                      default:
                                        dir = 0;
                                        break;
                                    }
                                }
                                c.sortList[c.sortList.length] = [ arry[indx][0], dir ];
                                c.sortVars[arry[indx][0]].sortedBy = "sortAppend";
                            }
                        }
                    }
                }
                c.$table.triggerHandler("sortBegin", table);
                setTimeout(function() {
                    ts.setHeadersCss(c);
                    ts.multisort(c);
                    ts.appendCache(c);
                    c.$table.triggerHandler("sortBeforeEnd", table);
                    c.$table.triggerHandler("sortEnd", table);
                }, 1);
            },
            multisort: function(c) {
                var tbodyIndex, sortTime, colMax, rows, tmp, table = c.table, sorter = [], dir = 0, textSorter = c.textSorter || "", sortList = c.sortList, sortLen = sortList.length, len = c.$tbodies.length;
                if (c.serverSideSorting || ts.isEmptyObject(c.cache)) {
                    return;
                }
                if (ts.debug(c, "core")) {
                    sortTime = new Date();
                }
                if (typeof textSorter === "object") {
                    colMax = c.columns;
                    while (colMax--) {
                        tmp = ts.getColumnData(table, textSorter, colMax);
                        if (typeof tmp === "function") {
                            sorter[colMax] = tmp;
                        }
                    }
                }
                for (tbodyIndex = 0; tbodyIndex < len; tbodyIndex++) {
                    colMax = c.cache[tbodyIndex].colMax;
                    rows = c.cache[tbodyIndex].normalized;
                    rows.sort(function(a, b) {
                        var sortIndex, num, col, order, sort, x, y;
                        for (sortIndex = 0; sortIndex < sortLen; sortIndex++) {
                            col = sortList[sortIndex][0];
                            order = sortList[sortIndex][1];
                            dir = order === 0;
                            if (c.sortStable && a[col] === b[col] && sortLen === 1) {
                                return a[c.columns].order - b[c.columns].order;
                            }
                            num = /n/i.test(ts.getSortType(c.parsers, col));
                            if (num && c.strings[col]) {
                                if (typeof ts.string[c.strings[col]] === "boolean") {
                                    num = (dir ? 1 : -1) * (ts.string[c.strings[col]] ? -1 : 1);
                                } else {
                                    num = c.strings[col] ? ts.string[c.strings[col]] || 0 : 0;
                                }
                                sort = c.numberSorter ? c.numberSorter(a[col], b[col], dir, colMax[col], table) : ts["sortNumeric" + (dir ? "Asc" : "Desc")](a[col], b[col], num, colMax[col], col, c);
                            } else {
                                x = dir ? a : b;
                                y = dir ? b : a;
                                if (typeof textSorter === "function") {
                                    sort = textSorter(x[col], y[col], dir, col, table);
                                } else if (typeof sorter[col] === "function") {
                                    sort = sorter[col](x[col], y[col], dir, col, table);
                                } else {
                                    sort = ts["sortNatural" + (dir ? "Asc" : "Desc")](a[col] || "", b[col] || "", col, c);
                                }
                            }
                            if (sort) {
                                return sort;
                            }
                        }
                        return a[c.columns].order - b[c.columns].order;
                    });
                }
                if (ts.debug(c, "core")) {
                    console.log("Applying sort " + sortList.toString() + ts.benchmark(sortTime));
                }
            },
            resortComplete: function(c, callback) {
                if (c.table.isUpdating) {
                    c.$table.triggerHandler("updateComplete", c.table);
                }
                if ($.isFunction(callback)) {
                    callback(c.table);
                }
            },
            checkResort: function(c, resort, callback) {
                var sortList = $.isArray(resort) ? resort : c.sortList, resrt = typeof resort === "undefined" ? c.resort : resort;
                if (resrt !== false && !c.serverSideSorting && !c.table.isProcessing) {
                    if (sortList.length) {
                        ts.sortOn(c, sortList, function() {
                            ts.resortComplete(c, callback);
                        }, true);
                    } else {
                        ts.sortReset(c, function() {
                            ts.resortComplete(c, callback);
                            ts.applyWidget(c.table, false);
                        });
                    }
                } else {
                    ts.resortComplete(c, callback);
                    ts.applyWidget(c.table, false);
                }
            },
            sortOn: function(c, list, callback, init) {
                var indx, table = c.table;
                c.$table.triggerHandler("sortStart", table);
                for (indx = 0; indx < c.columns; indx++) {
                    c.sortVars[indx].sortedBy = ts.isValueInArray(indx, list) > -1 ? "sorton" : "";
                }
                ts.updateHeaderSortCount(c, list);
                ts.setHeadersCss(c);
                if (c.delayInit && ts.isEmptyObject(c.cache)) {
                    ts.buildCache(c);
                }
                c.$table.triggerHandler("sortBegin", table);
                ts.multisort(c);
                ts.appendCache(c, init);
                c.$table.triggerHandler("sortBeforeEnd", table);
                c.$table.triggerHandler("sortEnd", table);
                ts.applyWidget(table);
                if ($.isFunction(callback)) {
                    callback(table);
                }
            },
            sortReset: function(c, callback) {
                c.sortList = [];
                var indx;
                for (indx = 0; indx < c.columns; indx++) {
                    c.sortVars[indx].count = -1;
                    c.sortVars[indx].sortedBy = "";
                }
                ts.setHeadersCss(c);
                ts.multisort(c);
                ts.appendCache(c);
                if ($.isFunction(callback)) {
                    callback(c.table);
                }
            },
            getSortType: function(parsers, column) {
                return parsers && parsers[column] ? parsers[column].type || "" : "";
            },
            getOrder: function(val) {
                return /^d/i.test(val) || val === 1;
            },
            sortNatural: function(a, b) {
                if (a === b) {
                    return 0;
                }
                a = (a || "").toString();
                b = (b || "").toString();
                var aNum, bNum, aFloat, bFloat, indx, max, regex = ts.regex;
                if (regex.hex.test(b)) {
                    aNum = parseInt(a.match(regex.hex), 16);
                    bNum = parseInt(b.match(regex.hex), 16);
                    if (aNum < bNum) {
                        return -1;
                    }
                    if (aNum > bNum) {
                        return 1;
                    }
                }
                aNum = a.replace(regex.chunk, "\\0$1\\0").replace(regex.chunks, "").split("\\0");
                bNum = b.replace(regex.chunk, "\\0$1\\0").replace(regex.chunks, "").split("\\0");
                max = Math.max(aNum.length, bNum.length);
                for (indx = 0; indx < max; indx++) {
                    aFloat = isNaN(aNum[indx]) ? aNum[indx] || 0 : parseFloat(aNum[indx]) || 0;
                    bFloat = isNaN(bNum[indx]) ? bNum[indx] || 0 : parseFloat(bNum[indx]) || 0;
                    if (isNaN(aFloat) !== isNaN(bFloat)) {
                        return isNaN(aFloat) ? 1 : -1;
                    }
                    if (typeof aFloat !== typeof bFloat) {
                        aFloat += "";
                        bFloat += "";
                    }
                    if (aFloat < bFloat) {
                        return -1;
                    }
                    if (aFloat > bFloat) {
                        return 1;
                    }
                }
                return 0;
            },
            sortNaturalAsc: function(a, b, col, c) {
                if (a === b) {
                    return 0;
                }
                var empty = ts.string[c.empties[col] || c.emptyTo];
                if (a === "" && empty !== 0) {
                    return typeof empty === "boolean" ? empty ? -1 : 1 : -empty || -1;
                }
                if (b === "" && empty !== 0) {
                    return typeof empty === "boolean" ? empty ? 1 : -1 : empty || 1;
                }
                return ts.sortNatural(a, b);
            },
            sortNaturalDesc: function(a, b, col, c) {
                if (a === b) {
                    return 0;
                }
                var empty = ts.string[c.empties[col] || c.emptyTo];
                if (a === "" && empty !== 0) {
                    return typeof empty === "boolean" ? empty ? -1 : 1 : empty || 1;
                }
                if (b === "" && empty !== 0) {
                    return typeof empty === "boolean" ? empty ? 1 : -1 : -empty || -1;
                }
                return ts.sortNatural(b, a);
            },
            sortText: function(a, b) {
                return a > b ? 1 : a < b ? -1 : 0;
            },
            getTextValue: function(val, num, max) {
                if (max) {
                    var indx, len = val ? val.length : 0, n = max + num;
                    for (indx = 0; indx < len; indx++) {
                        n += val.charCodeAt(indx);
                    }
                    return num * n;
                }
                return 0;
            },
            sortNumericAsc: function(a, b, num, max, col, c) {
                if (a === b) {
                    return 0;
                }
                var empty = ts.string[c.empties[col] || c.emptyTo];
                if (a === "" && empty !== 0) {
                    return typeof empty === "boolean" ? empty ? -1 : 1 : -empty || -1;
                }
                if (b === "" && empty !== 0) {
                    return typeof empty === "boolean" ? empty ? 1 : -1 : empty || 1;
                }
                if (isNaN(a)) {
                    a = ts.getTextValue(a, num, max);
                }
                if (isNaN(b)) {
                    b = ts.getTextValue(b, num, max);
                }
                return a - b;
            },
            sortNumericDesc: function(a, b, num, max, col, c) {
                if (a === b) {
                    return 0;
                }
                var empty = ts.string[c.empties[col] || c.emptyTo];
                if (a === "" && empty !== 0) {
                    return typeof empty === "boolean" ? empty ? -1 : 1 : empty || 1;
                }
                if (b === "" && empty !== 0) {
                    return typeof empty === "boolean" ? empty ? 1 : -1 : -empty || -1;
                }
                if (isNaN(a)) {
                    a = ts.getTextValue(a, num, max);
                }
                if (isNaN(b)) {
                    b = ts.getTextValue(b, num, max);
                }
                return b - a;
            },
            sortNumeric: function(a, b) {
                return a - b;
            },
            addWidget: function(widget) {
                if (widget.id && !ts.isEmptyObject(ts.getWidgetById(widget.id))) {
                    console.warn('"' + widget.id + '" widget was loaded more than once!');
                }
                ts.widgets[ts.widgets.length] = widget;
            },
            hasWidget: function($table, name) {
                $table = $($table);
                return $table.length && $table[0].config && $table[0].config.widgetInit[name] || false;
            },
            getWidgetById: function(name) {
                var indx, widget, len = ts.widgets.length;
                for (indx = 0; indx < len; indx++) {
                    widget = ts.widgets[indx];
                    if (widget && widget.id && widget.id.toLowerCase() === name.toLowerCase()) {
                        return widget;
                    }
                }
            },
            applyWidgetOptions: function(table) {
                var indx, widget, wo, c = table.config, len = c.widgets.length;
                if (len) {
                    for (indx = 0; indx < len; indx++) {
                        widget = ts.getWidgetById(c.widgets[indx]);
                        if (widget && widget.options) {
                            wo = $.extend(true, {}, widget.options);
                            c.widgetOptions = $.extend(true, wo, c.widgetOptions);
                            $.extend(true, ts.defaults.widgetOptions, widget.options);
                        }
                    }
                }
            },
            addWidgetFromClass: function(table) {
                var len, indx, c = table.config, regex = "^" + c.widgetClass.replace(ts.regex.templateName, "(\\S+)+") + "$", widgetClass = new RegExp(regex, "g"), widgets = (table.className || "").split(ts.regex.spaces);
                if (widgets.length) {
                    len = widgets.length;
                    for (indx = 0; indx < len; indx++) {
                        if (widgets[indx].match(widgetClass)) {
                            c.widgets[c.widgets.length] = widgets[indx].replace(widgetClass, "$1");
                        }
                    }
                }
            },
            applyWidgetId: function(table, id, init) {
                table = $(table)[0];
                var applied, time, name, c = table.config, wo = c.widgetOptions, debug = ts.debug(c, "core"), widget = ts.getWidgetById(id);
                if (widget) {
                    name = widget.id;
                    applied = false;
                    if ($.inArray(name, c.widgets) < 0) {
                        c.widgets[c.widgets.length] = name;
                    }
                    if (debug) {
                        time = new Date();
                    }
                    if (init || !c.widgetInit[name]) {
                        c.widgetInit[name] = true;
                        if (table.hasInitialized) {
                            ts.applyWidgetOptions(table);
                        }
                        if (typeof widget.init === "function") {
                            applied = true;
                            if (debug) {
                                console[console.group ? "group" : "log"]("Initializing " + name + " widget");
                            }
                            widget.init(table, widget, c, wo);
                        }
                    }
                    if (!init && typeof widget.format === "function") {
                        applied = true;
                        if (debug) {
                            console[console.group ? "group" : "log"]("Updating " + name + " widget");
                        }
                        widget.format(table, c, wo, false);
                    }
                    if (debug) {
                        if (applied) {
                            console.log("Completed " + (init ? "initializing " : "applying ") + name + " widget" + ts.benchmark(time));
                            if (console.groupEnd) {
                                console.groupEnd();
                            }
                        }
                    }
                }
            },
            applyWidget: function(table, init, callback) {
                table = $(table)[0];
                var indx, len, names, widget, time, c = table.config, debug = ts.debug(c, "core"), widgets = [];
                if (init !== false && table.hasInitialized && (table.isApplyingWidgets || table.isUpdating)) {
                    return;
                }
                if (debug) {
                    time = new Date();
                }
                ts.addWidgetFromClass(table);
                clearTimeout(c.timerReady);
                if (c.widgets.length) {
                    table.isApplyingWidgets = true;
                    c.widgets = $.grep(c.widgets, function(val, index) {
                        return $.inArray(val, c.widgets) === index;
                    });
                    names = c.widgets || [];
                    len = names.length;
                    for (indx = 0; indx < len; indx++) {
                        widget = ts.getWidgetById(names[indx]);
                        if (widget && widget.id) {
                            if (!widget.priority) {
                                widget.priority = 10;
                            }
                            widgets[indx] = widget;
                        } else if (debug) {
                            console.warn('"' + names[indx] + '" was enabled, but the widget code has not been loaded!');
                        }
                    }
                    widgets.sort(function(a, b) {
                        return a.priority < b.priority ? -1 : a.priority === b.priority ? 0 : 1;
                    });
                    len = widgets.length;
                    if (debug) {
                        console[console.group ? "group" : "log"]("Start " + (init ? "initializing" : "applying") + " widgets");
                    }
                    for (indx = 0; indx < len; indx++) {
                        widget = widgets[indx];
                        if (widget && widget.id) {
                            ts.applyWidgetId(table, widget.id, init);
                        }
                    }
                    if (debug && console.groupEnd) {
                        console.groupEnd();
                    }
                }
                c.timerReady = setTimeout(function() {
                    table.isApplyingWidgets = false;
                    $.data(table, "lastWidgetApplication", new Date());
                    c.$table.triggerHandler("tablesorter-ready");
                    if (!init && typeof callback === "function") {
                        callback(table);
                    }
                    if (debug) {
                        widget = c.widgets.length;
                        console.log("Completed " + (init === true ? "initializing " : "applying ") + widget + " widget" + (widget !== 1 ? "s" : "") + ts.benchmark(time));
                    }
                }, 10);
            },
            removeWidget: function(table, name, refreshing) {
                table = $(table)[0];
                var index, widget, indx, len, c = table.config;
                if (name === true) {
                    name = [];
                    len = ts.widgets.length;
                    for (indx = 0; indx < len; indx++) {
                        widget = ts.widgets[indx];
                        if (widget && widget.id) {
                            name[name.length] = widget.id;
                        }
                    }
                } else {
                    name = ($.isArray(name) ? name.join(",") : name || "").toLowerCase().split(/[\s,]+/);
                }
                len = name.length;
                for (index = 0; index < len; index++) {
                    widget = ts.getWidgetById(name[index]);
                    indx = $.inArray(name[index], c.widgets);
                    if (indx >= 0 && refreshing !== true) {
                        c.widgets.splice(indx, 1);
                    }
                    if (widget && widget.remove) {
                        if (ts.debug(c, "core")) {
                            console.log((refreshing ? "Refreshing" : "Removing") + ' "' + name[index] + '" widget');
                        }
                        widget.remove(table, c, c.widgetOptions, refreshing);
                        c.widgetInit[name[index]] = false;
                    }
                }
                c.$table.triggerHandler("widgetRemoveEnd", table);
            },
            refreshWidgets: function(table, doAll, dontapply) {
                table = $(table)[0];
                var indx, widget, c = table.config, curWidgets = c.widgets, widgets = ts.widgets, len = widgets.length, list = [], callback = function(table) {
                    $(table).triggerHandler("refreshComplete");
                };
                for (indx = 0; indx < len; indx++) {
                    widget = widgets[indx];
                    if (widget && widget.id && (doAll || $.inArray(widget.id, curWidgets) < 0)) {
                        list[list.length] = widget.id;
                    }
                }
                ts.removeWidget(table, list.join(","), true);
                if (dontapply !== true) {
                    ts.applyWidget(table, doAll || false, callback);
                    if (doAll) {
                        ts.applyWidget(table, false, callback);
                    }
                } else {
                    callback(table);
                }
            },
            benchmark: function(diff) {
                return " (" + (new Date().getTime() - diff.getTime()) + " ms)";
            },
            log: function() {
                console.log(arguments);
            },
            debug: function(c, name) {
                return c && (c.debug === true || typeof c.debug === "string" && c.debug.indexOf(name) > -1);
            },
            isEmptyObject: function(obj) {
                for (var name in obj) {
                    return false;
                }
                return true;
            },
            isValueInArray: function(column, arry) {
                var indx, len = arry && arry.length || 0;
                for (indx = 0; indx < len; indx++) {
                    if (arry[indx][0] === column) {
                        return indx;
                    }
                }
                return -1;
            },
            formatFloat: function(str, table) {
                if (typeof str !== "string" || str === "") {
                    return str;
                }
                var num, usFormat = table && table.config ? table.config.usNumberFormat !== false : typeof table !== "undefined" ? table : true;
                if (usFormat) {
                    str = str.replace(ts.regex.comma, "");
                } else {
                    str = str.replace(ts.regex.digitNonUS, "").replace(ts.regex.comma, ".");
                }
                if (ts.regex.digitNegativeTest.test(str)) {
                    str = str.replace(ts.regex.digitNegativeReplace, "-$1");
                }
                num = parseFloat(str);
                return isNaN(num) ? $.trim(str) : num;
            },
            isDigit: function(str) {
                return isNaN(str) ? ts.regex.digitTest.test(str.toString().replace(ts.regex.digitReplace, "")) : str !== "";
            },
            computeColumnIndex: function($rows, c) {
                var i, j, k, l, cell, cells, rowIndex, rowSpan, colSpan, firstAvailCol, columns = c && c.columns || 0, matrix = [], matrixrow = new Array(columns);
                for (i = 0; i < $rows.length; i++) {
                    cells = $rows[i].cells;
                    for (j = 0; j < cells.length; j++) {
                        cell = cells[j];
                        rowIndex = i;
                        rowSpan = cell.rowSpan || 1;
                        colSpan = cell.colSpan || 1;
                        if (typeof matrix[rowIndex] === "undefined") {
                            matrix[rowIndex] = [];
                        }
                        for (k = 0; k < matrix[rowIndex].length + 1; k++) {
                            if (typeof matrix[rowIndex][k] === "undefined") {
                                firstAvailCol = k;
                                break;
                            }
                        }
                        if (columns && cell.cellIndex === firstAvailCol) {} else if (cell.setAttribute) {
                            cell.setAttribute("data-column", firstAvailCol);
                        } else {
                            $(cell).attr("data-column", firstAvailCol);
                        }
                        for (k = rowIndex; k < rowIndex + rowSpan; k++) {
                            if (typeof matrix[k] === "undefined") {
                                matrix[k] = [];
                            }
                            matrixrow = matrix[k];
                            for (l = firstAvailCol; l < firstAvailCol + colSpan; l++) {
                                matrixrow[l] = "x";
                            }
                        }
                    }
                }
                ts.checkColumnCount($rows, matrix, matrixrow.length);
                return matrixrow.length;
            },
            checkColumnCount: function($rows, matrix, columns) {
                var i, len, valid = true, cells = [];
                for (i = 0; i < matrix.length; i++) {
                    if (matrix[i]) {
                        len = matrix[i].length;
                        if (matrix[i].length !== columns) {
                            valid = false;
                            break;
                        }
                    }
                }
                if (!valid) {
                    $rows.each(function(indx, el) {
                        var cell = el.parentElement.nodeName;
                        if (cells.indexOf(cell) < 0) {
                            cells.push(cell);
                        }
                    });
                    console.error("Invalid or incorrect number of columns in the " + cells.join(" or ") + "; expected " + columns + ", but found " + len + " columns");
                }
            },
            fixColumnWidth: function(table) {
                table = $(table)[0];
                var overallWidth, percent, $tbodies, len, index, c = table.config, $colgroup = c.$table.children("colgroup");
                if ($colgroup.length && $colgroup.hasClass(ts.css.colgroup)) {
                    $colgroup.remove();
                }
                if (c.widthFixed && c.$table.children("colgroup").length === 0) {
                    $colgroup = $('<colgroup class="' + ts.css.colgroup + '">');
                    overallWidth = c.$table.width();
                    $tbodies = c.$tbodies.find("tr:first").children(":visible");
                    len = $tbodies.length;
                    for (index = 0; index < len; index++) {
                        percent = parseInt($tbodies.eq(index).width() / overallWidth * 1e3, 10) / 10 + "%";
                        $colgroup.append($("<col>").css("width", percent));
                    }
                    c.$table.prepend($colgroup);
                }
            },
            getData: function(header, configHeader, key) {
                var meta, cl4ss, val = "", $header = $(header);
                if (!$header.length) {
                    return "";
                }
                meta = $.metadata ? $header.metadata() : false;
                cl4ss = " " + ($header.attr("class") || "");
                if (typeof $header.data(key) !== "undefined" || typeof $header.data(key.toLowerCase()) !== "undefined") {
                    val += $header.data(key) || $header.data(key.toLowerCase());
                } else if (meta && typeof meta[key] !== "undefined") {
                    val += meta[key];
                } else if (configHeader && typeof configHeader[key] !== "undefined") {
                    val += configHeader[key];
                } else if (cl4ss !== " " && cl4ss.match(" " + key + "-")) {
                    val = cl4ss.match(new RegExp("\\s" + key + "-([\\w-]+)"))[1] || "";
                }
                return $.trim(val);
            },
            getColumnData: function(table, obj, indx, getCell, $headers) {
                if (typeof obj !== "object" || obj === null) {
                    return obj;
                }
                table = $(table)[0];
                var $header, key, c = table.config, $cells = $headers || c.$headers, $cell = c.$headerIndexed && c.$headerIndexed[indx] || $cells.find('[data-column="' + indx + '"]:last');
                if (typeof obj[indx] !== "undefined") {
                    return getCell ? obj[indx] : obj[$cells.index($cell)];
                }
                for (key in obj) {
                    if (typeof key === "string") {
                        $header = $cell.filter(key).add($cell.find(key));
                        if ($header.length) {
                            return obj[key];
                        }
                    }
                }
                return;
            },
            isProcessing: function($table, toggle, $headers) {
                $table = $($table);
                var c = $table[0].config, $header = $headers || $table.find("." + ts.css.header);
                if (toggle) {
                    if (typeof $headers !== "undefined" && c.sortList.length > 0) {
                        $header = $header.filter(function() {
                            return this.sortDisabled ? false : ts.isValueInArray(parseFloat($(this).attr("data-column")), c.sortList) >= 0;
                        });
                    }
                    $table.add($header).addClass(ts.css.processing + " " + c.cssProcessing);
                } else {
                    $table.add($header).removeClass(ts.css.processing + " " + c.cssProcessing);
                }
            },
            processTbody: function(table, $tb, getIt) {
                table = $(table)[0];
                if (getIt) {
                    table.isProcessing = true;
                    $tb.before('<colgroup class="tablesorter-savemyplace"/>');
                    return $.fn.detach ? $tb.detach() : $tb.remove();
                }
                var holdr = $(table).find("colgroup.tablesorter-savemyplace");
                $tb.insertAfter(holdr);
                holdr.remove();
                table.isProcessing = false;
            },
            clearTableBody: function(table) {
                $(table)[0].config.$tbodies.children().detach();
            },
            characterEquivalents: {
                a: "",
                A: "",
                c: "",
                C: "",
                e: "",
                E: "",
                i: "",
                I: "",
                o: "",
                O: "",
                ss: "",
                SS: "",
                u: "",
                U: ""
            },
            replaceAccents: function(str) {
                var chr, acc = "[", eq = ts.characterEquivalents;
                if (!ts.characterRegex) {
                    ts.characterRegexArray = {};
                    for (chr in eq) {
                        if (typeof chr === "string") {
                            acc += eq[chr];
                            ts.characterRegexArray[chr] = new RegExp("[" + eq[chr] + "]", "g");
                        }
                    }
                    ts.characterRegex = new RegExp(acc + "]");
                }
                if (ts.characterRegex.test(str)) {
                    for (chr in eq) {
                        if (typeof chr === "string") {
                            str = str.replace(ts.characterRegexArray[chr], chr);
                        }
                    }
                }
                return str;
            },
            validateOptions: function(c) {
                var setting, setting2, typ, timer, ignore = "headers sortForce sortList sortAppend widgets".split(" "), orig = c.originalSettings;
                if (orig) {
                    if (ts.debug(c, "core")) {
                        timer = new Date();
                    }
                    for (setting in orig) {
                        typ = typeof ts.defaults[setting];
                        if (typ === "undefined") {
                            console.warn('Tablesorter Warning! "table.config.' + setting + '" option not recognized');
                        } else if (typ === "object") {
                            for (setting2 in orig[setting]) {
                                typ = ts.defaults[setting] && typeof ts.defaults[setting][setting2];
                                if ($.inArray(setting, ignore) < 0 && typ === "undefined") {
                                    console.warn('Tablesorter Warning! "table.config.' + setting + "." + setting2 + '" option not recognized');
                                }
                            }
                        }
                    }
                    if (ts.debug(c, "core")) {
                        console.log("validate options time:" + ts.benchmark(timer));
                    }
                }
            },
            restoreHeaders: function(table) {
                var index, $cell, c = $(table)[0].config, $headers = c.$table.find(c.selectorHeaders), len = $headers.length;
                for (index = 0; index < len; index++) {
                    $cell = $headers.eq(index);
                    if ($cell.find("." + ts.css.headerIn).length) {
                        $cell.html(c.headerContent[index]);
                    }
                }
            },
            destroy: function(table, removeClasses, callback) {
                table = $(table)[0];
                if (!table.hasInitialized) {
                    return;
                }
                ts.removeWidget(table, true, false);
                var events, $t = $(table), c = table.config, $h = $t.find("thead:first"), $r = $h.find("tr." + ts.css.headerRow).removeClass(ts.css.headerRow + " " + c.cssHeaderRow), $f = $t.find("tfoot:first > tr").children("th, td");
                if (removeClasses === false && $.inArray("uitheme", c.widgets) >= 0) {
                    $t.triggerHandler("applyWidgetId", [ "uitheme" ]);
                    $t.triggerHandler("applyWidgetId", [ "zebra" ]);
                }
                $h.find("tr").not($r).remove();
                events = "sortReset update updateRows updateAll updateHeaders updateCell addRows updateComplete sorton " + "appendCache updateCache applyWidgetId applyWidgets refreshWidgets removeWidget destroy mouseup mouseleave " + "keypress sortBegin sortEnd resetToLoadState ".split(" ").join(c.namespace + " ");
                $t.removeData("tablesorter").unbind(events.replace(ts.regex.spaces, " "));
                c.$headers.add($f).removeClass([ ts.css.header, c.cssHeader, c.cssAsc, c.cssDesc, ts.css.sortAsc, ts.css.sortDesc, ts.css.sortNone ].join(" ")).removeAttr("data-column").removeAttr("aria-label").attr("aria-disabled", "true");
                $r.find(c.selectorSort).unbind("mousedown mouseup keypress ".split(" ").join(c.namespace + " ").replace(ts.regex.spaces, " "));
                ts.restoreHeaders(table);
                $t.toggleClass(ts.css.table + " " + c.tableClass + " tablesorter-" + c.theme, removeClasses === false);
                $t.removeClass(c.namespace.slice(1));
                table.hasInitialized = false;
                delete table.config.cache;
                if (typeof callback === "function") {
                    callback(table);
                }
                if (ts.debug(c, "core")) {
                    console.log("tablesorter has been removed");
                }
            }
        };
        $.fn.tablesorter = function(settings) {
            return this.each(function() {
                var table = this, c = $.extend(true, {}, ts.defaults, settings, ts.instanceMethods);
                c.originalSettings = settings;
                if (!table.hasInitialized && ts.buildTable && this.nodeName !== "TABLE") {
                    ts.buildTable(table, c);
                } else {
                    ts.setup(table, c);
                }
            });
        };
        if (!(window.console && window.console.log)) {
            ts.logs = [];
            console = {};
            console.log = console.warn = console.error = console.table = function() {
                var arg = arguments.length > 1 ? arguments : arguments[0];
                ts.logs[ts.logs.length] = {
                    date: Date.now(),
                    log: arg
                };
            };
        }
        ts.addParser({
            id: "no-parser",
            is: function() {
                return false;
            },
            format: function() {
                return "";
            },
            type: "text"
        });
        ts.addParser({
            id: "text",
            is: function() {
                return true;
            },
            format: function(str, table) {
                var c = table.config;
                if (str) {
                    str = $.trim(c.ignoreCase ? str.toLocaleLowerCase() : str);
                    str = c.sortLocaleCompare ? ts.replaceAccents(str) : str;
                }
                return str;
            },
            type: "text"
        });
        ts.regex.nondigit = /[^\w,. \-()]/g;
        ts.addParser({
            id: "digit",
            is: function(str) {
                return ts.isDigit(str);
            },
            format: function(str, table) {
                var num = ts.formatFloat((str || "").replace(ts.regex.nondigit, ""), table);
                return str && typeof num === "number" ? num : str ? $.trim(str && table.config.ignoreCase ? str.toLocaleLowerCase() : str) : str;
            },
            type: "numeric"
        });
        ts.regex.currencyReplace = /[+\-,. ]/g;
        ts.regex.currencyTest = /^\(?\d+[\u00a3$\u20ac\u00a4\u00a5\u00a2?.]|[\u00a3$\u20ac\u00a4\u00a5\u00a2?.]\d+\)?$/;
        ts.addParser({
            id: "currency",
            is: function(str) {
                str = (str || "").replace(ts.regex.currencyReplace, "");
                return ts.regex.currencyTest.test(str);
            },
            format: function(str, table) {
                var num = ts.formatFloat((str || "").replace(ts.regex.nondigit, ""), table);
                return str && typeof num === "number" ? num : str ? $.trim(str && table.config.ignoreCase ? str.toLocaleLowerCase() : str) : str;
            },
            type: "numeric"
        });
        ts.regex.urlProtocolTest = /^(https?|ftp|file):\/\//;
        ts.regex.urlProtocolReplace = /(https?|ftp|file):\/\/(www\.)?/;
        ts.addParser({
            id: "url",
            is: function(str) {
                return ts.regex.urlProtocolTest.test(str);
            },
            format: function(str) {
                return str ? $.trim(str.replace(ts.regex.urlProtocolReplace, "")) : str;
            },
            type: "text"
        });
        ts.regex.dash = /-/g;
        ts.regex.isoDate = /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}/;
        ts.addParser({
            id: "isoDate",
            is: function(str) {
                return ts.regex.isoDate.test(str);
            },
            format: function(str) {
                var date = str ? new Date(str.replace(ts.regex.dash, "/")) : str;
                return date instanceof Date && isFinite(date) ? date.getTime() : str;
            },
            type: "numeric"
        });
        ts.regex.percent = /%/g;
        ts.regex.percentTest = /(\d\s*?%|%\s*?\d)/;
        ts.addParser({
            id: "percent",
            is: function(str) {
                return ts.regex.percentTest.test(str) && str.length < 15;
            },
            format: function(str, table) {
                return str ? ts.formatFloat(str.replace(ts.regex.percent, ""), table) : str;
            },
            type: "numeric"
        });
        ts.addParser({
            id: "image",
            is: function(str, table, node, $node) {
                return $node.find("img").length > 0;
            },
            format: function(str, table, cell) {
                return $(cell).find("img").attr(table.config.imgAttr || "alt") || str;
            },
            parsed: true,
            type: "text"
        });
        ts.regex.dateReplace = /(\S)([AP]M)$/i;
        ts.regex.usLongDateTest1 = /^[A-Z]{3,10}\.?\s+\d{1,2},?\s+(\d{4})(\s+\d{1,2}:\d{2}(:\d{2})?(\s+[AP]M)?)?$/i;
        ts.regex.usLongDateTest2 = /^\d{1,2}\s+[A-Z]{3,10}\s+\d{4}/i;
        ts.addParser({
            id: "usLongDate",
            is: function(str) {
                return ts.regex.usLongDateTest1.test(str) || ts.regex.usLongDateTest2.test(str);
            },
            format: function(str) {
                var date = str ? new Date(str.replace(ts.regex.dateReplace, "$1 $2")) : str;
                return date instanceof Date && isFinite(date) ? date.getTime() : str;
            },
            type: "numeric"
        });
        ts.regex.shortDateTest = /(^\d{1,2}[\/\s]\d{1,2}[\/\s]\d{4})|(^\d{4}[\/\s]\d{1,2}[\/\s]\d{1,2})/;
        ts.regex.shortDateReplace = /[\-.,]/g;
        ts.regex.shortDateXXY = /(\d{1,2})[\/\s](\d{1,2})[\/\s](\d{4})/;
        ts.regex.shortDateYMD = /(\d{4})[\/\s](\d{1,2})[\/\s](\d{1,2})/;
        ts.convertFormat = function(dateString, format) {
            dateString = (dateString || "").replace(ts.regex.spaces, " ").replace(ts.regex.shortDateReplace, "/");
            if (format === "mmddyyyy") {
                dateString = dateString.replace(ts.regex.shortDateXXY, "$3/$1/$2");
            } else if (format === "ddmmyyyy") {
                dateString = dateString.replace(ts.regex.shortDateXXY, "$3/$2/$1");
            } else if (format === "yyyymmdd") {
                dateString = dateString.replace(ts.regex.shortDateYMD, "$1/$2/$3");
            }
            var date = new Date(dateString);
            return date instanceof Date && isFinite(date) ? date.getTime() : "";
        };
        ts.addParser({
            id: "shortDate",
            is: function(str) {
                str = (str || "").replace(ts.regex.spaces, " ").replace(ts.regex.shortDateReplace, "/");
                return ts.regex.shortDateTest.test(str);
            },
            format: function(str, table, cell, cellIndex) {
                if (str) {
                    var c = table.config, $header = c.$headerIndexed[cellIndex], format = $header.length && $header.data("dateFormat") || ts.getData($header, ts.getColumnData(table, c.headers, cellIndex), "dateFormat") || c.dateFormat;
                    if ($header.length) {
                        $header.data("dateFormat", format);
                    }
                    return ts.convertFormat(str, format) || str;
                }
                return str;
            },
            type: "numeric"
        });
        ts.regex.timeTest = /^(0?[1-9]|1[0-2]):([0-5]\d)(\s[AP]M)$|^((?:[01]\d|[2][0-4]):[0-5]\d)$/i;
        ts.regex.timeMatch = /(0?[1-9]|1[0-2]):([0-5]\d)(\s[AP]M)|((?:[01]\d|[2][0-4]):[0-5]\d)/i;
        ts.addParser({
            id: "time",
            is: function(str) {
                return ts.regex.timeTest.test(str);
            },
            format: function(str) {
                var temp, timePart = (str || "").match(ts.regex.timeMatch), orig = new Date(str), time = str && (timePart !== null ? timePart[0] : "00:00 AM"), date = time ? new Date("2000/01/01 " + time.replace(ts.regex.dateReplace, "$1 $2")) : time;
                if (date instanceof Date && isFinite(date)) {
                    temp = orig instanceof Date && isFinite(orig) ? orig.getTime() : 0;
                    return temp ? parseFloat(date.getTime() + "." + orig.getTime()) : date.getTime();
                }
                return str;
            },
            type: "numeric"
        });
        ts.addParser({
            id: "metadata",
            is: function() {
                return false;
            },
            format: function(str, table, cell) {
                var c = table.config, p = !c.parserMetadataName ? "sortValue" : c.parserMetadataName;
                return $(cell).metadata()[p];
            },
            type: "numeric"
        });
        ts.addWidget({
            id: "zebra",
            priority: 90,
            format: function(table, c, wo) {
                var $visibleRows, $row, count, isEven, tbodyIndex, rowIndex, len, child = new RegExp(c.cssChildRow, "i"), $tbodies = c.$tbodies.add($(c.namespace + "_extra_table").children("tbody:not(." + c.cssInfoBlock + ")"));
                for (tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++) {
                    count = 0;
                    $visibleRows = $tbodies.eq(tbodyIndex).children("tr:visible").not(c.selectorRemove);
                    len = $visibleRows.length;
                    for (rowIndex = 0; rowIndex < len; rowIndex++) {
                        $row = $visibleRows.eq(rowIndex);
                        if (!child.test($row[0].className)) {
                            count++;
                        }
                        isEven = count % 2 === 0;
                        $row.removeClass(wo.zebra[isEven ? 1 : 0]).addClass(wo.zebra[isEven ? 0 : 1]);
                    }
                }
            },
            remove: function(table, c, wo, refreshing) {
                if (refreshing) {
                    return;
                }
                var tbodyIndex, $tbody, $tbodies = c.$tbodies, toRemove = (wo.zebra || [ "even", "odd" ]).join(" ");
                for (tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++) {
                    $tbody = ts.processTbody(table, $tbodies.eq(tbodyIndex), true);
                    $tbody.children().removeClass(toRemove);
                    ts.processTbody(table, $tbody, false);
                }
            }
        });
    })(jQuery);
    (function($, window, document) {
        "use strict";
        var ts = $.tablesorter || {};
        $.extend(true, ts.defaults, {
            fixedUrl: "",
            widgetOptions: {
                storage_fixedUrl: "",
                storage_group: "",
                storage_page: "",
                storage_storageType: "",
                storage_tableId: "",
                storage_useSessionStorage: ""
            }
        });
        ts.storage = function(table, key, value, options) {
            table = $(table)[0];
            var cookieIndex, cookies, date, hasStorage = false, values = {}, c = table.config, wo = c && c.widgetOptions, debug = ts.debug(c, "storage"), storageType = (options && options.storageType || wo && wo.storage_storageType).toString().charAt(0).toLowerCase(), session = storageType ? "" : options && options.useSessionStorage || wo && wo.storage_useSessionStorage, $table = $(table), id = options && options.id || $table.attr(options && options.group || wo && wo.storage_group || "data-table-group") || wo && wo.storage_tableId || table.id || $(".tablesorter").index($table), url = options && options.url || $table.attr(options && options.page || wo && wo.storage_page || "data-table-page") || wo && wo.storage_fixedUrl || c && c.fixedUrl || window.location.pathname;
            if (storageType !== "c") {
                storageType = storageType === "s" || session ? "sessionStorage" : "localStorage";
                if (storageType in window) {
                    try {
                        window[storageType].setItem("_tmptest", "temp");
                        hasStorage = true;
                        window[storageType].removeItem("_tmptest");
                    } catch (error) {
                        console.warn(storageType + " is not supported in this browser");
                    }
                }
            }
            if (debug) {
                console.log("Storage >> Using", hasStorage ? storageType : "cookies");
            }
            if ($.parseJSON) {
                if (hasStorage) {
                    values = $.parseJSON(window[storageType][key] || "null") || {};
                } else {
                    cookies = document.cookie.split(/[;\s|=]/);
                    cookieIndex = $.inArray(key, cookies) + 1;
                    values = cookieIndex !== 0 ? $.parseJSON(cookies[cookieIndex] || "null") || {} : {};
                }
            }
            if (typeof value !== "undefined" && window.JSON && JSON.hasOwnProperty("stringify")) {
                if (!values[url]) {
                    values[url] = {};
                }
                values[url][id] = value;
                if (hasStorage) {
                    window[storageType][key] = JSON.stringify(values);
                } else {
                    date = new Date();
                    date.setTime(date.getTime() + 31536e6);
                    document.cookie = key + "=" + JSON.stringify(values).replace(/\"/g, '"') + "; expires=" + date.toGMTString() + "; path=/";
                }
            } else {
                return values && values[url] ? values[url][id] : "";
            }
        };
    })(jQuery, window, document);
    (function($) {
        "use strict";
        var ts = $.tablesorter || {};
        ts.themes = {
            bootstrap: {
                table: "table table-bordered table-striped",
                caption: "caption",
                header: "bootstrap-header",
                sortNone: "",
                sortAsc: "",
                sortDesc: "",
                active: "",
                hover: "",
                icons: "",
                iconSortNone: "bootstrap-icon-unsorted",
                iconSortAsc: "glyphicon glyphicon-chevron-up",
                iconSortDesc: "glyphicon glyphicon-chevron-down",
                filterRow: "",
                footerRow: "",
                footerCells: "",
                even: "",
                odd: ""
            },
            jui: {
                table: "ui-widget ui-widget-content ui-corner-all",
                caption: "ui-widget-content",
                header: "ui-widget-header ui-corner-all ui-state-default",
                sortNone: "",
                sortAsc: "",
                sortDesc: "",
                active: "ui-state-active",
                hover: "ui-state-hover",
                icons: "ui-icon",
                iconSortNone: "ui-icon-carat-2-n-s ui-icon-caret-2-n-s",
                iconSortAsc: "ui-icon-carat-1-n ui-icon-caret-1-n",
                iconSortDesc: "ui-icon-carat-1-s ui-icon-caret-1-s",
                filterRow: "",
                footerRow: "",
                footerCells: "",
                even: "ui-widget-content",
                odd: "ui-state-default"
            }
        };
        $.extend(ts.css, {
            wrapper: "tablesorter-wrapper"
        });
        ts.addWidget({
            id: "uitheme",
            priority: 10,
            format: function(table, c, wo) {
                var i, tmp, hdr, icon, time, $header, $icon, $tfoot, $h, oldtheme, oldremove, oldIconRmv, hasOldTheme, themesAll = ts.themes, $table = c.$table.add($(c.namespace + "_extra_table")), $headers = c.$headers.add($(c.namespace + "_extra_headers")), theme = c.theme || "jui", themes = themesAll[theme] || {}, remove = $.trim([ themes.sortNone, themes.sortDesc, themes.sortAsc, themes.active ].join(" ")), iconRmv = $.trim([ themes.iconSortNone, themes.iconSortDesc, themes.iconSortAsc ].join(" ")), debug = ts.debug(c, "uitheme");
                if (debug) {
                    time = new Date();
                }
                if (!$table.hasClass("tablesorter-" + theme) || c.theme !== c.appliedTheme || !wo.uitheme_applied) {
                    wo.uitheme_applied = true;
                    oldtheme = themesAll[c.appliedTheme] || {};
                    hasOldTheme = !$.isEmptyObject(oldtheme);
                    oldremove = hasOldTheme ? [ oldtheme.sortNone, oldtheme.sortDesc, oldtheme.sortAsc, oldtheme.active ].join(" ") : "";
                    oldIconRmv = hasOldTheme ? [ oldtheme.iconSortNone, oldtheme.iconSortDesc, oldtheme.iconSortAsc ].join(" ") : "";
                    if (hasOldTheme) {
                        wo.zebra[0] = $.trim(" " + wo.zebra[0].replace(" " + oldtheme.even, ""));
                        wo.zebra[1] = $.trim(" " + wo.zebra[1].replace(" " + oldtheme.odd, ""));
                        c.$tbodies.children().removeClass([ oldtheme.even, oldtheme.odd ].join(" "));
                    }
                    if (themes.even) {
                        wo.zebra[0] += " " + themes.even;
                    }
                    if (themes.odd) {
                        wo.zebra[1] += " " + themes.odd;
                    }
                    $table.children("caption").removeClass(oldtheme.caption || "").addClass(themes.caption);
                    $tfoot = $table.removeClass((c.appliedTheme ? "tablesorter-" + (c.appliedTheme || "") : "") + " " + (oldtheme.table || "")).addClass("tablesorter-" + theme + " " + (themes.table || "")).children("tfoot");
                    c.appliedTheme = c.theme;
                    if ($tfoot.length) {
                        $tfoot.children("tr").removeClass(oldtheme.footerRow || "").addClass(themes.footerRow).children("th, td").removeClass(oldtheme.footerCells || "").addClass(themes.footerCells);
                    }
                    $headers.removeClass((hasOldTheme ? [ oldtheme.header, oldtheme.hover, oldremove ].join(" ") : "") || "").addClass(themes.header).not(".sorter-false").unbind("mouseenter.tsuitheme mouseleave.tsuitheme").bind("mouseenter.tsuitheme mouseleave.tsuitheme", function(event) {
                        $(this)[event.type === "mouseenter" ? "addClass" : "removeClass"](themes.hover || "");
                    });
                    $headers.each(function() {
                        var $this = $(this);
                        if (!$this.find("." + ts.css.wrapper).length) {
                            $this.wrapInner('<div class="' + ts.css.wrapper + '" style="position:relative;height:100%;width:100%"></div>');
                        }
                    });
                    if (c.cssIcon) {
                        $headers.find("." + ts.css.icon).removeClass(hasOldTheme ? [ oldtheme.icons, oldIconRmv ].join(" ") : "").addClass(themes.icons || "");
                    }
                    if (ts.hasWidget(c.table, "filter")) {
                        tmp = function() {
                            $table.children("thead").children("." + ts.css.filterRow).removeClass(hasOldTheme ? oldtheme.filterRow || "" : "").addClass(themes.filterRow || "");
                        };
                        if (wo.filter_initialized) {
                            tmp();
                        } else {
                            $table.one("filterInit", function() {
                                tmp();
                            });
                        }
                    }
                }
                for (i = 0; i < c.columns; i++) {
                    $header = c.$headers.add($(c.namespace + "_extra_headers")).not(".sorter-false").filter('[data-column="' + i + '"]');
                    $icon = ts.css.icon ? $header.find("." + ts.css.icon) : $();
                    $h = $headers.not(".sorter-false").filter('[data-column="' + i + '"]:last');
                    if ($h.length) {
                        $header.removeClass(remove);
                        $icon.removeClass(iconRmv);
                        if ($h[0].sortDisabled) {
                            $icon.removeClass(themes.icons || "");
                        } else {
                            hdr = themes.sortNone;
                            icon = themes.iconSortNone;
                            if ($h.hasClass(ts.css.sortAsc)) {
                                hdr = [ themes.sortAsc, themes.active ].join(" ");
                                icon = themes.iconSortAsc;
                            } else if ($h.hasClass(ts.css.sortDesc)) {
                                hdr = [ themes.sortDesc, themes.active ].join(" ");
                                icon = themes.iconSortDesc;
                            }
                            $header.addClass(hdr);
                            $icon.addClass(icon || "");
                        }
                    }
                }
                if (debug) {
                    console.log("uitheme >> Applied " + theme + " theme" + ts.benchmark(time));
                }
            },
            remove: function(table, c, wo, refreshing) {
                if (!wo.uitheme_applied) {
                    return;
                }
                var $table = c.$table, theme = c.appliedTheme || "jui", themes = ts.themes[theme] || ts.themes.jui, $headers = $table.children("thead").children(), remove = themes.sortNone + " " + themes.sortDesc + " " + themes.sortAsc, iconRmv = themes.iconSortNone + " " + themes.iconSortDesc + " " + themes.iconSortAsc;
                $table.removeClass("tablesorter-" + theme + " " + themes.table);
                wo.uitheme_applied = false;
                if (refreshing) {
                    return;
                }
                $table.find(ts.css.header).removeClass(themes.header);
                $headers.unbind("mouseenter.tsuitheme mouseleave.tsuitheme").removeClass(themes.hover + " " + remove + " " + themes.active).filter("." + ts.css.filterRow).removeClass(themes.filterRow);
                $headers.find("." + ts.css.icon).removeClass(themes.icons + " " + iconRmv);
            }
        });
    })(jQuery);
    (function($) {
        "use strict";
        var ts = $.tablesorter || {};
        ts.addWidget({
            id: "columns",
            priority: 65,
            options: {
                columns: [ "primary", "secondary", "tertiary" ]
            },
            format: function(table, c, wo) {
                var $tbody, tbodyIndex, $rows, rows, $row, $cells, remove, indx, $table = c.$table, $tbodies = c.$tbodies, sortList = c.sortList, len = sortList.length, css = wo && wo.columns || [ "primary", "secondary", "tertiary" ], last = css.length - 1;
                remove = css.join(" ");
                for (tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++) {
                    $tbody = ts.processTbody(table, $tbodies.eq(tbodyIndex), true);
                    $rows = $tbody.children("tr");
                    $rows.each(function() {
                        $row = $(this);
                        if (this.style.display !== "none") {
                            $cells = $row.children().removeClass(remove);
                            if (sortList && sortList[0]) {
                                $cells.eq(sortList[0][0]).addClass(css[0]);
                                if (len > 1) {
                                    for (indx = 1; indx < len; indx++) {
                                        $cells.eq(sortList[indx][0]).addClass(css[indx] || css[last]);
                                    }
                                }
                            }
                        }
                    });
                    ts.processTbody(table, $tbody, false);
                }
                rows = wo.columns_thead !== false ? [ "thead tr" ] : [];
                if (wo.columns_tfoot !== false) {
                    rows.push("tfoot tr");
                }
                if (rows.length) {
                    $rows = $table.find(rows.join(",")).children().removeClass(remove);
                    if (len) {
                        for (indx = 0; indx < len; indx++) {
                            $rows.filter('[data-column="' + sortList[indx][0] + '"]').addClass(css[indx] || css[last]);
                        }
                    }
                }
            },
            remove: function(table, c, wo) {
                var tbodyIndex, $tbody, $tbodies = c.$tbodies, remove = (wo.columns || [ "primary", "secondary", "tertiary" ]).join(" ");
                c.$headers.removeClass(remove);
                c.$table.children("tfoot").children("tr").children("th, td").removeClass(remove);
                for (tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++) {
                    $tbody = ts.processTbody(table, $tbodies.eq(tbodyIndex), true);
                    $tbody.children("tr").each(function() {
                        $(this).children().removeClass(remove);
                    });
                    ts.processTbody(table, $tbody, false);
                }
            }
        });
    })(jQuery);
    (function($) {
        "use strict";
        var tsf, tsfRegex, ts = $.tablesorter || {}, tscss = ts.css, tskeyCodes = ts.keyCodes;
        $.extend(tscss, {
            filterRow: "tablesorter-filter-row",
            filter: "tablesorter-filter",
            filterDisabled: "disabled",
            filterRowHide: "hideme"
        });
        $.extend(tskeyCodes, {
            backSpace: 8,
            escape: 27,
            space: 32,
            left: 37,
            down: 40
        });
        ts.addWidget({
            id: "filter",
            priority: 50,
            options: {
                filter_cellFilter: "",
                filter_childRows: false,
                filter_childByColumn: false,
                filter_childWithSibs: true,
                filter_columnAnyMatch: true,
                filter_columnFilters: true,
                filter_cssFilter: "",
                filter_defaultAttrib: "data-value",
                filter_defaultFilter: {},
                filter_excludeFilter: {},
                filter_external: "",
                filter_filteredRow: "filtered",
                filter_filterLabel: 'Filter "{{label}}" column by...',
                filter_formatter: null,
                filter_functions: null,
                filter_hideEmpty: true,
                filter_hideFilters: false,
                filter_ignoreCase: true,
                filter_liveSearch: true,
                filter_matchType: {
                    input: "exact",
                    select: "exact"
                },
                filter_onlyAvail: "filter-onlyAvail",
                filter_placeholder: {
                    search: "",
                    select: ""
                },
                filter_reset: null,
                filter_resetOnEsc: true,
                filter_saveFilters: false,
                filter_searchDelay: 300,
                filter_searchFiltered: true,
                filter_selectSource: null,
                filter_selectSourceSeparator: "|",
                filter_serversideFiltering: false,
                filter_startsWith: false,
                filter_useParsedData: false
            },
            format: function(table, c, wo) {
                if (!c.$table.hasClass("hasFilters")) {
                    tsf.init(table, c, wo);
                }
            },
            remove: function(table, c, wo, refreshing) {
                var tbodyIndex, $tbody, $table = c.$table, $tbodies = c.$tbodies, events = ("addRows updateCell update updateRows updateComplete appendCache filterReset " + "filterAndSortReset filterFomatterUpdate filterEnd search stickyHeadersInit ").split(" ").join(c.namespace + "filter ");
                $table.removeClass("hasFilters").unbind(events.replace(ts.regex.spaces, " ")).find("." + tscss.filterRow).remove();
                wo.filter_initialized = false;
                if (refreshing) {
                    return;
                }
                for (tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++) {
                    $tbody = ts.processTbody(table, $tbodies.eq(tbodyIndex), true);
                    $tbody.children().removeClass(wo.filter_filteredRow).show();
                    ts.processTbody(table, $tbody, false);
                }
                if (wo.filter_reset) {
                    $(document).undelegate(wo.filter_reset, "click" + c.namespace + "filter");
                }
            }
        });
        tsf = ts.filter = {
            regex: {
                regex: /^\/((?:\\\/|[^\/])+)\/([migyu]{0,5})?$/,
                child: /tablesorter-childRow/,
                filtered: /filtered/,
                type: /undefined|number/,
                exact: /(^[\"\'=]+)|([\"\'=]+$)/g,
                operators: /[<>=]/g,
                query: "(q|query)",
                wild01: /\?/g,
                wild0More: /\*/g,
                quote: /\"/g,
                isNeg1: /(>=?\s*-\d)/,
                isNeg2: /(<=?\s*\d)/
            },
            types: {
                or: function(c, data, vars) {
                    if ((tsfRegex.orTest.test(data.iFilter) || tsfRegex.orSplit.test(data.filter)) && !tsfRegex.regex.test(data.filter)) {
                        var indx, filterMatched, query, regex, data2 = $.extend({}, data), filter = data.filter.split(tsfRegex.orSplit), iFilter = data.iFilter.split(tsfRegex.orSplit), len = filter.length;
                        for (indx = 0; indx < len; indx++) {
                            data2.nestedFilters = true;
                            data2.filter = "" + (tsf.parseFilter(c, filter[indx], data) || "");
                            data2.iFilter = "" + (tsf.parseFilter(c, iFilter[indx], data) || "");
                            query = "(" + (tsf.parseFilter(c, data2.filter, data) || "") + ")";
                            try {
                                regex = new RegExp(data.isMatch ? query : "^" + query + "$", c.widgetOptions.filter_ignoreCase ? "i" : "");
                                filterMatched = regex.test(data2.exact) || tsf.processTypes(c, data2, vars);
                                if (filterMatched) {
                                    return filterMatched;
                                }
                            } catch (error) {
                                return null;
                            }
                        }
                        return filterMatched || false;
                    }
                    return null;
                },
                and: function(c, data, vars) {
                    if (tsfRegex.andTest.test(data.filter)) {
                        var indx, filterMatched, result, query, regex, data2 = $.extend({}, data), filter = data.filter.split(tsfRegex.andSplit), iFilter = data.iFilter.split(tsfRegex.andSplit), len = filter.length;
                        for (indx = 0; indx < len; indx++) {
                            data2.nestedFilters = true;
                            data2.filter = "" + (tsf.parseFilter(c, filter[indx], data) || "");
                            data2.iFilter = "" + (tsf.parseFilter(c, iFilter[indx], data) || "");
                            query = ("(" + (tsf.parseFilter(c, data2.filter, data) || "") + ")").replace(tsfRegex.wild01, "\\S{1}").replace(tsfRegex.wild0More, "\\S*");
                            try {
                                regex = new RegExp(data.isMatch ? query : "^" + query + "$", c.widgetOptions.filter_ignoreCase ? "i" : "");
                                result = regex.test(data2.exact) || tsf.processTypes(c, data2, vars);
                                if (indx === 0) {
                                    filterMatched = result;
                                } else {
                                    filterMatched = filterMatched && result;
                                }
                            } catch (error) {
                                return null;
                            }
                        }
                        return filterMatched || false;
                    }
                    return null;
                },
                regex: function(c, data) {
                    if (tsfRegex.regex.test(data.filter)) {
                        var matches, regex = data.filter_regexCache[data.index] || tsfRegex.regex.exec(data.filter), isRegex = regex instanceof RegExp;
                        try {
                            if (!isRegex) {
                                data.filter_regexCache[data.index] = regex = new RegExp(regex[1], regex[2]);
                            }
                            matches = regex.test(data.exact);
                        } catch (error) {
                            matches = false;
                        }
                        return matches;
                    }
                    return null;
                },
                operators: function(c, data) {
                    if (tsfRegex.operTest.test(data.iFilter) && data.iExact !== "") {
                        var cachedValue, result, txt, table = c.table, parsed = data.parsed[data.index], query = ts.formatFloat(data.iFilter.replace(tsfRegex.operators, ""), table), parser = c.parsers[data.index] || {}, savedSearch = query;
                        if (parsed || parser.type === "numeric") {
                            txt = $.trim("" + data.iFilter.replace(tsfRegex.operators, ""));
                            result = tsf.parseFilter(c, txt, data, true);
                            query = typeof result === "number" && result !== "" && !isNaN(result) ? result : query;
                        }
                        if ((parsed || parser.type === "numeric") && !isNaN(query) && typeof data.cache !== "undefined") {
                            cachedValue = data.cache;
                        } else {
                            txt = isNaN(data.iExact) ? data.iExact.replace(ts.regex.nondigit, "") : data.iExact;
                            cachedValue = ts.formatFloat(txt, table);
                        }
                        if (tsfRegex.gtTest.test(data.iFilter)) {
                            result = tsfRegex.gteTest.test(data.iFilter) ? cachedValue >= query : cachedValue > query;
                        } else if (tsfRegex.ltTest.test(data.iFilter)) {
                            result = tsfRegex.lteTest.test(data.iFilter) ? cachedValue <= query : cachedValue < query;
                        }
                        if (!result && savedSearch === "") {
                            result = true;
                        }
                        return result;
                    }
                    return null;
                },
                notMatch: function(c, data) {
                    if (tsfRegex.notTest.test(data.iFilter)) {
                        var indx, txt = data.iFilter.replace("!", ""), filter = tsf.parseFilter(c, txt, data) || "";
                        if (tsfRegex.exact.test(filter)) {
                            filter = filter.replace(tsfRegex.exact, "");
                            return filter === "" ? true : $.trim(filter) !== data.iExact;
                        } else {
                            indx = data.iExact.search($.trim(filter));
                            return filter === "" ? true : data.anyMatch ? indx < 0 : !(c.widgetOptions.filter_startsWith ? indx === 0 : indx >= 0);
                        }
                    }
                    return null;
                },
                exact: function(c, data) {
                    if (tsfRegex.exact.test(data.iFilter)) {
                        var txt = data.iFilter.replace(tsfRegex.exact, ""), filter = tsf.parseFilter(c, txt, data) || "";
                        return data.anyMatch ? $.inArray(filter, data.rowArray) >= 0 : filter == data.iExact;
                    }
                    return null;
                },
                range: function(c, data) {
                    if (tsfRegex.toTest.test(data.iFilter)) {
                        var result, tmp, range1, range2, table = c.table, index = data.index, parsed = data.parsed[index], query = data.iFilter.split(tsfRegex.toSplit);
                        tmp = query[0].replace(ts.regex.nondigit, "") || "";
                        range1 = ts.formatFloat(tsf.parseFilter(c, tmp, data), table);
                        tmp = query[1].replace(ts.regex.nondigit, "") || "";
                        range2 = ts.formatFloat(tsf.parseFilter(c, tmp, data), table);
                        if (parsed || c.parsers[index].type === "numeric") {
                            result = c.parsers[index].format("" + query[0], table, c.$headers.eq(index), index);
                            range1 = result !== "" && !isNaN(result) ? result : range1;
                            result = c.parsers[index].format("" + query[1], table, c.$headers.eq(index), index);
                            range2 = result !== "" && !isNaN(result) ? result : range2;
                        }
                        if ((parsed || c.parsers[index].type === "numeric") && !isNaN(range1) && !isNaN(range2)) {
                            result = data.cache;
                        } else {
                            tmp = isNaN(data.iExact) ? data.iExact.replace(ts.regex.nondigit, "") : data.iExact;
                            result = ts.formatFloat(tmp, table);
                        }
                        if (range1 > range2) {
                            tmp = range1;
                            range1 = range2;
                            range2 = tmp;
                        }
                        return result >= range1 && result <= range2 || (range1 === "" || range2 === "");
                    }
                    return null;
                },
                wild: function(c, data) {
                    if (tsfRegex.wildOrTest.test(data.iFilter)) {
                        var query = "" + (tsf.parseFilter(c, data.iFilter, data) || "");
                        if (!tsfRegex.wildTest.test(query) && data.nestedFilters) {
                            query = data.isMatch ? query : "^(" + query + ")$";
                        }
                        try {
                            return new RegExp(query.replace(tsfRegex.wild01, "\\S{1}").replace(tsfRegex.wild0More, "\\S*"), c.widgetOptions.filter_ignoreCase ? "i" : "").test(data.exact);
                        } catch (error) {
                            return null;
                        }
                    }
                    return null;
                },
                fuzzy: function(c, data) {
                    if (tsfRegex.fuzzyTest.test(data.iFilter)) {
                        var indx, patternIndx = 0, len = data.iExact.length, txt = data.iFilter.slice(1), pattern = tsf.parseFilter(c, txt, data) || "";
                        for (indx = 0; indx < len; indx++) {
                            if (data.iExact[indx] === pattern[patternIndx]) {
                                patternIndx += 1;
                            }
                        }
                        return patternIndx === pattern.length;
                    }
                    return null;
                }
            },
            init: function(table) {
                ts.language = $.extend(true, {}, {
                    to: "to",
                    or: "or",
                    and: "and"
                }, ts.language);
                var options, string, txt, $header, column, val, fxn, noSelect, c = table.config, wo = c.widgetOptions, processStr = function(prefix, str, suffix) {
                    str = str.trim();
                    return str === "" ? "" : (prefix || "") + str + (suffix || "");
                };
                c.$table.addClass("hasFilters");
                c.lastSearch = [];
                wo.filter_searchTimer = null;
                wo.filter_initTimer = null;
                wo.filter_formatterCount = 0;
                wo.filter_formatterInit = [];
                wo.filter_anyColumnSelector = '[data-column="all"],[data-column="any"]';
                wo.filter_multipleColumnSelector = '[data-column*="-"],[data-column*=","]';
                val = "\\{" + tsfRegex.query + "\\}";
                $.extend(tsfRegex, {
                    child: new RegExp(c.cssChildRow),
                    filtered: new RegExp(wo.filter_filteredRow),
                    alreadyFiltered: new RegExp("(\\s+(-" + processStr("|", ts.language.or) + processStr("|", ts.language.to) + ")\\s+)", "i"),
                    toTest: new RegExp("\\s+(-" + processStr("|", ts.language.to) + ")\\s+", "i"),
                    toSplit: new RegExp("(?:\\s+(?:-" + processStr("|", ts.language.to) + ")\\s+)", "gi"),
                    andTest: new RegExp("\\s+(" + processStr("", ts.language.and, "|") + "&&)\\s+", "i"),
                    andSplit: new RegExp("(?:\\s+(?:" + processStr("", ts.language.and, "|") + "&&)\\s+)", "gi"),
                    orTest: new RegExp("(\\|" + processStr("|\\s+", ts.language.or, "\\s+") + ")", "i"),
                    orSplit: new RegExp("(?:\\|" + processStr("|\\s+(?:", ts.language.or, ")\\s+") + ")", "gi"),
                    iQuery: new RegExp(val, "i"),
                    igQuery: new RegExp(val, "ig"),
                    operTest: /^[<>]=?/,
                    gtTest: />/,
                    gteTest: />=/,
                    ltTest: /</,
                    lteTest: /<=/,
                    notTest: /^\!/,
                    wildOrTest: /[\?\*\|]/,
                    wildTest: /\?\*/,
                    fuzzyTest: /^~/,
                    exactTest: /[=\"\|!]/
                });
                val = c.$headers.filter(".filter-false, .parser-false").length;
                if (wo.filter_columnFilters !== false && val !== c.$headers.length) {
                    tsf.buildRow(table, c, wo);
                }
                txt = "addRows updateCell update updateRows updateComplete appendCache filterReset " + "filterAndSortReset filterResetSaved filterEnd search ".split(" ").join(c.namespace + "filter ");
                c.$table.bind(txt, function(event, filter) {
                    val = wo.filter_hideEmpty && $.isEmptyObject(c.cache) && !(c.delayInit && event.type === "appendCache");
                    c.$table.find("." + tscss.filterRow).toggleClass(wo.filter_filteredRow, val);
                    if (!/(search|filter)/.test(event.type)) {
                        event.stopPropagation();
                        tsf.buildDefault(table, true);
                    }
                    if (event.type === "filterReset" || event.type === "filterAndSortReset") {
                        c.$table.find("." + tscss.filter).add(wo.filter_$externalFilters).val("");
                        if (event.type === "filterAndSortReset") {
                            ts.sortReset(this.config, function() {
                                tsf.searching(table, []);
                            });
                        } else {
                            tsf.searching(table, []);
                        }
                    } else if (event.type === "filterResetSaved") {
                        ts.storage(table, "tablesorter-filters", "");
                    } else if (event.type === "filterEnd") {
                        tsf.buildDefault(table, true);
                    } else {
                        filter = event.type === "search" ? filter : event.type === "updateComplete" ? c.$table.data("lastSearch") : "";
                        if (/(update|add)/.test(event.type) && event.type !== "updateComplete") {
                            c.lastCombinedFilter = null;
                            c.lastSearch = [];
                            setTimeout(function() {
                                c.$table.triggerHandler("filterFomatterUpdate");
                            }, 100);
                        }
                        tsf.searching(table, filter, true);
                    }
                    return false;
                });
                if (wo.filter_reset) {
                    if (wo.filter_reset instanceof $) {
                        wo.filter_reset.click(function() {
                            c.$table.triggerHandler("filterReset");
                        });
                    } else if ($(wo.filter_reset).length) {
                        $(document).undelegate(wo.filter_reset, "click" + c.namespace + "filter").delegate(wo.filter_reset, "click" + c.namespace + "filter", function() {
                            c.$table.triggerHandler("filterReset");
                        });
                    }
                }
                if (wo.filter_functions) {
                    for (column = 0; column < c.columns; column++) {
                        fxn = ts.getColumnData(table, wo.filter_functions, column);
                        if (fxn) {
                            $header = c.$headerIndexed[column].removeClass("filter-select");
                            noSelect = !($header.hasClass("filter-false") || $header.hasClass("parser-false"));
                            options = "";
                            if (fxn === true && noSelect) {
                                tsf.buildSelect(table, column);
                            } else if (typeof fxn === "object" && noSelect) {
                                for (string in fxn) {
                                    if (typeof string === "string") {
                                        options += options === "" ? '<option value="">' + ($header.data("placeholder") || $header.attr("data-placeholder") || wo.filter_placeholder.select || "") + "</option>" : "";
                                        val = string;
                                        txt = string;
                                        if (string.indexOf(wo.filter_selectSourceSeparator) >= 0) {
                                            val = string.split(wo.filter_selectSourceSeparator);
                                            txt = val[1];
                                            val = val[0];
                                        }
                                        options += "<option " + (txt === val ? "" : 'data-function-name="' + string + '" ') + 'value="' + val + '">' + txt + "</option>";
                                    }
                                }
                                c.$table.find("thead").find("select." + tscss.filter + '[data-column="' + column + '"]').append(options);
                                txt = wo.filter_selectSource;
                                fxn = typeof txt === "function" ? true : ts.getColumnData(table, txt, column);
                                if (fxn) {
                                    tsf.buildSelect(c.table, column, "", true, $header.hasClass(wo.filter_onlyAvail));
                                }
                            }
                        }
                    }
                }
                tsf.buildDefault(table, true);
                tsf.bindSearch(table, c.$table.find("." + tscss.filter), true);
                if (wo.filter_external) {
                    tsf.bindSearch(table, wo.filter_external);
                }
                if (wo.filter_hideFilters) {
                    tsf.hideFilters(c);
                }
                if (c.showProcessing) {
                    txt = "filterStart filterEnd ".split(" ").join(c.namespace + "filter-sp ");
                    c.$table.unbind(txt.replace(ts.regex.spaces, " ")).bind(txt, function(event, columns) {
                        $header = columns ? c.$table.find("." + tscss.header).filter("[data-column]").filter(function() {
                            return columns[$(this).data("column")] !== "";
                        }) : "";
                        ts.isProcessing(table, event.type === "filterStart", columns ? $header : "");
                    });
                }
                c.filteredRows = c.totalRows;
                txt = "tablesorter-initialized pagerBeforeInitialized ".split(" ").join(c.namespace + "filter ");
                c.$table.unbind(txt.replace(ts.regex.spaces, " ")).bind(txt, function() {
                    tsf.completeInit(this);
                });
                if (c.pager && c.pager.initialized && !wo.filter_initialized) {
                    c.$table.triggerHandler("filterFomatterUpdate");
                    setTimeout(function() {
                        tsf.filterInitComplete(c);
                    }, 100);
                } else if (!wo.filter_initialized) {
                    tsf.completeInit(table);
                }
            },
            completeInit: function(table) {
                var c = table.config, wo = c.widgetOptions, filters = tsf.setDefaults(table, c, wo) || [];
                if (filters.length) {
                    if (!(c.delayInit && filters.join("") === "")) {
                        ts.setFilters(table, filters, true);
                    }
                }
                c.$table.triggerHandler("filterFomatterUpdate");
                setTimeout(function() {
                    if (!wo.filter_initialized) {
                        tsf.filterInitComplete(c);
                    }
                }, 100);
            },
            formatterUpdated: function($cell, column) {
                var $table = $cell && $cell.closest("table");
                var config = $table.length && $table[0].config, wo = config && config.widgetOptions;
                if (wo && !wo.filter_initialized) {
                    wo.filter_formatterInit[column] = 1;
                }
            },
            filterInitComplete: function(c) {
                var indx, len, wo = c.widgetOptions, count = 0, completed = function() {
                    wo.filter_initialized = true;
                    c.lastSearch = c.$table.data("lastSearch");
                    c.$table.triggerHandler("filterInit", c);
                    tsf.findRows(c.table, c.lastSearch || []);
                    if (ts.debug(c, "filter")) {
                        console.log("Filter >> Widget initialized");
                    }
                };
                if ($.isEmptyObject(wo.filter_formatter)) {
                    completed();
                } else {
                    len = wo.filter_formatterInit.length;
                    for (indx = 0; indx < len; indx++) {
                        if (wo.filter_formatterInit[indx] === 1) {
                            count++;
                        }
                    }
                    clearTimeout(wo.filter_initTimer);
                    if (!wo.filter_initialized && count === wo.filter_formatterCount) {
                        completed();
                    } else if (!wo.filter_initialized) {
                        wo.filter_initTimer = setTimeout(function() {
                            completed();
                        }, 500);
                    }
                }
            },
            processFilters: function(filters, encode) {
                var indx, result = [], mode = encode ? encodeURIComponent : decodeURIComponent, len = filters.length;
                for (indx = 0; indx < len; indx++) {
                    if (filters[indx]) {
                        result[indx] = mode(filters[indx]);
                    }
                }
                return result;
            },
            setDefaults: function(table, c, wo) {
                var isArray, saved, indx, col, $filters, filters = ts.getFilters(table) || [];
                if (wo.filter_saveFilters && ts.storage) {
                    saved = ts.storage(table, "tablesorter-filters") || [];
                    isArray = $.isArray(saved);
                    if (!(isArray && saved.join("") === "" || !isArray)) {
                        filters = tsf.processFilters(saved);
                    }
                }
                if (filters.join("") === "") {
                    $filters = c.$headers.add(wo.filter_$externalFilters).filter("[" + wo.filter_defaultAttrib + "]");
                    for (indx = 0; indx <= c.columns; indx++) {
                        col = indx === c.columns ? "all" : indx;
                        filters[indx] = $filters.filter('[data-column="' + col + '"]').attr(wo.filter_defaultAttrib) || filters[indx] || "";
                    }
                }
                c.$table.data("lastSearch", filters);
                return filters;
            },
            parseFilter: function(c, filter, data, parsed) {
                return parsed || data.parsed[data.index] ? c.parsers[data.index].format(filter, c.table, [], data.index) : filter;
            },
            buildRow: function(table, c, wo) {
                var $filter, col, column, $header, makeSelect, disabled, name, ffxn, tmp, cellFilter = wo.filter_cellFilter, columns = c.columns, arry = $.isArray(cellFilter), buildFilter = '<tr role="search" class="' + tscss.filterRow + " " + c.cssIgnoreRow + '">';
                for (column = 0; column < columns; column++) {
                    if (c.$headerIndexed[column].length) {
                        tmp = c.$headerIndexed[column] && c.$headerIndexed[column][0].colSpan || 0;
                        if (tmp > 1) {
                            buildFilter += '<td data-column="' + column + "-" + (column + tmp - 1) + '" colspan="' + tmp + '"';
                        } else {
                            buildFilter += '<td data-column="' + column + '"';
                        }
                        if (arry) {
                            buildFilter += cellFilter[column] ? ' class="' + cellFilter[column] + '"' : "";
                        } else {
                            buildFilter += cellFilter !== "" ? ' class="' + cellFilter + '"' : "";
                        }
                        buildFilter += "></td>";
                    }
                }
                c.$filters = $(buildFilter += "</tr>").appendTo(c.$table.children("thead").eq(0)).children("td");
                for (column = 0; column < columns; column++) {
                    disabled = false;
                    $header = c.$headerIndexed[column];
                    if ($header && $header.length) {
                        $filter = tsf.getColumnElm(c, c.$filters, column);
                        ffxn = ts.getColumnData(table, wo.filter_functions, column);
                        makeSelect = wo.filter_functions && ffxn && typeof ffxn !== "function" || $header.hasClass("filter-select");
                        col = ts.getColumnData(table, c.headers, column);
                        disabled = ts.getData($header[0], col, "filter") === "false" || ts.getData($header[0], col, "parser") === "false";
                        if (makeSelect) {
                            buildFilter = $("<select>").appendTo($filter);
                        } else {
                            ffxn = ts.getColumnData(table, wo.filter_formatter, column);
                            if (ffxn) {
                                wo.filter_formatterCount++;
                                buildFilter = ffxn($filter, column);
                                if (buildFilter && buildFilter.length === 0) {
                                    buildFilter = $filter.children("input");
                                }
                                if (buildFilter && (buildFilter.parent().length === 0 || buildFilter.parent().length && buildFilter.parent()[0] !== $filter[0])) {
                                    $filter.append(buildFilter);
                                }
                            } else {
                                buildFilter = $('<input type="search">').appendTo($filter);
                            }
                            if (buildFilter) {
                                tmp = $header.data("placeholder") || $header.attr("data-placeholder") || wo.filter_placeholder.search || "";
                                buildFilter.attr("placeholder", tmp);
                            }
                        }
                        if (buildFilter) {
                            name = ($.isArray(wo.filter_cssFilter) ? typeof wo.filter_cssFilter[column] !== "undefined" ? wo.filter_cssFilter[column] || "" : "" : wo.filter_cssFilter) || "";
                            buildFilter.addClass(tscss.filter + " " + name);
                            name = wo.filter_filterLabel;
                            tmp = name.match(/{{([^}]+?)}}/g);
                            if (!tmp) {
                                tmp = [ "{{label}}" ];
                            }
                            $.each(tmp, function(indx, attr) {
                                var regex = new RegExp(attr, "g"), data = $header.attr("data-" + attr.replace(/{{|}}/g, "")), text = typeof data === "undefined" ? $header.text() : data;
                                name = name.replace(regex, $.trim(text));
                            });
                            buildFilter.attr({
                                "data-column": $filter.attr("data-column"),
                                "aria-label": name
                            });
                            if (disabled) {
                                buildFilter.attr("placeholder", "").addClass(tscss.filterDisabled)[0].disabled = true;
                            }
                        }
                    }
                }
            },
            bindSearch: function(table, $el, internal) {
                table = $(table)[0];
                $el = $($el);
                if (!$el.length) {
                    return;
                }
                var tmp, c = table.config, wo = c.widgetOptions, namespace = c.namespace + "filter", $ext = wo.filter_$externalFilters;
                if (internal !== true) {
                    tmp = wo.filter_anyColumnSelector + "," + wo.filter_multipleColumnSelector;
                    wo.filter_$anyMatch = $el.filter(tmp);
                    if ($ext && $ext.length) {
                        wo.filter_$externalFilters = wo.filter_$externalFilters.add($el);
                    } else {
                        wo.filter_$externalFilters = $el;
                    }
                    ts.setFilters(table, c.$table.data("lastSearch") || [], internal === false);
                }
                tmp = "keypress keyup keydown search change input ".split(" ").join(namespace + " ");
                $el.attr("data-lastSearchTime", new Date().getTime()).unbind(tmp.replace(ts.regex.spaces, " ")).bind("keydown" + namespace, function(event) {
                    if (event.which === tskeyCodes.escape && !table.config.widgetOptions.filter_resetOnEsc) {
                        return false;
                    }
                }).bind("keyup" + namespace, function(event) {
                    wo = table.config.widgetOptions;
                    var column = parseInt($(this).attr("data-column"), 10), liveSearch = typeof wo.filter_liveSearch === "boolean" ? wo.filter_liveSearch : ts.getColumnData(table, wo.filter_liveSearch, column);
                    if (typeof liveSearch === "undefined") {
                        liveSearch = wo.filter_liveSearch.fallback || false;
                    }
                    $(this).attr("data-lastSearchTime", new Date().getTime());
                    if (event.which === tskeyCodes.escape) {
                        this.value = wo.filter_resetOnEsc ? "" : c.lastSearch[column];
                    } else if (this.value !== "" && (typeof liveSearch === "number" && this.value.length < liveSearch || event.which !== tskeyCodes.enter && event.which !== tskeyCodes.backSpace && (event.which < tskeyCodes.space || event.which >= tskeyCodes.left && event.which <= tskeyCodes.down))) {
                        return;
                    } else if (liveSearch === false) {
                        if (this.value !== "" && event.which !== tskeyCodes.enter) {
                            return;
                        }
                    }
                    tsf.searching(table, true, true, column);
                }).bind("search change keypress input blur ".split(" ").join(namespace + " "), function(event) {
                    var column = parseInt($(this).attr("data-column"), 10), eventType = event.type, liveSearch = typeof wo.filter_liveSearch === "boolean" ? wo.filter_liveSearch : ts.getColumnData(table, wo.filter_liveSearch, column);
                    if (table.config.widgetOptions.filter_initialized && (event.which === tskeyCodes.enter || (eventType === "search" || eventType === "blur") || (eventType === "change" || eventType === "input") && (liveSearch === true || liveSearch !== true && event.target.nodeName !== "INPUT") && this.value !== c.lastSearch[column])) {
                        event.preventDefault();
                        $(this).attr("data-lastSearchTime", new Date().getTime());
                        tsf.searching(table, eventType !== "keypress" || event.which === tskeyCodes.enter, true, column);
                    }
                });
            },
            searching: function(table, filter, skipFirst, column) {
                var liveSearch, wo = table.config.widgetOptions;
                if (typeof column === "undefined") {
                    liveSearch = false;
                } else {
                    liveSearch = typeof wo.filter_liveSearch === "boolean" ? wo.filter_liveSearch : ts.getColumnData(table, wo.filter_liveSearch, column);
                    if (typeof liveSearch === "undefined") {
                        liveSearch = wo.filter_liveSearch.fallback || false;
                    }
                }
                clearTimeout(wo.filter_searchTimer);
                if (typeof filter === "undefined" || filter === true) {
                    wo.filter_searchTimer = setTimeout(function() {
                        tsf.checkFilters(table, filter, skipFirst);
                    }, liveSearch ? wo.filter_searchDelay : 10);
                } else {
                    tsf.checkFilters(table, filter, skipFirst);
                }
            },
            equalFilters: function(c, filter1, filter2) {
                var indx, f1 = [], f2 = [], len = c.columns + 1;
                filter1 = $.isArray(filter1) ? filter1 : [];
                filter2 = $.isArray(filter2) ? filter2 : [];
                for (indx = 0; indx < len; indx++) {
                    f1[indx] = filter1[indx] || "";
                    f2[indx] = filter2[indx] || "";
                }
                return f1.join(",") === f2.join(",");
            },
            checkFilters: function(table, filter, skipFirst) {
                var c = table.config, wo = c.widgetOptions, filterArray = $.isArray(filter), filters = filterArray ? filter : ts.getFilters(table, true), currentFilters = filters || [];
                if ($.isEmptyObject(c.cache)) {
                    if (c.delayInit && (!c.pager || c.pager && c.pager.initialized)) {
                        ts.updateCache(c, function() {
                            tsf.checkFilters(table, false, skipFirst);
                        });
                    }
                    return;
                }
                if (filterArray) {
                    ts.setFilters(table, filters, false, skipFirst !== true);
                    if (!wo.filter_initialized) {
                        c.lastSearch = [];
                        c.lastCombinedFilter = "";
                    }
                }
                if (wo.filter_hideFilters) {
                    c.$table.find("." + tscss.filterRow).triggerHandler(tsf.hideFiltersCheck(c) ? "mouseleave" : "mouseenter");
                }
                if (tsf.equalFilters(c, c.lastSearch, currentFilters)) {
                    if (filter !== false) {
                        return;
                    } else {
                        c.lastCombinedFilter = "";
                        c.lastSearch = [];
                    }
                }
                filters = filters || [];
                filters = Array.prototype.map ? filters.map(String) : filters.join("").split("");
                if (wo.filter_initialized) {
                    c.$table.triggerHandler("filterStart", [ filters ]);
                }
                if (c.showProcessing) {
                    setTimeout(function() {
                        tsf.findRows(table, filters, currentFilters);
                        return false;
                    }, 30);
                } else {
                    tsf.findRows(table, filters, currentFilters);
                    return false;
                }
            },
            hideFiltersCheck: function(c) {
                if (typeof c.widgetOptions.filter_hideFilters === "function") {
                    var val = c.widgetOptions.filter_hideFilters(c);
                    if (typeof val === "boolean") {
                        return val;
                    }
                }
                return ts.getFilters(c.$table).join("") === "";
            },
            hideFilters: function(c, $table) {
                var timer;
                ($table || c.$table).find("." + tscss.filterRow).addClass(tscss.filterRowHide).bind("mouseenter mouseleave", function(e) {
                    var event = e, $row = $(this);
                    clearTimeout(timer);
                    timer = setTimeout(function() {
                        if (/enter|over/.test(event.type)) {
                            $row.removeClass(tscss.filterRowHide);
                        } else {
                            if ($(document.activeElement).closest("tr")[0] !== $row[0]) {
                                $row.toggleClass(tscss.filterRowHide, tsf.hideFiltersCheck(c));
                            }
                        }
                    }, 200);
                }).find("input, select").bind("focus blur", function(e) {
                    var event = e, $row = $(this).closest("tr");
                    clearTimeout(timer);
                    timer = setTimeout(function() {
                        clearTimeout(timer);
                        $row.toggleClass(tscss.filterRowHide, tsf.hideFiltersCheck(c) && event.type !== "focus");
                    }, 200);
                });
            },
            defaultFilter: function(filter, mask) {
                if (filter === "") {
                    return filter;
                }
                var regex = tsfRegex.iQuery, maskLen = mask.match(tsfRegex.igQuery).length, query = maskLen > 1 ? $.trim(filter).split(/\s/) : [ $.trim(filter) ], len = query.length - 1, indx = 0, val = mask;
                if (len < 1 && maskLen > 1) {
                    query[1] = query[0];
                }
                while (regex.test(val)) {
                    val = val.replace(regex, query[indx++] || "");
                    if (regex.test(val) && indx < len && (query[indx] || "") !== "") {
                        val = mask.replace(regex, val);
                    }
                }
                return val;
            },
            getLatestSearch: function($input) {
                if ($input) {
                    return $input.sort(function(a, b) {
                        return $(b).attr("data-lastSearchTime") - $(a).attr("data-lastSearchTime");
                    });
                }
                return $input || $();
            },
            findRange: function(c, val, ignoreRanges) {
                var temp, ranges, range, start, end, singles, i, indx, len, columns = [];
                if (/^[0-9]+$/.test(val)) {
                    return [ parseInt(val, 10) ];
                }
                if (!ignoreRanges && /-/.test(val)) {
                    ranges = val.match(/(\d+)\s*-\s*(\d+)/g);
                    len = ranges ? ranges.length : 0;
                    for (indx = 0; indx < len; indx++) {
                        range = ranges[indx].split(/\s*-\s*/);
                        start = parseInt(range[0], 10) || 0;
                        end = parseInt(range[1], 10) || c.columns - 1;
                        if (start > end) {
                            temp = start;
                            start = end;
                            end = temp;
                        }
                        if (end >= c.columns) {
                            end = c.columns - 1;
                        }
                        for (;start <= end; start++) {
                            columns[columns.length] = start;
                        }
                        val = val.replace(ranges[indx], "");
                    }
                }
                if (!ignoreRanges && /,/.test(val)) {
                    singles = val.split(/\s*,\s*/);
                    len = singles.length;
                    for (i = 0; i < len; i++) {
                        if (singles[i] !== "") {
                            indx = parseInt(singles[i], 10);
                            if (indx < c.columns) {
                                columns[columns.length] = indx;
                            }
                        }
                    }
                }
                if (!columns.length) {
                    for (indx = 0; indx < c.columns; indx++) {
                        columns[columns.length] = indx;
                    }
                }
                return columns;
            },
            getColumnElm: function(c, $elements, column) {
                return $elements.filter(function() {
                    var cols = tsf.findRange(c, $(this).attr("data-column"));
                    return $.inArray(column, cols) > -1;
                });
            },
            multipleColumns: function(c, $input) {
                var wo = c.widgetOptions, targets = wo.filter_initialized || !$input.filter(wo.filter_anyColumnSelector).length, val = $.trim(tsf.getLatestSearch($input).attr("data-column") || "");
                return tsf.findRange(c, val, !targets);
            },
            processTypes: function(c, data, vars) {
                var ffxn, filterMatched = null, matches = null;
                for (ffxn in tsf.types) {
                    if ($.inArray(ffxn, vars.excludeMatch) < 0 && matches === null) {
                        matches = tsf.types[ffxn](c, data, vars);
                        if (matches !== null) {
                            data.matchedOn = ffxn;
                            filterMatched = matches;
                        }
                    }
                }
                return filterMatched;
            },
            matchType: function(c, columnIndex) {
                var isMatch, wo = c.widgetOptions, $el = c.$headerIndexed[columnIndex];
                if ($el.hasClass("filter-exact")) {
                    isMatch = false;
                } else if ($el.hasClass("filter-match")) {
                    isMatch = true;
                } else {
                    if (wo.filter_columnFilters) {
                        $el = c.$filters.find("." + tscss.filter).add(wo.filter_$externalFilters).filter('[data-column="' + columnIndex + '"]');
                    } else if (wo.filter_$externalFilters) {
                        $el = wo.filter_$externalFilters.filter('[data-column="' + columnIndex + '"]');
                    }
                    isMatch = $el.length ? c.widgetOptions.filter_matchType[($el[0].nodeName || "").toLowerCase()] === "match" : false;
                }
                return isMatch;
            },
            processRow: function(c, data, vars) {
                var result, filterMatched, fxn, ffxn, txt, wo = c.widgetOptions, showRow = true, hasAnyMatchInput = wo.filter_$anyMatch && wo.filter_$anyMatch.length, columnIndex = wo.filter_$anyMatch && wo.filter_$anyMatch.length ? tsf.multipleColumns(c, wo.filter_$anyMatch) : [];
                data.$cells = data.$row.children();
                data.matchedOn = null;
                if (data.anyMatchFlag && columnIndex.length > 1 || data.anyMatchFilter && !hasAnyMatchInput) {
                    data.anyMatch = true;
                    data.isMatch = true;
                    data.rowArray = data.$cells.map(function(i) {
                        if ($.inArray(i, columnIndex) > -1 || data.anyMatchFilter && !hasAnyMatchInput) {
                            if (data.parsed[i]) {
                                txt = data.cacheArray[i];
                            } else {
                                txt = data.rawArray[i];
                                txt = $.trim(wo.filter_ignoreCase ? txt.toLowerCase() : txt);
                                if (c.sortLocaleCompare) {
                                    txt = ts.replaceAccents(txt);
                                }
                            }
                            return txt;
                        }
                    }).get();
                    data.filter = data.anyMatchFilter;
                    data.iFilter = data.iAnyMatchFilter;
                    data.exact = data.rowArray.join(" ");
                    data.iExact = wo.filter_ignoreCase ? data.exact.toLowerCase() : data.exact;
                    data.cache = data.cacheArray.slice(0, -1).join(" ");
                    vars.excludeMatch = vars.noAnyMatch;
                    filterMatched = tsf.processTypes(c, data, vars);
                    if (filterMatched !== null) {
                        showRow = filterMatched;
                    } else {
                        if (wo.filter_startsWith) {
                            showRow = false;
                            columnIndex = Math.min(c.columns, data.rowArray.length);
                            while (!showRow && columnIndex > 0) {
                                columnIndex--;
                                showRow = showRow || data.rowArray[columnIndex].indexOf(data.iFilter) === 0;
                            }
                        } else {
                            showRow = (data.iExact + data.childRowText).indexOf(data.iFilter) >= 0;
                        }
                    }
                    data.anyMatch = false;
                    if (data.filters.join("") === data.filter) {
                        return showRow;
                    }
                }
                for (columnIndex = 0; columnIndex < c.columns; columnIndex++) {
                    data.filter = data.filters[columnIndex];
                    data.index = columnIndex;
                    vars.excludeMatch = vars.excludeFilter[columnIndex];
                    if (data.filter) {
                        data.cache = data.cacheArray[columnIndex];
                        result = data.parsed[columnIndex] ? data.cache : data.rawArray[columnIndex] || "";
                        data.exact = c.sortLocaleCompare ? ts.replaceAccents(result) : result;
                        data.iExact = !tsfRegex.type.test(typeof data.exact) && wo.filter_ignoreCase ? data.exact.toLowerCase() : data.exact;
                        data.isMatch = tsf.matchType(c, columnIndex);
                        result = showRow;
                        ffxn = wo.filter_columnFilters ? c.$filters.add(wo.filter_$externalFilters).filter('[data-column="' + columnIndex + '"]').find("select option:selected").attr("data-function-name") || "" : "";
                        if (c.sortLocaleCompare) {
                            data.filter = ts.replaceAccents(data.filter);
                        }
                        if (wo.filter_defaultFilter && tsfRegex.iQuery.test(vars.defaultColFilter[columnIndex])) {
                            data.filter = tsf.defaultFilter(data.filter, vars.defaultColFilter[columnIndex]);
                        }
                        data.iFilter = wo.filter_ignoreCase ? (data.filter || "").toLowerCase() : data.filter;
                        fxn = vars.functions[columnIndex];
                        filterMatched = null;
                        if (fxn) {
                            if (typeof fxn === "function") {
                                filterMatched = fxn(data.exact, data.cache, data.filter, columnIndex, data.$row, c, data);
                            } else if (typeof fxn[ffxn || data.filter] === "function") {
                                txt = ffxn || data.filter;
                                filterMatched = fxn[txt](data.exact, data.cache, data.filter, columnIndex, data.$row, c, data);
                            }
                        }
                        if (filterMatched === null) {
                            filterMatched = tsf.processTypes(c, data, vars);
                            txt = fxn === true && (data.matchedOn === "and" || data.matchedOn === "or");
                            if (filterMatched !== null && !txt) {
                                result = filterMatched;
                            } else {
                                if (fxn === true) {
                                    result = data.isMatch ? ("" + data.iExact).search(data.iFilter) >= 0 : data.filter === data.exact;
                                } else {
                                    txt = (data.iExact + data.childRowText).indexOf(tsf.parseFilter(c, data.iFilter, data));
                                    result = !wo.filter_startsWith && txt >= 0 || wo.filter_startsWith && txt === 0;
                                }
                            }
                        } else {
                            result = filterMatched;
                        }
                        showRow = result ? showRow : false;
                    }
                }
                return showRow;
            },
            findRows: function(table, filters, currentFilters) {
                if (tsf.equalFilters(table.config, table.config.lastSearch, currentFilters) || !table.config.widgetOptions.filter_initialized) {
                    return;
                }
                var len, norm_rows, rowData, $rows, $row, rowIndex, tbodyIndex, $tbody, columnIndex, isChild, childRow, lastSearch, showRow, showParent, time, val, indx, notFiltered, searchFiltered, query, injected, res, id, txt, storedFilters = $.extend([], filters), c = table.config, wo = c.widgetOptions, debug = ts.debug(c, "filter"), data = {
                    anyMatch: false,
                    filters: filters,
                    filter_regexCache: []
                }, vars = {
                    noAnyMatch: [ "range", "operators" ],
                    functions: [],
                    excludeFilter: [],
                    defaultColFilter: [],
                    defaultAnyFilter: ts.getColumnData(table, wo.filter_defaultFilter, c.columns, true) || ""
                };
                data.parsed = [];
                for (columnIndex = 0; columnIndex < c.columns; columnIndex++) {
                    data.parsed[columnIndex] = wo.filter_useParsedData || (c.parsers && c.parsers[columnIndex] && c.parsers[columnIndex].parsed || ts.getData && ts.getData(c.$headerIndexed[columnIndex], ts.getColumnData(table, c.headers, columnIndex), "filter") === "parsed" || c.$headerIndexed[columnIndex].hasClass("filter-parsed"));
                    vars.functions[columnIndex] = ts.getColumnData(table, wo.filter_functions, columnIndex) || c.$headerIndexed[columnIndex].hasClass("filter-select");
                    vars.defaultColFilter[columnIndex] = ts.getColumnData(table, wo.filter_defaultFilter, columnIndex) || "";
                    vars.excludeFilter[columnIndex] = (ts.getColumnData(table, wo.filter_excludeFilter, columnIndex, true) || "").split(/\s+/);
                }
                if (debug) {
                    console.log("Filter >> Starting filter widget search", filters);
                    time = new Date();
                }
                c.filteredRows = 0;
                c.totalRows = 0;
                currentFilters = storedFilters || [];
                for (tbodyIndex = 0; tbodyIndex < c.$tbodies.length; tbodyIndex++) {
                    $tbody = ts.processTbody(table, c.$tbodies.eq(tbodyIndex), true);
                    columnIndex = c.columns;
                    norm_rows = c.cache[tbodyIndex].normalized;
                    $rows = $($.map(norm_rows, function(el) {
                        return el[columnIndex].$row.get();
                    }));
                    if (currentFilters.join("") === "" || wo.filter_serversideFiltering) {
                        $rows.removeClass(wo.filter_filteredRow).not("." + c.cssChildRow).css("display", "");
                    } else {
                        $rows = $rows.not("." + c.cssChildRow);
                        len = $rows.length;
                        if (wo.filter_$anyMatch && wo.filter_$anyMatch.length || typeof filters[c.columns] !== "undefined") {
                            data.anyMatchFlag = true;
                            data.anyMatchFilter = "" + (filters[c.columns] || wo.filter_$anyMatch && tsf.getLatestSearch(wo.filter_$anyMatch).val() || "");
                            if (wo.filter_columnAnyMatch) {
                                query = data.anyMatchFilter.split(tsfRegex.andSplit);
                                injected = false;
                                for (indx = 0; indx < query.length; indx++) {
                                    res = query[indx].split(":");
                                    if (res.length > 1) {
                                        if (isNaN(res[0])) {
                                            $.each(c.headerContent, function(i, txt) {
                                                if (txt.toLowerCase().indexOf(res[0]) > -1) {
                                                    id = i;
                                                    filters[id] = res[1];
                                                }
                                            });
                                        } else {
                                            id = parseInt(res[0], 10) - 1;
                                        }
                                        if (id >= 0 && id < c.columns) {
                                            filters[id] = res[1];
                                            query.splice(indx, 1);
                                            indx--;
                                            injected = true;
                                        }
                                    }
                                }
                                if (injected) {
                                    data.anyMatchFilter = query.join(" && ");
                                }
                            }
                        }
                        searchFiltered = wo.filter_searchFiltered;
                        lastSearch = c.lastSearch || c.$table.data("lastSearch") || [];
                        if (searchFiltered) {
                            for (indx = 0; indx < columnIndex + 1; indx++) {
                                val = filters[indx] || "";
                                if (!searchFiltered) {
                                    indx = columnIndex;
                                }
                                searchFiltered = searchFiltered && lastSearch.length && val.indexOf(lastSearch[indx] || "") === 0 && !tsfRegex.alreadyFiltered.test(val) && !tsfRegex.exactTest.test(val) && !(tsfRegex.isNeg1.test(val) || tsfRegex.isNeg2.test(val)) && !(val !== "" && c.$filters && c.$filters.filter('[data-column="' + indx + '"]').find("select").length && !tsf.matchType(c, indx));
                            }
                        }
                        notFiltered = $rows.not("." + wo.filter_filteredRow).length;
                        if (searchFiltered && notFiltered === 0) {
                            searchFiltered = false;
                        }
                        if (debug) {
                            console.log("Filter >> Searching through " + (searchFiltered && notFiltered < len ? notFiltered : "all") + " rows");
                        }
                        if (data.anyMatchFlag) {
                            if (c.sortLocaleCompare) {
                                data.anyMatchFilter = ts.replaceAccents(data.anyMatchFilter);
                            }
                            if (wo.filter_defaultFilter && tsfRegex.iQuery.test(vars.defaultAnyFilter)) {
                                data.anyMatchFilter = tsf.defaultFilter(data.anyMatchFilter, vars.defaultAnyFilter);
                                searchFiltered = false;
                            }
                            data.iAnyMatchFilter = !(wo.filter_ignoreCase && c.ignoreCase) ? data.anyMatchFilter : data.anyMatchFilter.toLowerCase();
                        }
                        for (rowIndex = 0; rowIndex < len; rowIndex++) {
                            txt = $rows[rowIndex].className;
                            isChild = rowIndex && tsfRegex.child.test(txt);
                            if (isChild || searchFiltered && tsfRegex.filtered.test(txt)) {
                                continue;
                            }
                            data.$row = $rows.eq(rowIndex);
                            data.rowIndex = rowIndex;
                            data.cacheArray = norm_rows[rowIndex];
                            rowData = data.cacheArray[c.columns];
                            data.rawArray = rowData.raw;
                            data.childRowText = "";
                            if (!wo.filter_childByColumn) {
                                txt = "";
                                childRow = rowData.child;
                                for (indx = 0; indx < childRow.length; indx++) {
                                    txt += " " + childRow[indx].join(" ") || "";
                                }
                                data.childRowText = wo.filter_childRows ? wo.filter_ignoreCase ? txt.toLowerCase() : txt : "";
                            }
                            showRow = false;
                            showParent = tsf.processRow(c, data, vars);
                            $row = rowData.$row;
                            val = showParent ? true : false;
                            childRow = rowData.$row.filter(":gt(0)");
                            if (wo.filter_childRows && childRow.length) {
                                if (wo.filter_childByColumn) {
                                    if (!wo.filter_childWithSibs) {
                                        childRow.addClass(wo.filter_filteredRow);
                                        $row = $row.eq(0);
                                    }
                                    for (indx = 0; indx < childRow.length; indx++) {
                                        data.$row = childRow.eq(indx);
                                        data.cacheArray = rowData.child[indx];
                                        data.rawArray = data.cacheArray;
                                        val = tsf.processRow(c, data, vars);
                                        showRow = showRow || val;
                                        if (!wo.filter_childWithSibs && val) {
                                            childRow.eq(indx).removeClass(wo.filter_filteredRow);
                                        }
                                    }
                                }
                                showRow = showRow || showParent;
                            } else {
                                showRow = val;
                            }
                            $row.toggleClass(wo.filter_filteredRow, !showRow)[0].display = showRow ? "" : "none";
                        }
                    }
                    c.filteredRows += $rows.not("." + wo.filter_filteredRow).length;
                    c.totalRows += $rows.length;
                    ts.processTbody(table, $tbody, false);
                }
                c.lastCombinedFilter = storedFilters.join("");
                c.lastSearch = storedFilters;
                c.$table.data("lastSearch", storedFilters);
                if (wo.filter_saveFilters && ts.storage) {
                    ts.storage(table, "tablesorter-filters", tsf.processFilters(storedFilters, true));
                }
                if (debug) {
                    console.log("Filter >> Completed search" + ts.benchmark(time));
                }
                if (wo.filter_initialized) {
                    c.$table.triggerHandler("filterBeforeEnd", c);
                    c.$table.triggerHandler("filterEnd", c);
                }
                setTimeout(function() {
                    ts.applyWidget(c.table);
                }, 0);
            },
            getOptionSource: function(table, column, onlyAvail) {
                table = $(table)[0];
                var c = table.config, wo = c.widgetOptions, arry = false, source = wo.filter_selectSource, last = c.$table.data("lastSearch") || [], fxn = typeof source === "function" ? true : ts.getColumnData(table, source, column);
                if (onlyAvail && last[column] !== "") {
                    onlyAvail = false;
                }
                if (fxn === true) {
                    arry = source(table, column, onlyAvail);
                } else if (fxn instanceof $ || $.type(fxn) === "string" && fxn.indexOf("</option>") >= 0) {
                    return fxn;
                } else if ($.isArray(fxn)) {
                    arry = fxn;
                } else if ($.type(source) === "object" && fxn) {
                    arry = fxn(table, column, onlyAvail);
                    if (arry === null) {
                        return null;
                    }
                }
                if (arry === false) {
                    arry = tsf.getOptions(table, column, onlyAvail);
                }
                return tsf.processOptions(table, column, arry);
            },
            processOptions: function(table, column, arry) {
                if (!$.isArray(arry)) {
                    return false;
                }
                table = $(table)[0];
                var cts, txt, indx, len, parsedTxt, str, c = table.config, validColumn = typeof column !== "undefined" && column !== null && column >= 0 && column < c.columns, direction = validColumn ? c.$headerIndexed[column].hasClass("filter-select-sort-desc") : false, parsed = [];
                arry = $.grep(arry, function(value, indx) {
                    if (value.text) {
                        return true;
                    }
                    return $.inArray(value, arry) === indx;
                });
                if (validColumn && c.$headerIndexed[column].hasClass("filter-select-nosort")) {
                    return arry;
                } else {
                    len = arry.length;
                    for (indx = 0; indx < len; indx++) {
                        txt = arry[indx];
                        str = txt.text ? txt.text : txt;
                        parsedTxt = (validColumn && c.parsers && c.parsers.length && c.parsers[column].format(str, table, [], column) || str).toString();
                        parsedTxt = c.widgetOptions.filter_ignoreCase ? parsedTxt.toLowerCase() : parsedTxt;
                        if (txt.text) {
                            txt.parsed = parsedTxt;
                            parsed[parsed.length] = txt;
                        } else {
                            parsed[parsed.length] = {
                                text: txt,
                                parsed: parsedTxt
                            };
                        }
                    }
                    cts = c.textSorter || "";
                    parsed.sort(function(a, b) {
                        var x = direction ? b.parsed : a.parsed, y = direction ? a.parsed : b.parsed;
                        if (validColumn && typeof cts === "function") {
                            return cts(x, y, true, column, table);
                        } else if (validColumn && typeof cts === "object" && cts.hasOwnProperty(column)) {
                            return cts[column](x, y, true, column, table);
                        } else if (ts.sortNatural) {
                            return ts.sortNatural(x, y);
                        }
                        return true;
                    });
                    arry = [];
                    len = parsed.length;
                    for (indx = 0; indx < len; indx++) {
                        arry[arry.length] = parsed[indx];
                    }
                    return arry;
                }
            },
            getOptions: function(table, column, onlyAvail) {
                table = $(table)[0];
                var rowIndex, tbodyIndex, len, row, cache, indx, child, childLen, c = table.config, wo = c.widgetOptions, arry = [];
                for (tbodyIndex = 0; tbodyIndex < c.$tbodies.length; tbodyIndex++) {
                    cache = c.cache[tbodyIndex];
                    len = c.cache[tbodyIndex].normalized.length;
                    for (rowIndex = 0; rowIndex < len; rowIndex++) {
                        row = cache.row ? cache.row[rowIndex] : cache.normalized[rowIndex][c.columns].$row[0];
                        if (onlyAvail && row.className.match(wo.filter_filteredRow)) {
                            continue;
                        }
                        if (wo.filter_useParsedData || c.parsers[column].parsed || c.$headerIndexed[column].hasClass("filter-parsed")) {
                            arry[arry.length] = "" + cache.normalized[rowIndex][column];
                            if (wo.filter_childRows && wo.filter_childByColumn) {
                                childLen = cache.normalized[rowIndex][c.columns].$row.length - 1;
                                for (indx = 0; indx < childLen; indx++) {
                                    arry[arry.length] = "" + cache.normalized[rowIndex][c.columns].child[indx][column];
                                }
                            }
                        } else {
                            arry[arry.length] = cache.normalized[rowIndex][c.columns].raw[column];
                            if (wo.filter_childRows && wo.filter_childByColumn) {
                                childLen = cache.normalized[rowIndex][c.columns].$row.length;
                                for (indx = 1; indx < childLen; indx++) {
                                    child = cache.normalized[rowIndex][c.columns].$row.eq(indx).children().eq(column);
                                    arry[arry.length] = "" + ts.getElementText(c, child, column);
                                }
                            }
                        }
                    }
                }
                return arry;
            },
            buildSelect: function(table, column, arry, updating, onlyAvail) {
                table = $(table)[0];
                column = parseInt(column, 10);
                if (!table.config.cache || $.isEmptyObject(table.config.cache)) {
                    return;
                }
                var indx, val, txt, t, $filters, $filter, option, c = table.config, wo = c.widgetOptions, node = c.$headerIndexed[column], options = '<option value="">' + (node.data("placeholder") || node.attr("data-placeholder") || wo.filter_placeholder.select || "") + "</option>", currentValue = c.$table.find("thead").find("select." + tscss.filter + '[data-column="' + column + '"]').val();
                if (typeof arry === "undefined" || arry === "") {
                    arry = tsf.getOptionSource(table, column, onlyAvail);
                    if (arry === null) {
                        return;
                    }
                }
                if ($.isArray(arry)) {
                    for (indx = 0; indx < arry.length; indx++) {
                        option = arry[indx];
                        if (option.text) {
                            option["data-function-name"] = typeof option.value === "undefined" ? option.text : option.value;
                            options += "<option";
                            for (val in option) {
                                if (option.hasOwnProperty(val) && val !== "text") {
                                    options += " " + val + '="' + option[val].replace(tsfRegex.quote, "&quot;") + '"';
                                }
                            }
                            if (!option.value) {
                                options += ' value="' + option.text.replace(tsfRegex.quote, "&quot;") + '"';
                            }
                            options += ">" + option.text.replace(tsfRegex.quote, "&quot;") + "</option>";
                        } else if ("" + option !== "[object Object]") {
                            txt = option = ("" + option).replace(tsfRegex.quote, "&quot;");
                            val = txt;
                            if (txt.indexOf(wo.filter_selectSourceSeparator) >= 0) {
                                t = txt.split(wo.filter_selectSourceSeparator);
                                val = t[0];
                                txt = t[1];
                            }
                            options += option !== "" ? "<option " + (val === txt ? "" : 'data-function-name="' + option + '" ') + 'value="' + val + '">' + txt + "</option>" : "";
                        }
                    }
                    arry = [];
                }
                $filters = (c.$filters ? c.$filters : c.$table.children("thead")).find("." + tscss.filter);
                if (wo.filter_$externalFilters) {
                    $filters = $filters && $filters.length ? $filters.add(wo.filter_$externalFilters) : wo.filter_$externalFilters;
                }
                $filter = $filters.filter('select[data-column="' + column + '"]');
                if ($filter.length) {
                    $filter[updating ? "html" : "append"](options);
                    if (!$.isArray(arry)) {
                        $filter.append(arry).val(currentValue);
                    }
                    $filter.val(currentValue);
                }
            },
            buildDefault: function(table, updating) {
                var columnIndex, $header, noSelect, c = table.config, wo = c.widgetOptions, columns = c.columns;
                for (columnIndex = 0; columnIndex < columns; columnIndex++) {
                    $header = c.$headerIndexed[columnIndex];
                    noSelect = !($header.hasClass("filter-false") || $header.hasClass("parser-false"));
                    if (($header.hasClass("filter-select") || ts.getColumnData(table, wo.filter_functions, columnIndex) === true) && noSelect) {
                        tsf.buildSelect(table, columnIndex, "", updating, $header.hasClass(wo.filter_onlyAvail));
                    }
                }
            }
        };
        tsfRegex = tsf.regex;
        ts.getFilters = function(table, getRaw, setFilters, skipFirst) {
            var i, $filters, $column, cols, filters = [], c = table ? $(table)[0].config : "", wo = c ? c.widgetOptions : "";
            if (getRaw !== true && wo && !wo.filter_columnFilters || $.isArray(setFilters) && tsf.equalFilters(c, setFilters, c.lastSearch)) {
                return $(table).data("lastSearch") || [];
            }
            if (c) {
                if (c.$filters) {
                    $filters = c.$filters.find("." + tscss.filter);
                }
                if (wo.filter_$externalFilters) {
                    $filters = $filters && $filters.length ? $filters.add(wo.filter_$externalFilters) : wo.filter_$externalFilters;
                }
                if ($filters && $filters.length) {
                    filters = setFilters || [];
                    for (i = 0; i < c.columns + 1; i++) {
                        cols = i === c.columns ? wo.filter_anyColumnSelector + "," + wo.filter_multipleColumnSelector : '[data-column="' + i + '"]';
                        $column = $filters.filter(cols);
                        if ($column.length) {
                            $column = tsf.getLatestSearch($column);
                            if ($.isArray(setFilters)) {
                                if (skipFirst && $column.length > 1) {
                                    $column = $column.slice(1);
                                }
                                if (i === c.columns) {
                                    cols = $column.filter(wo.filter_anyColumnSelector);
                                    $column = cols.length ? cols : $column;
                                }
                                $column.val(setFilters[i]).trigger("change" + c.namespace);
                            } else {
                                filters[i] = $column.val() || "";
                                if (i === c.columns) {
                                    $column.slice(1).filter('[data-column*="' + $column.attr("data-column") + '"]').val(filters[i]);
                                } else {
                                    $column.slice(1).val(filters[i]);
                                }
                            }
                            if (i === c.columns && $column.length) {
                                wo.filter_$anyMatch = $column;
                            }
                        }
                    }
                }
            }
            return filters;
        };
        ts.setFilters = function(table, filter, apply, skipFirst) {
            var c = table ? $(table)[0].config : "", valid = ts.getFilters(table, true, filter, skipFirst);
            if (typeof apply === "undefined") {
                apply = true;
            }
            if (c && apply) {
                c.lastCombinedFilter = null;
                c.lastSearch = [];
                tsf.searching(c.table, filter, skipFirst);
                c.$table.triggerHandler("filterFomatterUpdate");
            }
            return valid.length !== 0;
        };
    })(jQuery);
    (function($, window) {
        "use strict";
        var ts = $.tablesorter || {};
        $.extend(ts.css, {
            sticky: "tablesorter-stickyHeader",
            stickyVis: "tablesorter-sticky-visible",
            stickyHide: "tablesorter-sticky-hidden",
            stickyWrap: "tablesorter-sticky-wrapper"
        });
        ts.addHeaderResizeEvent = function(table, disable, settings) {
            table = $(table)[0];
            if (!table.config) {
                return;
            }
            var defaults = {
                timer: 250
            }, options = $.extend({}, defaults, settings), c = table.config, wo = c.widgetOptions, checkSizes = function(triggerEvent) {
                var index, headers, $header, sizes, width, height, len = c.$headers.length;
                wo.resize_flag = true;
                headers = [];
                for (index = 0; index < len; index++) {
                    $header = c.$headers.eq(index);
                    sizes = $header.data("savedSizes") || [ 0, 0 ];
                    width = $header[0].offsetWidth;
                    height = $header[0].offsetHeight;
                    if (width !== sizes[0] || height !== sizes[1]) {
                        $header.data("savedSizes", [ width, height ]);
                        headers.push($header[0]);
                    }
                }
                if (headers.length && triggerEvent !== false) {
                    c.$table.triggerHandler("resize", [ headers ]);
                }
                wo.resize_flag = false;
            };
            clearInterval(wo.resize_timer);
            if (disable) {
                wo.resize_flag = false;
                return false;
            }
            checkSizes(false);
            wo.resize_timer = setInterval(function() {
                if (wo.resize_flag) {
                    return;
                }
                checkSizes();
            }, options.timer);
        };
        function getStickyOffset(c, wo) {
            var $el = isNaN(wo.stickyHeaders_offset) ? $(wo.stickyHeaders_offset) : [];
            return $el.length ? $el.height() || 0 : parseInt(wo.stickyHeaders_offset, 10) || 0;
        }
        ts.addWidget({
            id: "stickyHeaders",
            priority: 54,
            options: {
                stickyHeaders: "",
                stickyHeaders_appendTo: null,
                stickyHeaders_attachTo: null,
                stickyHeaders_xScroll: null,
                stickyHeaders_yScroll: null,
                stickyHeaders_offset: 0,
                stickyHeaders_filteredToTop: true,
                stickyHeaders_cloneId: "-sticky",
                stickyHeaders_addResizeEvent: true,
                stickyHeaders_includeCaption: true,
                stickyHeaders_zIndex: 2
            },
            format: function(table, c, wo) {
                if (c.$table.hasClass("hasStickyHeaders") || $.inArray("filter", c.widgets) >= 0 && !c.$table.hasClass("hasFilters")) {
                    return;
                }
                var index, len, $t, $table = c.$table, $attach = $(wo.stickyHeaders_attachTo || wo.stickyHeaders_appendTo), namespace = c.namespace + "stickyheaders ", $yScroll = $(wo.stickyHeaders_yScroll || wo.stickyHeaders_attachTo || window), $xScroll = $(wo.stickyHeaders_xScroll || wo.stickyHeaders_attachTo || window), $thead = $table.children("thead:first"), $header = $thead.children("tr").not(".sticky-false").children(), $tfoot = $table.children("tfoot"), stickyOffset = getStickyOffset(c, wo), $nestedSticky = $table.parent().closest("." + ts.css.table).hasClass("hasStickyHeaders") ? $table.parent().closest("table.tablesorter")[0].config.widgetOptions.$sticky.parent() : [], nestedStickyTop = $nestedSticky.length ? $nestedSticky.height() : 0, $stickyTable = wo.$sticky = $table.clone().addClass("containsStickyHeaders " + ts.css.sticky + " " + wo.stickyHeaders + " " + c.namespace.slice(1) + "_extra_table").wrap('<div class="' + ts.css.stickyWrap + '">'), $stickyWrap = $stickyTable.parent().addClass(ts.css.stickyHide).css({
                    position: $attach.length ? "absolute" : "fixed",
                    padding: parseInt($stickyTable.parent().parent().css("padding-left"), 10),
                    top: stickyOffset + nestedStickyTop,
                    left: 0,
                    visibility: "hidden",
                    zIndex: wo.stickyHeaders_zIndex || 2
                }), $stickyThead = $stickyTable.children("thead:first"), $stickyCells, laststate = "", setWidth = function($orig, $clone) {
                    var index, width, border, $cell, $this, $cells = $orig.filter(":visible"), len = $cells.length;
                    for (index = 0; index < len; index++) {
                        $cell = $clone.filter(":visible").eq(index);
                        $this = $cells.eq(index);
                        if ($this.css("box-sizing") === "border-box") {
                            width = $this.outerWidth();
                        } else {
                            if ($cell.css("border-collapse") === "collapse") {
                                if (window.getComputedStyle) {
                                    width = parseFloat(window.getComputedStyle($this[0], null).width);
                                } else {
                                    border = parseFloat($this.css("border-width"));
                                    width = $this.outerWidth() - parseFloat($this.css("padding-left")) - parseFloat($this.css("padding-right")) - border;
                                }
                            } else {
                                width = $this.width();
                            }
                        }
                        $cell.css({
                            width: width,
                            "min-width": width,
                            "max-width": width
                        });
                    }
                }, getLeftPosition = function(yWindow) {
                    if (yWindow === false && $nestedSticky.length) {
                        return $table.position().left;
                    }
                    return $attach.length ? parseInt($attach.css("padding-left"), 10) || 0 : $table.offset().left - parseInt($table.css("margin-left"), 10) - $(window).scrollLeft();
                }, resizeHeader = function() {
                    $stickyWrap.css({
                        left: getLeftPosition(),
                        width: $table.outerWidth()
                    });
                    setWidth($table, $stickyTable);
                    setWidth($header, $stickyCells);
                }, scrollSticky = function(resizing) {
                    if (!$table.is(":visible")) {
                        return;
                    }
                    nestedStickyTop = $nestedSticky.length ? $nestedSticky.offset().top - $yScroll.scrollTop() + $nestedSticky.height() : 0;
                    var tmp, offset = $table.offset(), stickyOffset = getStickyOffset(c, wo), yWindow = $.isWindow($yScroll[0]), yScroll = yWindow ? $yScroll.scrollTop() : $nestedSticky.length ? parseInt($nestedSticky[0].style.top, 10) : $yScroll.offset().top, attachTop = $attach.length ? yScroll : $yScroll.scrollTop(), captionHeight = wo.stickyHeaders_includeCaption ? 0 : $table.children("caption").height() || 0, scrollTop = attachTop + stickyOffset + nestedStickyTop - captionHeight, tableHeight = $table.height() - ($stickyWrap.height() + ($tfoot.height() || 0)) - captionHeight, isVisible = scrollTop > offset.top && scrollTop < offset.top + tableHeight ? "visible" : "hidden", state = isVisible === "visible" ? ts.css.stickyVis : ts.css.stickyHide, needsUpdating = !$stickyWrap.hasClass(state), cssSettings = {
                        visibility: isVisible
                    };
                    if ($attach.length) {
                        needsUpdating = true;
                        cssSettings.top = yWindow ? scrollTop - $attach.offset().top : $attach.scrollTop();
                    }
                    tmp = getLeftPosition(yWindow);
                    if (tmp !== parseInt($stickyWrap.css("left"), 10)) {
                        needsUpdating = true;
                        cssSettings.left = tmp;
                    }
                    cssSettings.top = (cssSettings.top || 0) + (!yWindow && $nestedSticky.length ? $nestedSticky.height() : stickyOffset + nestedStickyTop);
                    if (needsUpdating) {
                        $stickyWrap.removeClass(ts.css.stickyVis + " " + ts.css.stickyHide).addClass(state).css(cssSettings);
                    }
                    if (isVisible !== laststate || resizing) {
                        resizeHeader();
                        laststate = isVisible;
                    }
                };
                if ($attach.length && !$attach.css("position")) {
                    $attach.css("position", "relative");
                }
                if ($stickyTable.attr("id")) {
                    $stickyTable[0].id += wo.stickyHeaders_cloneId;
                }
                $stickyTable.find("> thead:gt(0), tr.sticky-false").hide();
                $stickyTable.find("> tbody, > tfoot").remove();
                $stickyTable.find("caption").toggle(wo.stickyHeaders_includeCaption);
                $stickyCells = $stickyThead.children().children();
                $stickyTable.css({
                    height: 0,
                    width: 0,
                    margin: 0
                });
                $stickyCells.find("." + ts.css.resizer).remove();
                $table.addClass("hasStickyHeaders").bind("pagerComplete" + namespace, function() {
                    resizeHeader();
                });
                ts.bindEvents(table, $stickyThead.children().children("." + ts.css.header));
                if (wo.stickyHeaders_appendTo) {
                    $(wo.stickyHeaders_appendTo).append($stickyWrap);
                } else {
                    $table.after($stickyWrap);
                }
                if (c.onRenderHeader) {
                    $t = $stickyThead.children("tr").children();
                    len = $t.length;
                    for (index = 0; index < len; index++) {
                        c.onRenderHeader.apply($t.eq(index), [ index, c, $stickyTable ]);
                    }
                }
                $xScroll.add($yScroll).unbind("scroll resize ".split(" ").join(namespace).replace(/\s+/g, " ")).bind("scroll resize ".split(" ").join(namespace), function(event) {
                    scrollSticky(event.type === "resize");
                });
                c.$table.unbind("stickyHeadersUpdate" + namespace).bind("stickyHeadersUpdate" + namespace, function() {
                    scrollSticky(true);
                });
                if (wo.stickyHeaders_addResizeEvent) {
                    ts.addHeaderResizeEvent(table);
                }
                if ($table.hasClass("hasFilters") && wo.filter_columnFilters) {
                    $table.bind("filterEnd" + namespace, function() {
                        var $td = $(document.activeElement).closest("td"), column = $td.parent().children().index($td);
                        if ($stickyWrap.hasClass(ts.css.stickyVis) && wo.stickyHeaders_filteredToTop) {
                            window.scrollTo(0, $table.position().top);
                            if (column >= 0 && c.$filters) {
                                c.$filters.eq(column).find("a, select, input").filter(":visible").focus();
                            }
                        }
                    });
                    ts.filter.bindSearch($table, $stickyCells.find("." + ts.css.filter));
                    if (wo.filter_hideFilters) {
                        ts.filter.hideFilters(c, $stickyTable);
                    }
                }
                if (wo.stickyHeaders_addResizeEvent) {
                    $table.bind("resize" + c.namespace + "stickyheaders", function() {
                        resizeHeader();
                    });
                }
                scrollSticky(true);
                $table.triggerHandler("stickyHeadersInit");
            },
            remove: function(table, c, wo) {
                var namespace = c.namespace + "stickyheaders ";
                c.$table.removeClass("hasStickyHeaders").unbind("pagerComplete resize filterEnd stickyHeadersUpdate ".split(" ").join(namespace).replace(/\s+/g, " ")).next("." + ts.css.stickyWrap).remove();
                if (wo.$sticky && wo.$sticky.length) {
                    wo.$sticky.remove();
                }
                $(window).add(wo.stickyHeaders_xScroll).add(wo.stickyHeaders_yScroll).add(wo.stickyHeaders_attachTo).unbind("scroll resize ".split(" ").join(namespace).replace(/\s+/g, " "));
                ts.addHeaderResizeEvent(table, true);
            }
        });
    })(jQuery, window);
    (function($, window) {
        "use strict";
        var ts = $.tablesorter || {};
        $.extend(ts.css, {
            resizableContainer: "tablesorter-resizable-container",
            resizableHandle: "tablesorter-resizable-handle",
            resizableNoSelect: "tablesorter-disableSelection",
            resizableStorage: "tablesorter-resizable"
        });
        $(function() {
            var s = "<style>" + "body." + ts.css.resizableNoSelect + " { -ms-user-select: none; -moz-user-select: -moz-none;" + "-khtml-user-select: none; -webkit-user-select: none; user-select: none; }" + "." + ts.css.resizableContainer + " { position: relative; height: 1px; }" + "." + ts.css.resizableHandle + " { position: absolute; display: inline-block; width: 8px;" + "top: 1px; cursor: ew-resize; z-index: 3; user-select: none; -moz-user-select: none; }" + "</style>";
            $("head").append(s);
        });
        ts.resizable = {
            init: function(c, wo) {
                if (c.$table.hasClass("hasResizable")) {
                    return;
                }
                c.$table.addClass("hasResizable");
                var noResize, $header, column, storedSizes, tmp, $table = c.$table, $parent = $table.parent(), marginTop = parseInt($table.css("margin-top"), 10), vars = wo.resizable_vars = {
                    useStorage: ts.storage && wo.resizable !== false,
                    $wrap: $parent,
                    mouseXPosition: 0,
                    $target: null,
                    $next: null,
                    overflow: $parent.css("overflow") === "auto" || $parent.css("overflow") === "scroll" || $parent.css("overflow-x") === "auto" || $parent.css("overflow-x") === "scroll",
                    storedSizes: []
                };
                ts.resizableReset(c.table, true);
                vars.tableWidth = $table.width();
                vars.fullWidth = Math.abs($parent.width() - vars.tableWidth) < 20;
                if (vars.useStorage && vars.overflow) {
                    ts.storage(c.table, "tablesorter-table-original-css-width", vars.tableWidth);
                    tmp = ts.storage(c.table, "tablesorter-table-resized-width") || "auto";
                    ts.resizable.setWidth($table, tmp, true);
                }
                wo.resizable_vars.storedSizes = storedSizes = (vars.useStorage ? ts.storage(c.table, ts.css.resizableStorage) : []) || [];
                ts.resizable.setWidths(c, wo, storedSizes);
                ts.resizable.updateStoredSizes(c, wo);
                wo.$resizable_container = $('<div class="' + ts.css.resizableContainer + '">').css({
                    top: marginTop
                }).insertBefore($table);
                for (column = 0; column < c.columns; column++) {
                    $header = c.$headerIndexed[column];
                    tmp = ts.getColumnData(c.table, c.headers, column);
                    noResize = ts.getData($header, tmp, "resizable") === "false";
                    if (!noResize) {
                        $('<div class="' + ts.css.resizableHandle + '">').appendTo(wo.$resizable_container).attr({
                            "data-column": column,
                            unselectable: "on"
                        }).data("header", $header).bind("selectstart", false);
                    }
                }
                ts.resizable.bindings(c, wo);
            },
            updateStoredSizes: function(c, wo) {
                var column, $header, len = c.columns, vars = wo.resizable_vars;
                vars.storedSizes = [];
                for (column = 0; column < len; column++) {
                    $header = c.$headerIndexed[column];
                    vars.storedSizes[column] = $header.is(":visible") ? $header.width() : 0;
                }
            },
            setWidth: function($el, width, overflow) {
                $el.css({
                    width: width,
                    "min-width": overflow ? width : "",
                    "max-width": overflow ? width : ""
                });
            },
            setWidths: function(c, wo, storedSizes) {
                var column, $temp, vars = wo.resizable_vars, $extra = $(c.namespace + "_extra_headers"), $col = c.$table.children("colgroup").children("col");
                storedSizes = storedSizes || vars.storedSizes || [];
                if (storedSizes.length) {
                    for (column = 0; column < c.columns; column++) {
                        ts.resizable.setWidth(c.$headerIndexed[column], storedSizes[column], vars.overflow);
                        if ($extra.length) {
                            $temp = $extra.eq(column).add($col.eq(column));
                            ts.resizable.setWidth($temp, storedSizes[column], vars.overflow);
                        }
                    }
                    $temp = $(c.namespace + "_extra_table");
                    if ($temp.length && !ts.hasWidget(c.table, "scroller")) {
                        ts.resizable.setWidth($temp, c.$table.outerWidth(), vars.overflow);
                    }
                }
            },
            setHandlePosition: function(c, wo) {
                var startPosition, tableHeight = c.$table.height(), $handles = wo.$resizable_container.children(), handleCenter = Math.floor($handles.width() / 2);
                if (ts.hasWidget(c.table, "scroller")) {
                    tableHeight = 0;
                    c.$table.closest("." + ts.css.scrollerWrap).children().each(function() {
                        var $this = $(this);
                        tableHeight += $this.filter('[style*="height"]').length ? $this.height() : $this.children("table").height();
                    });
                }
                if (!wo.resizable_includeFooter && c.$table.children("tfoot").length) {
                    tableHeight -= c.$table.children("tfoot").height();
                }
                startPosition = parseFloat($.fn.jquery) >= 3.3 ? 0 : c.$table.position().left;
                $handles.each(function() {
                    var $this = $(this), column = parseInt($this.attr("data-column"), 10), columns = c.columns - 1, $header = $this.data("header");
                    if (!$header) {
                        return;
                    }
                    if (!$header.is(":visible") || !wo.resizable_addLastColumn && ts.resizable.checkVisibleColumns(c, column)) {
                        $this.hide();
                    } else if (column < columns || column === columns && wo.resizable_addLastColumn) {
                        $this.css({
                            display: "inline-block",
                            height: tableHeight,
                            left: $header.position().left - startPosition + $header.outerWidth() - handleCenter
                        });
                    }
                });
            },
            checkVisibleColumns: function(c, column) {
                var i, len = 0;
                for (i = column + 1; i < c.columns; i++) {
                    len += c.$headerIndexed[i].is(":visible") ? 1 : 0;
                }
                return len === 0;
            },
            toggleTextSelection: function(c, wo, toggle) {
                var namespace = c.namespace + "tsresize";
                wo.resizable_vars.disabled = toggle;
                $("body").toggleClass(ts.css.resizableNoSelect, toggle);
                if (toggle) {
                    $("body").attr("unselectable", "on").bind("selectstart" + namespace, false);
                } else {
                    $("body").removeAttr("unselectable").unbind("selectstart" + namespace);
                }
            },
            bindings: function(c, wo) {
                var namespace = c.namespace + "tsresize";
                wo.$resizable_container.children().bind("mousedown", function(event) {
                    var column, vars = wo.resizable_vars, $extras = $(c.namespace + "_extra_headers"), $header = $(event.target).data("header");
                    column = parseInt($header.attr("data-column"), 10);
                    vars.$target = $header = $header.add($extras.filter('[data-column="' + column + '"]'));
                    vars.target = column;
                    vars.$next = event.shiftKey || wo.resizable_targetLast ? $header.parent().children().not(".resizable-false").filter(":last") : $header.nextAll(":not(.resizable-false)").eq(0);
                    column = parseInt(vars.$next.attr("data-column"), 10);
                    vars.$next = vars.$next.add($extras.filter('[data-column="' + column + '"]'));
                    vars.next = column;
                    vars.mouseXPosition = event.pageX;
                    ts.resizable.updateStoredSizes(c, wo);
                    ts.resizable.toggleTextSelection(c, wo, true);
                });
                $(document).bind("mousemove" + namespace, function(event) {
                    var vars = wo.resizable_vars;
                    if (!vars.disabled || vars.mouseXPosition === 0 || !vars.$target) {
                        return;
                    }
                    if (wo.resizable_throttle) {
                        clearTimeout(vars.timer);
                        vars.timer = setTimeout(function() {
                            ts.resizable.mouseMove(c, wo, event);
                        }, isNaN(wo.resizable_throttle) ? 5 : wo.resizable_throttle);
                    } else {
                        ts.resizable.mouseMove(c, wo, event);
                    }
                }).bind("mouseup" + namespace, function() {
                    if (!wo.resizable_vars.disabled) {
                        return;
                    }
                    ts.resizable.toggleTextSelection(c, wo, false);
                    ts.resizable.stopResize(c, wo);
                    ts.resizable.setHandlePosition(c, wo);
                });
                $(window).bind("resize" + namespace + " resizeEnd" + namespace, function() {
                    ts.resizable.setHandlePosition(c, wo);
                });
                c.$table.bind("columnUpdate pagerComplete resizableUpdate ".split(" ").join(namespace + " "), function() {
                    ts.resizable.setHandlePosition(c, wo);
                }).bind("resizableReset" + namespace, function() {
                    ts.resizableReset(c.table);
                }).find("thead:first").add($(c.namespace + "_extra_table").find("thead:first")).bind("contextmenu" + namespace, function() {
                    var allowClick = wo.resizable_vars.storedSizes.length === 0;
                    ts.resizableReset(c.table);
                    ts.resizable.setHandlePosition(c, wo);
                    wo.resizable_vars.storedSizes = [];
                    return allowClick;
                });
            },
            mouseMove: function(c, wo, event) {
                if (wo.resizable_vars.mouseXPosition === 0 || !wo.resizable_vars.$target) {
                    return;
                }
                var column, total = 0, vars = wo.resizable_vars, $next = vars.$next, tar = vars.storedSizes[vars.target], leftEdge = event.pageX - vars.mouseXPosition;
                if (vars.overflow) {
                    if (tar + leftEdge > 0) {
                        vars.storedSizes[vars.target] += leftEdge;
                        ts.resizable.setWidth(vars.$target, vars.storedSizes[vars.target], true);
                        for (column = 0; column < c.columns; column++) {
                            total += vars.storedSizes[column];
                        }
                        ts.resizable.setWidth(c.$table.add($(c.namespace + "_extra_table")), total);
                    }
                    if (!$next.length) {
                        vars.$wrap[0].scrollLeft = c.$table.width();
                    }
                } else if (vars.fullWidth) {
                    vars.storedSizes[vars.target] += leftEdge;
                    vars.storedSizes[vars.next] -= leftEdge;
                    ts.resizable.setWidths(c, wo);
                } else {
                    vars.storedSizes[vars.target] += leftEdge;
                    ts.resizable.setWidths(c, wo);
                }
                vars.mouseXPosition = event.pageX;
                c.$table.triggerHandler("stickyHeadersUpdate");
            },
            stopResize: function(c, wo) {
                var vars = wo.resizable_vars;
                ts.resizable.updateStoredSizes(c, wo);
                if (vars.useStorage) {
                    ts.storage(c.table, ts.css.resizableStorage, vars.storedSizes);
                    ts.storage(c.table, "tablesorter-table-resized-width", c.$table.width());
                }
                vars.mouseXPosition = 0;
                vars.$target = vars.$next = null;
                c.$table.triggerHandler("stickyHeadersUpdate");
                c.$table.triggerHandler("resizableComplete");
            }
        };
        ts.addWidget({
            id: "resizable",
            priority: 40,
            options: {
                resizable: true,
                resizable_addLastColumn: false,
                resizable_includeFooter: true,
                resizable_widths: [],
                resizable_throttle: false,
                resizable_targetLast: false
            },
            init: function(table, thisWidget, c, wo) {
                ts.resizable.init(c, wo);
            },
            format: function(table, c, wo) {
                ts.resizable.setHandlePosition(c, wo);
            },
            remove: function(table, c, wo, refreshing) {
                if (wo.$resizable_container) {
                    var namespace = c.namespace + "tsresize";
                    c.$table.add($(c.namespace + "_extra_table")).removeClass("hasResizable").children("thead").unbind("contextmenu" + namespace);
                    wo.$resizable_container.remove();
                    ts.resizable.toggleTextSelection(c, wo, false);
                    ts.resizableReset(table, refreshing);
                    $(document).unbind("mousemove" + namespace + " mouseup" + namespace);
                }
            }
        });
        ts.resizableReset = function(table, refreshing) {
            $(table).each(function() {
                var index, $t, c = this.config, wo = c && c.widgetOptions, vars = wo.resizable_vars;
                if (table && c && c.$headerIndexed.length) {
                    if (vars.overflow && vars.tableWidth) {
                        ts.resizable.setWidth(c.$table, vars.tableWidth, true);
                        if (vars.useStorage) {
                            ts.storage(table, "tablesorter-table-resized-width", vars.tableWidth);
                        }
                    }
                    for (index = 0; index < c.columns; index++) {
                        $t = c.$headerIndexed[index];
                        if (wo.resizable_widths && wo.resizable_widths[index]) {
                            ts.resizable.setWidth($t, wo.resizable_widths[index], vars.overflow);
                        } else if (!$t.hasClass("resizable-false")) {
                            ts.resizable.setWidth($t, "", vars.overflow);
                        }
                    }
                    c.$table.triggerHandler("stickyHeadersUpdate");
                    if (ts.storage && !refreshing) {
                        ts.storage(this, ts.css.resizableStorage, []);
                    }
                }
            });
        };
    })(jQuery, window);
    (function($) {
        "use strict";
        var ts = $.tablesorter || {};
        function getStoredSortList(c) {
            var stored = ts.storage(c.table, "tablesorter-savesort");
            return stored && stored.hasOwnProperty("sortList") && $.isArray(stored.sortList) ? stored.sortList : [];
        }
        function sortListChanged(c, sortList) {
            return (sortList || getStoredSortList(c)).join(",") !== c.sortList.join(",");
        }
        ts.addWidget({
            id: "saveSort",
            priority: 20,
            options: {
                saveSort: true
            },
            init: function(table, thisWidget, c, wo) {
                thisWidget.format(table, c, wo, true);
            },
            format: function(table, c, wo, init) {
                var time, $table = c.$table, saveSort = wo.saveSort !== false, sortList = {
                    sortList: c.sortList
                }, debug = ts.debug(c, "saveSort");
                if (debug) {
                    time = new Date();
                }
                if ($table.hasClass("hasSaveSort")) {
                    if (saveSort && table.hasInitialized && ts.storage && sortListChanged(c)) {
                        ts.storage(table, "tablesorter-savesort", sortList);
                        if (debug) {
                            console.log("saveSort >> Saving last sort: " + c.sortList + ts.benchmark(time));
                        }
                    }
                } else {
                    $table.addClass("hasSaveSort");
                    sortList = "";
                    if (ts.storage) {
                        sortList = getStoredSortList(c);
                        if (debug) {
                            console.log('saveSort >> Last sort loaded: "' + sortList + '"' + ts.benchmark(time));
                        }
                        $table.bind("saveSortReset", function(event) {
                            event.stopPropagation();
                            ts.storage(table, "tablesorter-savesort", "");
                        });
                    }
                    if (init && sortList && sortList.length > 0) {
                        c.sortList = sortList;
                    } else if (table.hasInitialized && sortList && sortList.length > 0) {
                        if (sortListChanged(c, sortList)) {
                            ts.sortOn(c, sortList);
                        }
                    }
                }
            },
            remove: function(table, c) {
                c.$table.removeClass("hasSaveSort");
                if (ts.storage) {
                    ts.storage(table, "tablesorter-savesort", "");
                }
            }
        });
    })(jQuery);
    return jQuery.tablesorter;
});

(function($) {
    "use strict";
    var ts = $.tablesorter;
    $.extend({
        tablesorterPager: new function() {
            this.defaults = {
                container: null,
                ajaxUrl: null,
                customAjaxUrl: function(table, url) {
                    return url;
                },
                ajaxError: null,
                ajaxObject: {
                    dataType: "json"
                },
                processAjaxOnInit: true,
                ajaxProcessing: function(data) {
                    return data;
                },
                output: "{startRow} to {endRow} of {totalRows} rows",
                updateArrows: true,
                page: 0,
                pageReset: 0,
                size: 10,
                maxOptionSize: 20,
                savePages: true,
                storageKey: "tablesorter-pager",
                fixedHeight: false,
                countChildRows: false,
                removeRows: false,
                cssFirst: ".first",
                cssPrev: ".prev",
                cssNext: ".next",
                cssLast: ".last",
                cssGoto: ".gotoPage",
                cssPageDisplay: ".pagedisplay",
                cssPageSize: ".pagesize",
                cssErrorRow: "tablesorter-errorRow",
                cssDisabled: "disabled",
                totalRows: 0,
                totalPages: 0,
                filteredRows: 0,
                filteredPages: 0,
                ajaxCounter: 0,
                currentFilters: [],
                startRow: 0,
                endRow: 0,
                $size: null,
                last: {}
            };
            var pagerEvents = "filterInit filterStart filterEnd sortEnd disablePager enablePager destroyPager updateComplete " + "pageSize pageSet pageAndSize pagerUpdate refreshComplete ", $this = this, pagerArrows = function(table, p, disable) {
                var tmp, a = "addClass", r = "removeClass", d = p.cssDisabled, dis = !!disable, first = dis || p.page === 0, tp = getTotalPages(table, p), last = dis || p.page === tp - 1 || tp === 0;
                if (p.updateArrows) {
                    tmp = p.$container.find(p.cssFirst + "," + p.cssPrev);
                    tmp[first ? a : r](d);
                    tmp.each(function() {
                        this.ariaDisabled = first;
                    });
                    tmp = p.$container.find(p.cssNext + "," + p.cssLast);
                    tmp[last ? a : r](d);
                    tmp.each(function() {
                        this.ariaDisabled = last;
                    });
                }
            }, calcFilters = function(table, p) {
                var normalized, indx, len, c = table.config, hasFilters = c.$table.hasClass("hasFilters");
                if (hasFilters && !p.ajax) {
                    if (ts.isEmptyObject(c.cache)) {
                        p.filteredRows = p.totalRows = c.$tbodies.eq(0).children("tr").not(p.countChildRows ? "" : "." + c.cssChildRow).length;
                    } else {
                        p.filteredRows = 0;
                        normalized = c.cache[0].normalized;
                        len = normalized.length;
                        for (indx = 0; indx < len; indx++) {
                            p.filteredRows += p.regexRows.test(normalized[indx][c.columns].$row[0].className) ? 0 : 1;
                        }
                    }
                } else if (!hasFilters) {
                    p.filteredRows = p.totalRows;
                }
            }, updatePageDisplay = function(table, p, completed) {
                if (p.initializing) {
                    return;
                }
                var s, t, $out, $el, indx, len, options, output, c = table.config, namespace = c.namespace + "pager", sz = parsePageSize(p, p.size, "get");
                if (sz === "all") {
                    sz = p.totalRows;
                }
                if (p.countChildRows) {
                    t[t.length] = c.cssChildRow;
                }
                p.totalPages = Math.ceil(p.totalRows / sz);
                c.totalRows = p.totalRows;
                parsePageNumber(table, p);
                calcFilters(table, p);
                c.filteredRows = p.filteredRows;
                p.filteredPages = Math.ceil(p.filteredRows / sz) || 0;
                if (getTotalPages(table, p) >= 0) {
                    t = sz * p.page > p.filteredRows && completed;
                    p.page = t ? p.pageReset || 0 : p.page;
                    p.startRow = t ? sz * p.page + 1 : p.filteredRows === 0 ? 0 : sz * p.page + 1;
                    p.endRow = Math.min(p.filteredRows, p.totalRows, sz * (p.page + 1));
                    $out = p.$container.find(p.cssPageDisplay);
                    if (typeof p.output === "function") {
                        s = p.output(table, p);
                    } else {
                        output = $out.attr("data-pager-output" + (p.filteredRows < p.totalRows ? "-filtered" : "")) || p.output;
                        s = (p.ajaxData && p.ajaxData.output ? p.ajaxData.output || output : output).replace(/\{page([\-+]\d+)?\}/gi, function(m, n) {
                            return p.totalPages ? p.page + (n ? parseInt(n, 10) : 1) : 0;
                        }).replace(/\{\w+(\s*:\s*\w+)?\}/gi, function(m) {
                            var len, indx, str = m.replace(/[{}\s]/g, ""), extra = str.split(":"), data = p.ajaxData, deflt = /(rows?|pages?)$/i.test(str) ? 0 : "";
                            if (/(startRow|page)/.test(extra[0]) && extra[1] === "input") {
                                len = ("" + (extra[0] === "page" ? p.totalPages : p.totalRows)).length;
                                indx = extra[0] === "page" ? p.page + 1 : p.startRow;
                                return '<input type="text" class="ts-' + extra[0] + '" style="max-width:' + len + 'em" value="' + indx + '"/>';
                            }
                            return extra.length > 1 && data && data[extra[0]] ? data[extra[0]][extra[1]] : p[str] || (data ? data[str] : deflt) || deflt;
                        });
                    }
                    $el = p.$container.find(p.cssGoto);
                    if ($el.length) {
                        t = "";
                        options = buildPageSelect(table, p);
                        len = options.length;
                        for (indx = 0; indx < len; indx++) {
                            t += '<option value="' + options[indx] + '">' + options[indx] + "</option>";
                        }
                        $el.html(t).val(p.page + 1);
                    }
                    if ($out.length) {
                        $out[$out[0].nodeName === "INPUT" ? "val" : "html"](s);
                        $out.find(".ts-startRow, .ts-page").unbind("change" + namespace).bind("change" + namespace, function() {
                            var v = $(this).val(), pg = $(this).hasClass("ts-startRow") ? Math.floor(v / sz) + 1 : v;
                            c.$table.triggerHandler("pageSet" + namespace, [ pg ]);
                        });
                    }
                }
                pagerArrows(table, p);
                fixHeight(table, p);
                if (p.initialized && completed !== false) {
                    if (ts.debug(c, "pager")) {
                        console.log("Pager >> Triggering pagerComplete");
                    }
                    c.$table.triggerHandler("pagerComplete", p);
                    if (p.savePages && ts.storage) {
                        ts.storage(table, p.storageKey, {
                            page: p.page,
                            size: sz === p.totalRows ? "all" : sz
                        });
                    }
                }
            }, buildPageSelect = function(table, p) {
                var i, central_focus_size, focus_option_pages, insert_index, option_length, focus_length, pg = getTotalPages(table, p) || 1, skip_set_size = Math.ceil(pg / p.maxOptionSize / 5) * 5, large_collection = pg > p.maxOptionSize, current_page = p.page + 1, start_page = skip_set_size, end_page = pg - skip_set_size, option_pages = [ 1 ], option_pages_start_page = large_collection ? skip_set_size : 1;
                for (i = option_pages_start_page; i <= pg; ) {
                    option_pages[option_pages.length] = i;
                    i = i + (large_collection ? skip_set_size : 1);
                }
                option_pages[option_pages.length] = pg;
                if (large_collection) {
                    focus_option_pages = [];
                    central_focus_size = Math.max(Math.floor(p.maxOptionSize / skip_set_size) - 1, 5);
                    start_page = current_page - central_focus_size;
                    if (start_page < 1) {
                        start_page = 1;
                    }
                    end_page = current_page + central_focus_size;
                    if (end_page > pg) {
                        end_page = pg;
                    }
                    for (i = start_page; i <= end_page; i++) {
                        focus_option_pages[focus_option_pages.length] = i;
                    }
                    option_pages = $.grep(option_pages, function(value, indx) {
                        return $.inArray(value, option_pages) === indx;
                    });
                    option_length = option_pages.length;
                    focus_length = focus_option_pages.length;
                    if (option_length - focus_length > skip_set_size / 2 && option_length + focus_length > p.maxOptionSize) {
                        insert_index = Math.floor(option_length / 2) - Math.floor(focus_length / 2);
                        Array.prototype.splice.apply(option_pages, [ insert_index, focus_length ]);
                    }
                    option_pages = option_pages.concat(focus_option_pages);
                }
                option_pages = $.grep(option_pages, function(value, indx) {
                    return $.inArray(value, option_pages) === indx;
                }).sort(function(a, b) {
                    return a - b;
                });
                return option_pages;
            }, fixHeight = function(table, p) {
                var d, h, bs, c = table.config, $b = c.$tbodies.eq(0);
                $b.find("tr.pagerSavedHeightSpacer").remove();
                if (p.fixedHeight && !p.isDisabled) {
                    h = $.data(table, "pagerSavedHeight");
                    if (h) {
                        bs = 0;
                        if ($(table).css("border-spacing").split(" ").length > 1) {
                            bs = $(table).css("border-spacing").split(" ")[1].replace(/[^-\d\.]/g, "");
                        }
                        d = h - $b.height() + bs * p.size - bs;
                        if (d > 5 && $.data(table, "pagerLastSize") === p.size && $b.children("tr:visible").length < (p.size === "all" ? p.totalRows : p.size)) {
                            $b.append('<tr class="pagerSavedHeightSpacer ' + c.selectorRemove.slice(1) + '" style="height:' + d + 'px;"></tr>');
                        }
                    }
                }
            }, changeHeight = function(table, p) {
                var h, c = table.config, $b = c.$tbodies.eq(0);
                $b.find("tr.pagerSavedHeightSpacer").remove();
                if (!$b.children("tr:visible").length) {
                    $b.append('<tr class="pagerSavedHeightSpacer ' + c.selectorRemove.slice(1) + '"><td>&nbsp</td></tr>');
                }
                h = $b.children("tr").eq(0).height() * (p.size === "all" ? p.totalRows : p.size);
                $.data(table, "pagerSavedHeight", h);
                fixHeight(table, p);
                $.data(table, "pagerLastSize", p.size);
            }, hideRows = function(table, p) {
                if (!p.ajaxUrl) {
                    var i, lastIndex = 0, c = table.config, rows = c.$tbodies.eq(0).children("tr"), l = rows.length, sz = p.size === "all" ? p.totalRows : p.size, s = p.page * sz, e = s + sz, last = -1, j = 0;
                    p.cacheIndex = [];
                    for (i = 0; i < l; i++) {
                        if (!p.regexFiltered.test(rows[i].className)) {
                            if (j === s && rows[i].className.match(c.cssChildRow)) {
                                rows[i].style.display = "none";
                            } else {
                                rows[i].style.display = j >= s && j < e ? "" : "none";
                                if (last !== j && j >= s && j < e) {
                                    p.cacheIndex[p.cacheIndex.length] = i;
                                    last = j;
                                }
                                j += rows[i].className.match(c.cssChildRow + "|" + c.selectorRemove.slice(1)) && !p.countChildRows ? 0 : 1;
                                if (j === e && rows[i].style.display !== "none" && rows[i].className.match(ts.css.cssHasChild)) {
                                    lastIndex = i;
                                }
                            }
                        }
                    }
                    if (lastIndex > 0 && rows[lastIndex].className.match(ts.css.cssHasChild)) {
                        while (++lastIndex < l && rows[lastIndex].className.match(c.cssChildRow)) {
                            rows[lastIndex].style.display = "";
                        }
                    }
                }
            }, hideRowsSetup = function(table, p) {
                p.size = parsePageSize(p, p.$container.find(p.cssPageSize).val(), "get");
                setPageSize(table, p.size, p);
                pagerArrows(table, p);
                if (!p.removeRows) {
                    hideRows(table, p);
                    $(table).bind("sortEnd filterEnd ".split(" ").join(table.config.namespace + "pager "), function() {
                        hideRows(table, p);
                    });
                }
            }, renderAjax = function(data, table, p, xhr, settings, exception) {
                if (typeof p.ajaxProcessing === "function") {
                    table.config.$tbodies.eq(0).empty();
                    var i, j, t, hsh, $f, $sh, $headers, $h, icon, th, d, l, rr_count, len, sz, c = table.config, $table = c.$table, tds = "", result = p.ajaxProcessing(data, table, xhr) || [ 0, [] ];
                    ts.showError(table);
                    if (exception) {
                        if (ts.debug(c, "pager")) {
                            console.error("Pager >> Ajax Error", xhr, settings, exception);
                        }
                        ts.showError(table, xhr, settings, exception);
                        c.$tbodies.eq(0).children("tr").detach();
                        p.totalRows = 0;
                    } else {
                        if (!$.isArray(result)) {
                            p.ajaxData = result;
                            c.totalRows = p.totalRows = result.total;
                            c.filteredRows = p.filteredRows = typeof result.filteredRows !== "undefined" ? result.filteredRows : result.total;
                            th = result.headers;
                            d = result.rows || [];
                        } else {
                            t = isNaN(result[0]) && !isNaN(result[1]);
                            rr_count = result[t ? 1 : 0];
                            p.totalRows = isNaN(rr_count) ? p.totalRows || 0 : rr_count;
                            c.totalRows = c.filteredRows = p.filteredRows = p.totalRows;
                            d = p.totalRows === 0 ? [] : result[t ? 0 : 1] || [];
                            th = result[2];
                        }
                        l = d && d.length;
                        if (d instanceof $) {
                            if (p.processAjaxOnInit) {
                                c.$tbodies.eq(0).empty();
                                c.$tbodies.eq(0).append(d);
                            }
                        } else if (l) {
                            for (i = 0; i < l; i++) {
                                tds += "<tr>";
                                for (j = 0; j < d[i].length; j++) {
                                    tds += /^\s*<td/.test(d[i][j]) ? $.trim(d[i][j]) : "<td>" + d[i][j] + "</td>";
                                }
                                tds += "</tr>";
                            }
                            if (p.processAjaxOnInit) {
                                c.$tbodies.eq(0).html(tds);
                            }
                        }
                        p.processAjaxOnInit = true;
                        if (th) {
                            hsh = $table.hasClass("hasStickyHeaders");
                            $sh = hsh ? c.widgetOptions.$sticky.children("thead:first").children("tr:not(." + c.cssIgnoreRow + ")").children() : "";
                            $f = $table.find("tfoot tr:first").children();
                            $headers = c.$headers.filter("th ");
                            len = $headers.length;
                            for (j = 0; j < len; j++) {
                                $h = $headers.eq(j);
                                if ($h.find("." + ts.css.icon).length) {
                                    icon = $h.find("." + ts.css.icon).clone(true);
                                    $h.find("." + ts.css.headerIn).html(th[j]).append(icon);
                                    if (hsh && $sh.length) {
                                        icon = $sh.eq(j).find("." + ts.css.icon).clone(true);
                                        $sh.eq(j).find("." + ts.css.headerIn).html(th[j]).append(icon);
                                    }
                                } else {
                                    $h.find("." + ts.css.headerIn).html(th[j]);
                                    if (hsh && $sh.length) {
                                        p.$container = p.$container.add(c.widgetOptions.$sticky);
                                        $sh.eq(j).find("." + ts.css.headerIn).html(th[j]);
                                    }
                                }
                                $f.eq(j).html(th[j]);
                            }
                        }
                    }
                    if (c.showProcessing) {
                        ts.isProcessing(table);
                    }
                    sz = parsePageSize(p, p.size, "get");
                    p.totalPages = sz === "all" ? 1 : Math.ceil(p.totalRows / sz);
                    p.last.totalRows = p.totalRows;
                    p.last.currentFilters = p.currentFilters;
                    p.last.sortList = (c.sortList || []).join(",");
                    updatePageDisplay(table, p, false);
                    ts.updateCache(c, function() {
                        if (p.initialized) {
                            setTimeout(function() {
                                if (ts.debug(c, "pager")) {
                                    console.log("Pager >> Triggering pagerChange");
                                }
                                $table.triggerHandler("pagerChange", p);
                                ts.applyWidget(table);
                                updatePageDisplay(table, p, true);
                            }, 0);
                        }
                    });
                }
                if (!p.initialized) {
                    pagerInitialized(table, p);
                }
            }, getAjax = function(table, p) {
                var url = getAjaxUrl(table, p), $doc = $(document), counter, c = table.config, namespace = c.namespace + "pager";
                if (url !== "") {
                    if (c.showProcessing) {
                        ts.isProcessing(table, true);
                    }
                    $doc.bind("ajaxError" + namespace, function(e, xhr, settings, exception) {
                        renderAjax(null, table, p, xhr, settings, exception);
                        $doc.unbind("ajaxError" + namespace);
                    });
                    counter = ++p.ajaxCounter;
                    p.last.ajaxUrl = url;
                    p.ajaxObject.url = url;
                    p.ajaxObject.success = function(data, status, jqxhr) {
                        if (counter < p.ajaxCounter) {
                            return;
                        }
                        renderAjax(data, table, p, jqxhr);
                        $doc.unbind("ajaxError" + namespace);
                        if (typeof p.oldAjaxSuccess === "function") {
                            p.oldAjaxSuccess(data);
                        }
                    };
                    if (ts.debug(c, "pager")) {
                        console.log("Pager >> Ajax initialized", p.ajaxObject);
                    }
                    $.ajax(p.ajaxObject);
                }
            }, getAjaxUrl = function(table, p) {
                var indx, len, c = table.config, url = p.ajaxUrl ? p.ajaxUrl.replace(/\{page([\-+]\d+)?\}/, function(s, n) {
                    return p.page + (n ? parseInt(n, 10) : 0);
                }).replace(/\{size\}/g, p.size) : "", sortList = c.sortList, filterList = p.currentFilters || $(table).data("lastSearch") || [], sortCol = url.match(/\{\s*sort(?:List)?\s*:\s*(\w*)\s*\}/), filterCol = url.match(/\{\s*filter(?:List)?\s*:\s*(\w*)\s*\}/), arry = [];
                if (sortCol) {
                    sortCol = sortCol[1];
                    len = sortList.length;
                    for (indx = 0; indx < len; indx++) {
                        arry[arry.length] = sortCol + "[" + sortList[indx][0] + "]=" + sortList[indx][1];
                    }
                    url = url.replace(/\{\s*sort(?:List)?\s*:\s*(\w*)\s*\}/g, arry.length ? arry.join("&") : sortCol);
                    arry = [];
                }
                if (filterCol) {
                    filterCol = filterCol[1];
                    len = filterList.length;
                    for (indx = 0; indx < len; indx++) {
                        if (filterList[indx]) {
                            arry[arry.length] = filterCol + "[" + indx + "]=" + encodeURIComponent(filterList[indx]);
                        }
                    }
                    url = url.replace(/\{\s*filter(?:List)?\s*:\s*(\w*)\s*\}/g, arry.length ? arry.join("&") : filterCol);
                    p.currentFilters = filterList;
                }
                if (typeof p.customAjaxUrl === "function") {
                    url = p.customAjaxUrl(table, url);
                }
                if (ts.debug(c, "pager")) {
                    console.log("Pager >> Ajax url = " + url);
                }
                return url;
            }, renderTable = function(table, rows, p) {
                var $tb, index, count, added, $t = $(table), c = table.config, debug = ts.debug(c, "pager"), f = c.$table.hasClass("hasFilters"), l = rows && rows.length || 0, e = p.size === "all" ? p.totalRows : p.size, s = p.page * e;
                if (l < 1) {
                    if (debug) {
                        console.warn("Pager >> No rows for pager to render");
                    }
                    return;
                }
                if (p.page >= p.totalPages) {
                    moveToLastPage(table, p);
                }
                p.cacheIndex = [];
                p.isDisabled = false;
                if (p.initialized) {
                    if (debug) {
                        console.log("Pager >> Triggering pagerChange");
                    }
                    $t.triggerHandler("pagerChange", p);
                }
                if (!p.removeRows) {
                    hideRows(table, p);
                } else {
                    ts.clearTableBody(table);
                    $tb = ts.processTbody(table, c.$tbodies.eq(0), true);
                    index = f ? 0 : s;
                    count = f ? 0 : s;
                    added = 0;
                    while (added < e && index < rows.length) {
                        if (!f || !p.regexFiltered.test(rows[index][0].className)) {
                            count++;
                            if (count > s && added <= e) {
                                added++;
                                p.cacheIndex[p.cacheIndex.length] = index;
                                $tb.append(rows[index]);
                            }
                        }
                        index++;
                    }
                    ts.processTbody(table, $tb, false);
                }
                updatePageDisplay(table, p);
                if (table.isUpdating) {
                    if (debug) {
                        console.log("Pager >> Triggering updateComplete");
                    }
                    $t.triggerHandler("updateComplete", [ table, true ]);
                }
            }, showAllRows = function(table, p) {
                var index, $controls, len;
                if (p.ajax) {
                    pagerArrows(table, p, true);
                } else {
                    $.data(table, "pagerLastPage", p.page);
                    $.data(table, "pagerLastSize", p.size);
                    p.page = 0;
                    p.size = p.totalRows;
                    p.totalPages = 1;
                    $(table).addClass("pagerDisabled").removeAttr("aria-describedby").find("tr.pagerSavedHeightSpacer").remove();
                    renderTable(table, table.config.rowsCopy, p);
                    p.isDisabled = true;
                    ts.applyWidget(table);
                    if (ts.debug(table.config, "pager")) {
                        console.log("Pager >> Disabled");
                    }
                }
                $controls = p.$container.find(p.cssGoto + "," + p.cssPageSize + ", .ts-startRow, .ts-page");
                len = $controls.length;
                for (index = 0; index < len; index++) {
                    $controls.eq(index).addClass(p.cssDisabled)[0].disabled = true;
                    $controls[index].ariaDisabled = true;
                }
            }, updateCache = function(table) {
                var c = table.config, p = c.pager;
                ts.updateCache(c, function() {
                    var i, rows = [], n = table.config.cache[0].normalized;
                    p.totalRows = n.length;
                    for (i = 0; i < p.totalRows; i++) {
                        rows[rows.length] = n[i][c.columns].$row;
                    }
                    c.rowsCopy = rows;
                    moveToPage(table, p, true);
                });
            }, moveToPage = function(table, p, pageMoved) {
                if (p.isDisabled) {
                    return;
                }
                var tmp, c = table.config, debug = ts.debug(c, "pager"), $t = $(table), l = p.last;
                if (pageMoved !== false && p.initialized && ts.isEmptyObject(c.cache)) {
                    return updateCache(table);
                }
                if (p.ajax && ts.hasWidget(table, "filter") && !c.widgetOptions.filter_initialized) {
                    return;
                }
                parsePageNumber(table, p);
                calcFilters(table, p);
                l.currentFilters = (l.currentFilters || []).join("") === "" ? [] : l.currentFilters;
                p.currentFilters = (p.currentFilters || []).join("") === "" ? [] : p.currentFilters;
                if (l.page === p.page && l.size === p.size && l.totalRows === p.totalRows && (l.currentFilters || []).join(",") === (p.currentFilters || []).join(",") && (l.ajaxUrl || "") === (p.ajaxObject.url || "") && (l.optAjaxUrl || "") === (p.ajaxUrl || "") && l.sortList === (c.sortList || []).join(",")) {
                    return;
                }
                if (debug) {
                    console.log("Pager >> Changing to page " + p.page);
                }
                p.last = {
                    page: p.page,
                    size: p.size,
                    sortList: (c.sortList || []).join(","),
                    totalRows: p.totalRows,
                    currentFilters: p.currentFilters || [],
                    ajaxUrl: p.ajaxObject.url || "",
                    optAjaxUrl: p.ajaxUrl || ""
                };
                if (p.ajax) {
                    if (!p.processAjaxOnInit && !ts.isEmptyObject(p.initialRows)) {
                        p.processAjaxOnInit = true;
                        tmp = p.initialRows;
                        p.totalRows = typeof tmp.total !== "undefined" ? tmp.total : debug ? console.error("Pager >> No initial total page set!") || 0 : 0;
                        p.filteredRows = typeof tmp.filtered !== "undefined" ? tmp.filtered : debug ? console.error("Pager >> No initial filtered page set!") || 0 : 0;
                        pagerInitialized(table, p);
                    } else {
                        getAjax(table, p);
                    }
                } else if (!p.ajax) {
                    renderTable(table, c.rowsCopy, p);
                }
                $.data(table, "pagerLastPage", p.page);
                if (p.initialized && pageMoved !== false) {
                    if (debug) {
                        console.log("Pager >> Triggering pageMoved");
                    }
                    $t.triggerHandler("pageMoved", p);
                    ts.applyWidget(table);
                    if (table.isUpdating) {
                        if (debug) {
                            console.log("Pager >> Triggering updateComplete");
                        }
                        $t.triggerHandler("updateComplete", [ table, true ]);
                    }
                }
            }, getTotalPages = function(table, p) {
                return ts.hasWidget(table, "filter") ? Math.min(p.totalPages, p.filteredPages) : p.totalPages;
            }, parsePageNumber = function(table, p) {
                var min = getTotalPages(table, p) - 1;
                p.page = parseInt(p.page, 10);
                if (p.page < 0 || isNaN(p.page)) {
                    p.page = 0;
                }
                if (p.page > min && min >= 0) {
                    p.page = min;
                }
                return p.page;
            }, parsePageSize = function(p, size, mode) {
                var s = parseInt(size, 10) || p.size || p.settings.size || 10;
                if (p.initialized && (/all/i.test(s + " " + size) || s === p.totalRows)) {
                    return p.$container.find(p.cssPageSize + ' option[value="all"]').length ? "all" : p.totalRows;
                }
                return mode === "get" ? s : p.size;
            }, setPageSize = function(table, size, p) {
                p.size = parsePageSize(p, size, "get");
                p.$container.find(p.cssPageSize).val(p.size);
                $.data(table, "pagerLastPage", parsePageNumber(table, p));
                $.data(table, "pagerLastSize", p.size);
                p.totalPages = p.size === "all" ? 1 : Math.ceil(p.totalRows / p.size);
                p.filteredPages = p.size === "all" ? 1 : Math.ceil(p.filteredRows / p.size);
            }, moveToFirstPage = function(table, p) {
                p.page = 0;
                moveToPage(table, p);
            }, moveToLastPage = function(table, p) {
                p.page = getTotalPages(table, p) - 1;
                moveToPage(table, p);
            }, moveToNextPage = function(table, p) {
                p.page++;
                var last = getTotalPages(table, p) - 1;
                if (p.page >= last) {
                    p.page = last;
                }
                moveToPage(table, p);
            }, moveToPrevPage = function(table, p) {
                p.page--;
                if (p.page <= 0) {
                    p.page = 0;
                }
                moveToPage(table, p);
            }, pagerInitialized = function(table, p) {
                p.initialized = true;
                p.initializing = false;
                if (ts.debug(table.config, "pager")) {
                    console.log("Pager >> Triggering pagerInitialized");
                }
                $(table).triggerHandler("pagerInitialized", p);
                ts.applyWidget(table);
                updatePageDisplay(table, p);
            }, resetState = function(table, p) {
                var c = table.config;
                c.pager = $.extend(true, {}, $.tablesorterPager.defaults, p.settings);
                init(table, p.settings);
            }, destroyPager = function(table, p) {
                var c = table.config, namespace = c.namespace + "pager", ctrls = [ p.cssFirst, p.cssPrev, p.cssNext, p.cssLast, p.cssGoto, p.cssPageSize ].join(",");
                showAllRows(table, p);
                p.$container.hide().find(ctrls).unbind(namespace);
                c.appender = null;
                c.$table.unbind(namespace);
                if (ts.storage) {
                    ts.storage(table, p.storageKey, "");
                }
                delete c.pager;
                delete c.rowsCopy;
            }, enablePager = function(table, p, triggered) {
                var info, size, $el, c = table.config;
                p.$container.find(p.cssGoto + "," + p.cssPageSize + ",.ts-startRow, .ts-page").removeClass(p.cssDisabled).removeAttr("disabled").each(function() {
                    this.ariaDisabled = false;
                });
                p.isDisabled = false;
                p.page = $.data(table, "pagerLastPage") || p.page || 0;
                $el = p.$container.find(p.cssPageSize);
                size = $el.find("option[selected]").val();
                p.size = $.data(table, "pagerLastSize") || parsePageSize(p, size, "get");
                p.totalPages = p.size === "all" ? 1 : Math.ceil(getTotalPages(table, p) / p.size);
                setPageSize(table, p.size, p);
                if (table.id && !c.$table.attr("aria-describedby")) {
                    $el = p.$container.find(p.cssPageDisplay);
                    info = $el.attr("id");
                    if (!info) {
                        info = table.id + "_pager_info";
                        $el.attr("id", info);
                    }
                    c.$table.attr("aria-describedby", info);
                }
                changeHeight(table, p);
                if (triggered) {
                    ts.update(c);
                    setPageSize(table, p.size, p);
                    moveToPage(table, p);
                    hideRowsSetup(table, p);
                    if (ts.debug(c, "pager")) {
                        console.log("Pager >> Enabled");
                    }
                }
            }, init = function(table, settings) {
                var t, ctrls, fxn, $el, c = table.config, wo = c.widgetOptions, debug = ts.debug(c, "pager"), p = c.pager = $.extend(true, {}, $.tablesorterPager.defaults, settings), $t = c.$table, namespace = c.namespace + "pager", pager = p.$container = $(p.container).addClass("tablesorter-pager").show();
                p.settings = $.extend(true, {}, $.tablesorterPager.defaults, settings);
                if (debug) {
                    console.log("Pager >> Initializing");
                }
                p.oldAjaxSuccess = p.oldAjaxSuccess || p.ajaxObject.success;
                c.appender = $this.appender;
                p.initializing = true;
                if (p.savePages && ts.storage) {
                    t = ts.storage(table, p.storageKey) || {};
                    p.page = isNaN(t.page) ? p.page : t.page;
                    p.size = t.size === "all" ? t.size : (isNaN(t.size) ? p.size : t.size) || p.setSize || 10;
                    setPageSize(table, p.size, p);
                }
                p.regexRows = new RegExp("(" + (wo.filter_filteredRow || "filtered") + "|" + c.selectorRemove.slice(1) + "|" + c.cssChildRow + ")");
                p.regexFiltered = new RegExp(wo.filter_filteredRow || "filtered");
                $t.unbind(pagerEvents.split(" ").join(namespace + " ").replace(/\s+/g, " ")).bind("filterInit filterStart ".split(" ").join(namespace + " "), function(e, filters) {
                    p.currentFilters = $.isArray(filters) ? filters : c.$table.data("lastSearch");
                    var filtersEqual;
                    if (p.ajax && e.type === "filterInit") {
                        return moveToPage(table, p, false);
                    }
                    if (ts.filter.equalFilters) {
                        filtersEqual = ts.filter.equalFilters(c, c.lastSearch, p.currentFilters);
                    } else {
                        filtersEqual = (c.lastSearch || []).join("") !== (p.currentFilters || []).join("");
                    }
                    if (e.type === "filterStart" && p.pageReset !== false && !filtersEqual) {
                        p.page = p.pageReset;
                    }
                }).bind("filterEnd sortEnd ".split(" ").join(namespace + " "), function() {
                    p.currentFilters = c.$table.data("lastSearch");
                    if (p.initialized || p.initializing) {
                        if (c.delayInit && c.rowsCopy && c.rowsCopy.length === 0) {
                            updateCache(table);
                        }
                        updatePageDisplay(table, p, false);
                        moveToPage(table, p, false);
                        ts.applyWidget(table);
                    }
                }).bind("disablePager" + namespace, function(e) {
                    e.stopPropagation();
                    showAllRows(table, p);
                }).bind("enablePager" + namespace, function(e) {
                    e.stopPropagation();
                    enablePager(table, p, true);
                }).bind("destroyPager" + namespace, function(e) {
                    e.stopPropagation();
                    destroyPager(table, p);
                }).bind("resetToLoadState" + namespace, function(e) {
                    e.stopPropagation();
                    resetState(table, p);
                }).bind("updateComplete" + namespace, function(e, table, triggered) {
                    e.stopPropagation();
                    if (!table || triggered || p.ajax) {
                        return;
                    }
                    var $rows = c.$tbodies.eq(0).children("tr").not(c.selectorRemove);
                    p.totalRows = $rows.length - (p.countChildRows ? 0 : $rows.filter("." + c.cssChildRow).length);
                    p.totalPages = p.size === "all" ? 1 : Math.ceil(p.totalRows / p.size);
                    if ($rows.length && c.rowsCopy && c.rowsCopy.length === 0) {
                        updateCache(table);
                    }
                    if (p.page >= p.totalPages) {
                        moveToLastPage(table, p);
                    }
                    hideRows(table, p);
                    changeHeight(table, p);
                    updatePageDisplay(table, p, true);
                }).bind("pageSize refreshComplete ".split(" ").join(namespace + " "), function(e, size) {
                    e.stopPropagation();
                    setPageSize(table, parsePageSize(p, size, "get"), p);
                    moveToPage(table, p);
                    hideRows(table, p);
                    updatePageDisplay(table, p, false);
                }).bind("pageSet pagerUpdate ".split(" ").join(namespace + " "), function(e, num) {
                    e.stopPropagation();
                    if (e.type === "pagerUpdate") {
                        num = typeof num === "undefined" ? p.page + 1 : num;
                        p.last.page = true;
                    }
                    p.page = (parseInt(num, 10) || 1) - 1;
                    moveToPage(table, p, true);
                    updatePageDisplay(table, p, false);
                }).bind("pageAndSize" + namespace, function(e, page, size) {
                    e.stopPropagation();
                    p.page = (parseInt(page, 10) || 1) - 1;
                    setPageSize(table, parsePageSize(p, size, "get"), p);
                    moveToPage(table, p, true);
                    hideRows(table, p);
                    updatePageDisplay(table, p, false);
                });
                ctrls = [ p.cssFirst, p.cssPrev, p.cssNext, p.cssLast ];
                fxn = [ moveToFirstPage, moveToPrevPage, moveToNextPage, moveToLastPage ];
                if (debug && !pager.length) {
                    console.warn('Pager >> "container" not found');
                }
                pager.find(ctrls.join(",")).attr("tabindex", 0).unbind("click" + namespace).bind("click" + namespace, function(e) {
                    e.stopPropagation();
                    var i, $t = $(this), l = ctrls.length;
                    if (!$t.hasClass(p.cssDisabled)) {
                        for (i = 0; i < l; i++) {
                            if ($t.is(ctrls[i])) {
                                fxn[i](table, p);
                                break;
                            }
                        }
                    }
                });
                $el = pager.find(p.cssGoto);
                if ($el.length) {
                    $el.unbind("change" + namespace).bind("change" + namespace, function() {
                        p.page = $(this).val() - 1;
                        moveToPage(table, p, true);
                        updatePageDisplay(table, p, false);
                    });
                } else if (debug) {
                    console.warn('Pager >> "goto" selector not found');
                }
                $el = pager.find(p.cssPageSize);
                if ($el.length) {
                    $el.find("option").removeAttr("selected");
                    $el.unbind("change" + namespace).bind("change" + namespace, function() {
                        if (!$(this).hasClass(p.cssDisabled)) {
                            var size = $(this).val();
                            setPageSize(table, size, p);
                            moveToPage(table, p);
                            changeHeight(table, p);
                        }
                        return false;
                    });
                } else if (debug) {
                    console.warn('Pager >> "size" selector not found');
                }
                p.initialized = false;
                $t.triggerHandler("pagerBeforeInitialized", p);
                enablePager(table, p, false);
                if (typeof p.ajaxUrl === "string") {
                    p.ajax = true;
                    c.widgetOptions.filter_serversideFiltering = true;
                    c.serverSideSorting = true;
                    moveToPage(table, p);
                } else {
                    p.ajax = false;
                    ts.appendCache(c, true);
                    hideRowsSetup(table, p);
                }
                if (!p.ajax && !p.initialized) {
                    p.initializing = false;
                    p.initialized = true;
                    setPageSize(table, p.size, p);
                    moveToPage(table, p);
                    if (debug) {
                        console.log("Pager >> Triggering pagerInitialized");
                    }
                    c.$table.triggerHandler("pagerInitialized", p);
                    if (!(c.widgetOptions.filter_initialized && ts.hasWidget(table, "filter"))) {
                        updatePageDisplay(table, p, false);
                    }
                }
                c.widgetInit.pager = true;
            };
            $this.appender = function(table, rows) {
                var c = table.config, p = c.pager;
                if (!p.ajax) {
                    c.rowsCopy = rows;
                    p.totalRows = p.countChildRows ? c.$tbodies.eq(0).children("tr").length : rows.length;
                    p.size = $.data(table, "pagerLastSize") || p.size || p.settings.size || 10;
                    p.totalPages = p.size === "all" ? 1 : Math.ceil(p.totalRows / p.size);
                    renderTable(table, rows, p);
                    updatePageDisplay(table, p, false);
                }
            };
            $this.construct = function(settings) {
                return this.each(function() {
                    if (!(this.config && this.hasInitialized)) {
                        return;
                    }
                    init(this, settings);
                });
            };
        }()
    });
    ts.showError = function(table, xhr, settings, exception) {
        var $table = $(table), c = $table[0].config, wo = c && c.widgetOptions, errorRow = c.pager && c.pager.cssErrorRow || wo && wo.pager_css && wo.pager_css.errorRow || "tablesorter-errorRow", typ = typeof xhr, valid = true, message = "", removeRow = function() {
            c.$table.find("thead").find(c.selectorRemove).remove();
        };
        if (!$table.length) {
            console.error("tablesorter showError: no table parameter passed");
            return;
        }
        if (typeof c.pager.ajaxError === "function") {
            valid = c.pager.ajaxError(c, xhr, settings, exception);
            if (valid === false) {
                return removeRow();
            } else {
                message = valid;
            }
        } else if (typeof wo.pager_ajaxError === "function") {
            valid = wo.pager_ajaxError(c, xhr, settings, exception);
            if (valid === false) {
                return removeRow();
            } else {
                message = valid;
            }
        }
        if (message === "") {
            if (typ === "object") {
                message = xhr.status === 0 ? "Not connected, verify Network" : xhr.status === 404 ? "Requested page not found [404]" : xhr.status === 500 ? "Internal Server Error [500]" : exception === "parsererror" ? "Requested JSON parse failed" : exception === "timeout" ? "Time out error" : exception === "abort" ? "Ajax Request aborted" : "Uncaught error: " + xhr.statusText + " [" + xhr.status + "]";
            } else if (typ === "string") {
                message = xhr;
            } else {
                return removeRow();
            }
        }
        $(/tr\>/.test(message) ? message : '<tr><td colspan="' + c.columns + '">' + message + "</td></tr>").click(function() {
            $(this).remove();
        }).appendTo(c.$table.find("thead:first")).addClass(errorRow + " " + c.selectorRemove.slice(1)).attr({
            role: "alert",
            "aria-live": "assertive"
        });
    };
    $.fn.extend({
        tablesorterPager: $.tablesorterPager.construct
    });
})(jQuery);

(function($) {
    "use strict";
    var ts = $.tablesorter, tablereflow = {
        init: function(table, c, wo) {
            var $this, title = wo.reflow_dataAttrib, header = wo.reflow_headerAttrib, headers = [];
            c.$table.addClass(wo.reflow_className).off("refresh.tsreflow updateComplete.tsreflow2").on("refresh.tsreflow updateComplete.tsreflow2", function() {
                tablereflow.init(table, c, wo);
            });
            c.$headers.each(function() {
                $this = $(this);
                headers.push($.trim($this.attr(header) || $this.text()));
            });
            c.$tbodies.children().each(function() {
                $(this).children().each(function(i) {
                    $(this).attr(title, headers[i]);
                });
            });
        },
        init2: function(table, c, wo) {
            var $this, $tbody, i, $hdr, txt, len, cols = c.columns, header = wo.reflow2_headerAttrib, headers = [];
            c.$table.addClass(wo.reflow2_className).off("refresh.tsreflow2 updateComplete.tsreflow2").on("refresh.tsreflow2 updateComplete.tsreflow2", function() {
                tablereflow.init2(table, c, wo);
            });
            for (i = 0; i < cols; i++) {
                $hdr = c.$headers.filter('[data-column="' + i + '"]');
                if ($hdr.length > 1) {
                    txt = [];
                    $hdr.each(function() {
                        $this = $(this);
                        if (!$this.hasClass(wo.reflow2_classIgnore)) {
                            txt.push($this.attr(header) || $this.text());
                        }
                    });
                } else {
                    txt = [ $hdr.attr(header) || $hdr.text() ];
                }
                headers.push(txt);
            }
            txt = '<b class="' + c.selectorRemove.slice(1) + " " + wo.reflow2_labelClass;
            c.$tbodies.children().each(function() {
                $tbody = ts.processTbody(table, $(this), true);
                $tbody.children().each(function(j) {
                    $this = $(this);
                    len = headers[j].length;
                    i = len - 1;
                    while (i >= 0) {
                        $this.prepend(txt + (i === 0 && len > 1 ? " " + wo.reflow2_labelTop : "") + '">' + headers[j][i] + "</b>");
                        i--;
                    }
                });
                ts.processTbody(table, $tbody, false);
            });
        },
        remove: function(table, c, wo) {
            c.$table.removeClass(wo.reflow_className);
        },
        remove2: function(table, c, wo) {
            c.$table.removeClass(wo.reflow2_className);
        }
    };
    ts.addWidget({
        id: "reflow",
        options: {
            reflow_className: "ui-table-reflow",
            reflow_headerAttrib: "data-name",
            reflow_dataAttrib: "data-title"
        },
        init: function(table, thisWidget, c, wo) {
            tablereflow.init(table, c, wo);
        },
        remove: function(table, c, wo) {
            tablereflow.remove(table, c, wo);
        }
    });
    ts.addWidget({
        id: "reflow2",
        options: {
            reflow2_className: "ui-table-reflow",
            reflow2_classIgnore: "ui-table-reflow-ignore",
            reflow2_headerAttrib: "data-name",
            reflow2_labelClass: "ui-table-cell-label",
            reflow2_labelTop: "ui-table-cell-label-top"
        },
        init: function(table, thisWidget, c, wo) {
            tablereflow.init2(table, c, wo);
        },
        remove: function(table, c, wo) {
            tablereflow.remove2(table, c, wo);
        }
    });
})(jQuery);

function formatState(state) {
    if (!state.id) {
        return state.text;
    }
    if ($($(state.element).data("content")).length === 0) {
        return state.text;
    }
    var $state = $($(state.element).data("content"));
    return $state;
}

$(document).on("click", '[data-bs-toggle="confirm"]', function(e) {
    if ($(this).prop("tagName") === "a") {
        e.preventDefault();
        var link = $(this).attr("href");
        var text = $(this).data("title");
        var title = $(this).html();
        var blockUI = $(this).data("confirm-event");
        bootbox.confirm({
            centerVertical: true,
            title: title,
            message: text,
            buttons: {
                confirm: {
                    label: '<i class="fa fa-check"></i> ' + $(this).data("yes"),
                    className: "btn-success"
                },
                cancel: {
                    label: '<i class="fa fa-times"></i> ' + $(this).data("no"),
                    className: "btn-danger"
                }
            },
            callback: function(confirmed) {
                if (confirmed) {
                    document.location.href = link;
                    if (typeof blockUI !== "undefined") {
                        window[blockUI]();
                    }
                }
            }
        });
    }
});

$(".form-confirm").submit(function(e) {
    var button = $(e)[0].originalEvent;
    var text = button.submitter.getAttribute("data-title");
    var title = button.submitter.innerHTML;
    var blockUI = button.submitter.getAttribute("data-confirm-event");
    var currentForm = this;
    e.preventDefault();
    bootbox.confirm({
        centerVertical: true,
        title: title,
        message: text,
        buttons: {
            confirm: {
                label: '<i class="fa fa-check"></i> ' + button.submitter.getAttribute("data-yes"),
                className: "btn-success"
            },
            cancel: {
                label: '<i class="fa fa-times"></i> ' + button.submitter.getAttribute("data-no"),
                className: "btn-danger"
            }
        },
        callback: function(confirmed) {
            if (confirmed) {
                currentForm.submit();
                if (typeof blockUI !== "undefined") {
                    window[blockUI]();
                }
            }
        }
    });
});

$(window).scroll(function() {
    if ($(this).scrollTop() > 50) {
        $(".scroll-top:hidden").stop(true, true).fadeIn();
    } else {
        $(".scroll-top").stop(true, true).fadeOut();
    }
});

$(function() {
    $(".btn-scroll").click(function() {
        $("html,body").animate({
            scrollTop: $("header").offset().top
        }, "1000");
        return false;
    });
});

document.addEventListener("DOMContentLoaded", function() {
    if (document.body.contains(document.getElementById("PasswordToggle"))) {
        var passwordToggle = document.getElementById("PasswordToggle");
        var icon = passwordToggle.querySelector("i");
        var pass = document.querySelector("input[id*='Password']");
        passwordToggle.addEventListener("click", function(event) {
            event.preventDefault();
            if (pass.getAttribute("type") === "text") {
                pass.setAttribute("type", "password");
                icon.classList.add("fa-eye-slash");
                icon.classList.remove("fa-eye");
            } else if (pass.getAttribute("type") === "password") {
                pass.setAttribute("type", "text");
                icon.classList.remove("fa-eye-slash");
                icon.classList.add("fa-eye");
            }
        });
    }
});

function getAlbumImagesData(pageSize, pageNumber, isPageChange) {
    var yafUserID = $("#PostAlbumsListPlaceholder").data("userid");
    var pagedResults = {};
    pagedResults.UserId = yafUserID;
    pagedResults.PageSize = pageSize;
    pagedResults.PageNumber = pageNumber;
    var ajaxURL = $("#PostAlbumsListPlaceholder").data("url") + "api/Album/GetAlbumImages";
    $.ajax({
        url: ajaxURL,
        type: "POST",
        data: JSON.stringify(pagedResults),
        contentType: "application/json; charset=utf-8",
        success: function(data) {
            $("#PostAlbumsListPlaceholder ul").empty();
            $("#PostAlbumsLoader").hide();
            if (data.AttachmentList.length === 0) {
                var list = $("#PostAlbumsListPlaceholder ul");
                var notext = $("#PostAlbumsListPlaceholder").data("notext");
                list.append('<li><div class="alert alert-info text-break" role="alert" style="white-space:normal">' + notext + "</div></li>");
            }
            $.each(data.AttachmentList, function(id, data) {
                var list = $("#PostAlbumsListPlaceholder ul"), listItem = $('<li class="list-group-item list-group-item-action" style="white-space: nowrap; cursor: pointer;" />');
                listItem.attr("onclick", data.OnClick);
                listItem.append(data.IconImage);
                list.append(listItem);
            });
            setPageNumberAlbums(pageSize, pageNumber, data.TotalRecords);
            if (isPageChange) {
                jQuery(".albums-toggle").dropdown("toggle");
            }
            var tooltipAlbumsTriggerList = [].slice.call(document.querySelectorAll("#PostAlbumsListPlaceholder ul li"));
            var tooltipAlbumsList = tooltipAlbumsTriggerList.map(function(tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl, {
                    html: true,
                    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner" style="max-width:250px"></div></div>',
                    placement: "top"
                });
            });
        },
        error: function(request, status, error) {
            console.log(request);
            console.log(error);
            $("#PostAlbumsLoader").hide();
            $("#PostAlbumsListPlaceholder").html(request.statusText).fadeIn(1e3);
        }
    });
}

function setPageNumberAlbums(pageSize, pageNumber, total) {
    var pages = Math.ceil(total / pageSize);
    var pagerHolder = $("#AlbumsListPager"), pagination = $('<ul class="pagination pagination-sm" />');
    pagerHolder.empty();
    pagination.wrap('<nav aria-label="Albums Page Results" />');
    if (pageNumber > 0) {
        pagination.append('<li class="page-item"><a href="javascript:getAlbumImagesData(' + pageSize + "," + (pageNumber - 1) + "," + total + ',true)" class="page-link"><i class="fas fa-angle-left"></i></a></li>');
    }
    var start = pageNumber - 2;
    var end = pageNumber + 3;
    if (start < 0) {
        start = 0;
    }
    if (end > pages) {
        end = pages;
    }
    if (start > 0) {
        pagination.append('<li class="page-item"><a href="javascript:getAlbumImagesData(' + pageSize + "," + 0 + "," + total + ', true);" class="page-link">1</a></li>');
        pagination.append('<li class="page-item disabled"><a class="page-link" href="#" tabindex="-1">...</a></li>');
    }
    for (var i = start; i < end; i++) {
        if (i === pageNumber) {
            pagination.append('<li class="page-item active"><span class="page-link">' + (i + 1) + "</span>");
        } else {
            pagination.append('<li class="page-item"><a href="javascript:getAlbumImagesData(' + pageSize + "," + i + "," + total + ',true);" class="page-link">' + (i + 1) + "</a></li>");
        }
    }
    if (end < pages) {
        pagination.append('<li class="page-item disabled"><a class="page-link" href="#" tabindex="-1">...</a></li>');
        pagination.append('<li class="page-item"><a href="javascript:getAlbumImagesData(' + pageSize + "," + (pages - 1) + "," + total + ',true)" class="page-link">' + pages + "</a></li>");
    }
    if (pageNumber < pages - 1) {
        pagination.append('<li class="page-item"><a href="javascript:getAlbumImagesData(' + pageSize + "," + (pageNumber + 1) + "," + total + ',true)" class="page-link"><i class="fas fa-angle-right"></i></a></li>');
    }
    pagerHolder.append(pagination);
}

function getNotifyData(pageSize, pageNumber, isPageChange) {
    var yafUserID = $("#NotifyListPlaceholder").data("userid");
    var pagedResults = {};
    pagedResults.UserId = yafUserID;
    pagedResults.PageSize = pageSize;
    pagedResults.PageNumber = pageNumber;
    var ajaxURL = $("#NotifyListPlaceholder").data("url") + "api/Notify/GetNotifications";
    $.ajax({
        type: "POST",
        url: ajaxURL,
        data: JSON.stringify(pagedResults),
        contentType: "application/json; charset=utf-8",
        dataType: "json",
        success: function(data) {
            $("#NotifyListPlaceholder ul").empty();
            $("#Loader").hide();
            if (data.AttachmentList.length > 0) {
                $("#MarkRead").removeClass("d-none").addClass("d-block");
                $.each(data.AttachmentList, function(id, data) {
                    var list = $("#NotifyListPlaceholder ul"), listItem = $('<li class="list-group-item list-group-item-action small text-wrap" style="width:15rem;" />');
                    listItem.append(data.FileName);
                    list.append(listItem);
                });
                setPageNumberNotify(pageSize, pageNumber, data.TotalRecords);
                if (isPageChange) {
                    jQuery(".notify-toggle").dropdown("toggle");
                }
            }
        },
        error: function(request) {
            $("#Loader").hide();
            $("#NotifyListPlaceholder").html(request.statusText).fadeIn(1e3);
        }
    });
}

function setPageNumberNotify(pageSize, pageNumber, total) {
    var pages = Math.ceil(total / pageSize);
    var pagerHolder = $("#NotifyListPager"), pagination = $('<ul class="pagination pagination-sm" />');
    pagerHolder.empty();
    pagination.wrap('<nav aria-label="Attachments Page Results" />');
    if (pageNumber > 0) {
        pagination.append('<li class="page-item"><a href="javascript:getNotifyData(' + pageSize + "," + (pageNumber - 1) + "," + total + ',true)" class="page-link"><i class="fas fa-angle-left"></i></a></li>');
    }
    var start = pageNumber - 2;
    var end = pageNumber + 3;
    if (start < 0) {
        start = 0;
    }
    if (end > pages) {
        end = pages;
    }
    if (start > 0) {
        pagination.append('<li class="page-item"><a href="javascript:getNotifyData(' + pageSize + "," + 0 + "," + total + ', true);" class="page-link">1</a></li>');
        pagination.append('<li class="page-item disabled"><a class="page-link" href="#" tabindex="-1">...</a></li>');
    }
    for (var i = start; i < end; i++) {
        if (i === pageNumber) {
            pagination.append('<li class="page-item active"><span class="page-link">' + (i + 1) + "</span>");
        } else {
            pagination.append('<li class="page-item"><a href="javascript:getNotifyData(' + pageSize + "," + i + "," + total + ',true);" class="page-link">' + (i + 1) + "</a></li>");
        }
    }
    if (end < pages) {
        pagination.append('<li class="page-item disabled"><a class="page-link" href="#" tabindex="-1">...</a></li>');
        pagination.append('<li class="page-item"><a href="javascript:getNotifyData(' + pageSize + "," + (pages - 1) + "," + total + ',true)" class="page-link">' + pages + "</a></li>");
    }
    if (pageNumber < pages - 1) {
        pagination.append('<li class="page-item"><a href="javascript:getNotifyData(' + pageSize + "," + (pageNumber + 1) + "," + total + ',true)" class="page-link"><i class="fas fa-angle-right"></i></a></li>');
    }
    pagerHolder.append(pagination);
}

jQuery(document).ready(function() {
    $("a.btn-login,input.btn-login").click(function() {
        $(this).html("<span class='spinner-border spinner-border-sm' role='status' aria-hidden='true'></span> Loading...");
    });
    $(".dropdown-menu a.dropdown-toggle").on("show.bs.dropdown", function() {
        var $el = $(this);
        var $parent = $el.parents(".dropdown-menu");
        var parentDropDown = $parent.prev();
        var $subMenu = $el.next();
        if (!$subMenu.hasClass("show")) {
            $(".dropdown-menu").find(".show").removeClass("show");
        }
        if (!$parent.hasClass("show")) {
            parentDropDown.dropdown("show");
        }
        $subMenu.toggleClass("show");
        $subMenu.css({
            top: $el[0].offsetTop - 10,
            left: $el.outerWidth() - 4
        });
        return false;
    });
    $("input[type='number']").each(function() {
        if ($(this).hasClass("form-pager")) {
            var holder = $(this).closest(".mb-3");
            $(this).TouchSpin({
                min: holder.data("min"),
                max: holder.data("max")
            });
        } else {
            $(this).TouchSpin({
                max: 2147483647
            });
        }
    });
    jQuery(".serverTime-Input").TouchSpin({
        min: -720,
        max: 720
    });
    $(".yafnet .select2-select").each(function() {
        $(this).select2({
            width: "100%",
            theme: "bootstrap4",
            placeholder: $(this).attr("placeholder")
        });
    });
    if ($(".select2-image-select").length) {
        var selected = $(".select2-image-select").val();
        var groups = {};
        $(".yafnet .select2-image-select option[data-category]").each(function() {
            var sGroup = $.trim($(this).attr("data-category"));
            groups[sGroup] = true;
        });
        $.each(groups, function(c) {
            $(".yafnet .select2-image-select").each(function() {
                $(this).find("option[data-category='" + c + "']").wrapAll('<optgroup label="' + c + '">');
            });
        });
        $(".select2-image-select").val(selected);
    }
    jQuery(".yafnet .select2-image-select").select2({
        width: "100%",
        theme: "bootstrap4",
        allowClear: false,
        dropdownAutoWidth: true,
        templateResult: formatState,
        templateSelection: formatState
    });
    if (jQuery("#PostAttachmentListPlaceholder").length) {
        var pageSize = 5;
        var pageNumber = 0;
        getPaginationData(pageSize, pageNumber, false);
    }
    if (jQuery("#SearchResultsPlaceholder").length) {
        jQuery(".searchInput").keypress(function(e) {
            var code = e.which;
            if (code === 13) {
                e.preventDefault();
                var pageNumberSearch = 0;
                getSearchResultsData(pageNumberSearch);
            }
        });
    }
    $(".dropdown-notify").on("show.bs.dropdown", function() {
        var pageSize = 5;
        var pageNumber = 0;
        getNotifyData(pageSize, pageNumber, false);
    });
    $(".form-check > input").addClass("form-check-input");
    $(".form-check li > input").addClass("form-check-input");
    $(".form-check > label").addClass("form-check-label");
    $(".form-check li > label").addClass("form-check-label");
    $(".img-user-posted").on("error", function() {
        $(this).parent().parent().hide();
    });
});

document.addEventListener("DOMContentLoaded", function() {
    var popoverTriggerList = [].slice.call(document.querySelectorAll(".thanks-popover"));
    popoverTriggerList.map(function(popoverTriggerEl) {
        return new bootstrap.Popover(popoverTriggerEl, {
            template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body popover-body-scrollable"></div></div>'
        });
    });
    $(".thanks-popover").on("show.bs.popover", function() {
        var messageId = $(this).data("messageid");
        var url = $(this).data("url");
        $.ajax({
            url: url + "/ThankYou/GetThanks/" + messageId,
            type: "POST",
            contentType: "application/json;charset=utf-8",
            cache: true,
            success: function(response) {
                $("#popover-list-" + messageId).html(response.ThanksInfo);
            }
        });
    });
    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.map(function(tooltipTriggerEl) {
        return new bootstrap.Tooltip(tooltipTriggerEl);
    });
    [].forEach.call(document.querySelectorAll(".attachedImage"), function(imageLink) {
        var messageId = imageLink.parentNode.id;
        imageLink.setAttribute("data-gallery", "#blueimp-gallery-" + messageId);
    });
});

jQuery(document).ready(function() {
    $(".list-group-item-menu, .message").each(function() {
        var isMessageContext = !!$(this).hasClass("message");
        var contextMenu = $(this).find(".context-menu");
        var messageID = $(this).find(".selectionQuoteable").attr("id");
        if (window.matchMedia("only screen and (max-width: 760px)").matches) {
            delete Hammer.defaults.cssProps.userSelect;
            Hammer($(this)[0], {
                prevent_default: false,
                stop_browser_behavior: false
            }).on("press", function(e) {
                if (isMessageContext) {
                    var selectedText = getSelectedMessageText();
                    if (selectedText.length) {
                        var searchItem = contextMenu.find(".item-search");
                        if (searchItem.length) {
                            searchItem.remove();
                        }
                        var selectedItem = contextMenu.find(".item-selected-quoting");
                        if (selectedItem.length) {
                            selectedItem.remove();
                        }
                        var selectedDivider = contextMenu.find(".selected-divider");
                        if (selectedDivider.length) {
                            selectedDivider.remove();
                        }
                        if (contextMenu.data("url").length) {
                            contextMenu.prepend("<a href=\"javascript:goToURL('" + messageID + "','" + selectedText + "','" + contextMenu.data("url") + '\')" class="dropdown-item item-selected-quoting"><i class="fas fa-quote-left fa-fw"></i>&nbsp;' + contextMenu.data("quote") + "</a>");
                        }
                        contextMenu.prepend('<div class="dropdown-divider selected-divider"></div>');
                        contextMenu.prepend("<a href=\"javascript:searchText('" + selectedText + '\')" class="dropdown-item item-search"><i class="fas fa-search fa-fw"></i>&nbsp;' + contextMenu.data("search") + ' "' + selectedText + '"</a>');
                    }
                }
                contextMenu.css({
                    display: "block"
                }).addClass("show").offset({
                    left: e.srcEvent.pageX,
                    top: e.srcEvent.pageY
                });
            });
        }
        $(this).on("contextmenu", function(e) {
            if (isMessageContext) {
                var selectedText = getSelectedMessageText();
                if (selectedText.length) {
                    var searchItem = contextMenu.find(".item-search");
                    if (searchItem.length) {
                        searchItem.remove();
                    }
                    var selectedItem = contextMenu.find(".item-selected-quoting");
                    if (selectedItem.length) {
                        selectedItem.remove();
                    }
                    var selectedDivider = contextMenu.find(".selected-divider");
                    if (selectedDivider.length) {
                        selectedDivider.remove();
                    }
                    if (contextMenu.data("url").length) {
                        contextMenu.prepend("<a href=\"javascript:goToURL('" + messageID + "','" + selectedText + "','" + contextMenu.data("url") + '\')" class="dropdown-item item-selected-quoting"><i class="fas fa-quote-left fa-fw"></i>&nbsp;' + contextMenu.data("quote") + "</a>");
                    }
                    contextMenu.prepend('<div class="dropdown-divider selected-divider"></div>');
                    contextMenu.prepend("<a href=\"javascript:searchText('" + selectedText + '\')" class="dropdown-item item-search"><i class="fas fa-search fa-fw"></i>&nbsp;' + contextMenu.data("search") + ' "' + selectedText + '"</a>');
                }
            }
            contextMenu.removeClass("show").hide();
            contextMenu.css({
                display: "block"
            }).addClass("show").offset({
                left: e.pageX,
                top: e.pageY
            });
            return false;
        }).on("click", function() {
            contextMenu.removeClass("show").hide();
        });
        $(this).find(".context-menu a").on("click", function(e) {
            if ($(this).data("toggle") !== undefined && $(this).data("toggle") == "confirm") {
                e.preventDefault();
                var link = $(this).attr("href");
                var text = $(this).data("title");
                var title = $(this).html();
                var blockUI = $(this).data("confirm-event");
                bootbox.confirm({
                    centerVertical: true,
                    title: title,
                    message: text,
                    buttons: {
                        confirm: {
                            label: '<i class="fa fa-check"></i> ' + $(this).data("yes"),
                            className: "btn-success"
                        },
                        cancel: {
                            label: '<i class="fa fa-times"></i> ' + $(this).data("no"),
                            className: "btn-danger"
                        }
                    },
                    callback: function(confirmed) {
                        if (confirmed) {
                            document.location.href = link;
                            if (typeof blockUI !== "undefined") {
                                window[blockUI]();
                            }
                        }
                    }
                });
            }
            contextMenu.removeClass("show").hide();
        });
        $("body").click(function() {
            contextMenu.removeClass("show").hide();
        });
    });
});

function goToURL(messageId, input, url) {
    window.location.href = url + "test" + "&q=" + messageId + "&text=" + encodeURIComponent(input);
}

function searchText(input) {
    let a = document.createElement("a");
    a.target = "_blank";
    a.href = "https://www.google.com/search?q=" + encodeURIComponent(input);
    a.click();
}

function getSelectedMessageText() {
    var text = "";
    var sel = window.getSelection();
    if (sel.rangeCount) {
        var container = document.createElement("div");
        for (var i = 0, len = sel.rangeCount; i < len; ++i) {
            container.appendChild(sel.getRangeAt(i).cloneContents());
        }
        text = container.textContent || container.innerText;
    }
    return text.replace(/<p[^>]*>/gi, "\n").replace(/<\/p>|  /gi, "").replace("(", "").replace(")", "").replace('"', "").replace("'", "").replace("'", "").replace(";", "").trim();
}